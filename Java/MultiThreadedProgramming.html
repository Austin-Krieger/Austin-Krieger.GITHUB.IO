<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Learning Java</title>
    <link rel="stylesheet" type="text/css" href="../styles/Styles.css">
    <link rel="stylesheet" type="text/css" href="../styles/SideNav.css">
    <link rel="stylesheet" type="text/css" href="../styles/modal.css">
    <script type="text/javascript" src="../scripts/JSFunctions.js"></script>
    <link rel="icon" href="../images/ThirstyPenguin(Logo).ico">
</head>
<body>
<div class="navbar">
    <span style="font-size: 30px; cursor: pointer; padding-left: 10px; padding-top: 2px; float: left; color: white;" onclick="openNav()">&#9776;</span>
    <a href="index.html" style="float: left;">Home</a>
    <a href="ExceptionHandling.html">Previous</a>
    <a href="Collections.html" style="float: right;">Next</a>
</div>
<div id="Sidenav" class="sidenav">
    <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
    <a href="../index.html">Home</a>
    <a href="index.html">Java</a>
    <a href="../Roblox/index.html">Roblox</a>
    <a href="../Unity/index.html">Unity</a>
    <a href="../Perlenspiel/index.html">Perlenspiel</a>
    <a href="../Web/index.html">Web</a>
    <a href="../Modding/index.html">Modding</a>
</div>
<div id="closeSideNav">
<h1>Multi-threaded Programming</h1>
<div class="containButtons">
<button class="collapsible" id="autoClickBtn">Multi-threaded Programming (Add thread creation information)</button>
<div class="content">
    <!-- The Modal -->
    <div id="myModal" class="modal">
        <!-- The Close Button -->
        <span class="close">&times;</span>
        <!-- Modal Content (The Image) -->
        <img class="modal-content" id="img01">
        <!-- Modal Caption (Image Text) -->
        <div id="caption"></div>
    </div>
    <h2>Multi-threaded Programming</h2>
    <h3>Java Memory Model</h3>
    <p>Stack:</p>
    <ul>
        <li>Every thread running in the JVM has its own stack.</li>
        <li>Contains all the methods it has executed up to the current point of execution.</li>
        <li>Local variables of primitive data types are stored inside the stack.</li>
        <li>Object references are stored on the stack.</li>
    </ul>
    <p>Heap:</p>
    <ul>
        <li>Contains all objects created by your java application.</li>
        <li>Object member variables are stored on the heap along with the object itself.</li>
        <li>Instance variables are on the heap.</li>
        <li>Static/class variables are stored on the heap along with the class definition (stored in a different region) and can be referenced by all other threads that have a reference the the object</li>
    </ul>
    <h3>Race Condition</h3>
    <p>Race Condition: When two or more threads are trying to access the same resource. Gives inconsistent output.</p>
    <h3>Thread Safety</h3>
    <p>Objects created locally and not shared with other threads are thread safe. Local primitive variables are thread safe.</p>
    <p>A resource that never escapes the control of the thread is safe.</p>
    <h3>Immutability</h3>
    <p>Immutable object: An object whose state cannot be modified after it's created.</p>
    <p>&emsp;Can also be used to achieve thread safety.</p>
    <p>Objects shared between threads are never updated by any of the threads by making the shared objects immutable, and thereby thread safe.</p>
    <p>The reference to the immutable object may not be thread safe so we use synchronization.</p>
    <h3>Synchronization</h3>
    <p>Used when two threads need to interact with a shared resource.</p>
    <h3>Thread Local</h3>
    <p>Allows you to create variables that can only be read and written to by that class.</p>
    <p>&emsp;private static final ThreadLocal&lt;&gt;</p>
    <p>If you want to access a thread local set by the parent class, then you need to use InheritableThreadLocal class.</p>
    <h3>Volatile Keyword</h3>
    <p>Used to ensure we are reading from and getting the data from the main memory and not the cache memory.</p>
    <p>Gets the data from the cache memory and updates the main memory.</p>
    <p>This is an expensive process, since cache memory is used for efficiency this should only be used with shared resources.</p>
    <p>&emsp;private volatile String spaces;</p>
    <h3>Daemon Thread</h3>
    <p>Low priority thread that keeps running in the background to perform background tasks like (garbage collection).</p>
    <div class="scrollableTable"><table>
        <tr>
            <td>setDaemon()</td>
            <td>Set to true on a thread to make it a daemon thread.</td>
        </tr>
        <tr>
            <td>isDaemon()</td>
            <td>Check if a thread is a daemon thread.</td>
        </tr>
    </table></div>
    <h3>Thread Priority</h3>
    <p>Thread priority gives a thread more cpu preference. The default value is 5.</p>
</div>
&nbsp;
<button class="collapsible">Concurrency</button>
<div class="content">
    <h2>The Concurrency Utilities</h2>
    &nbsp;
    <div class="scrollableTable"><table>
        <tr>
            <td>Semaphore</td>
            <td>Controls access to a shared resource through the use of a counter.</td>
        </tr>
        <tr>
            <td rowspan="3">CountDownLatch</td>
            <td>Waits until a specified number of events have occurred.</td>
        </tr>
        <tr>
            <td>To wait on the latch, a thread calls await().</td>
        </tr>
        <tr>
            <td>Each call to countDown() decrements the count associated with the invoking object.</td>
        </tr>
        <tr>
            <td rowspan="2">CyclicBarrier</td>
            <td>Enables a group of threads to wait at a predefined execution point.</td>
        </tr>
        <tr>
            <td>When each thread reaches the barrier, have it call await() on that object pausing execution of the thread until all of the other threads also call await()..</td>
        </tr>
        <tr>
            <td>Exchanger</td>
            <td>Exchanges data between two threads.</td>
        </tr>
        <tr>
            <td>Phaser</td>
            <td>Synchronizes threads that advance through multiple phases of an operation.</td>
        </tr>
        <tr>
            <td>Executor</td>
            <td>Controls the execution of threads.</td>
        </tr>
        <tr>
            <td>ExecutorService</td>
            <td>The ExecutorService interface extends Executor by adding methods that help manage and control the execution of threads.</td>
        </tr>
        <tr>
            <td>Runnable</td>
            <td>The Runnable interface is implemented in order to execute threads. The threads created will not return a value. Preferable to Callable, because it avoids inheritance.</td>
        </tr>
        <tr>
            <td>Callable</td>
            <td>The Callable interface represents a thread that returns a value.</td>
        </tr>
        <tr>
            <td>Future</td>
            <td>A generic interface that represents the value that will be returned by a Callable object.</td>
        </tr>
        <tr>
            <td>TimeUnit Enumeration</td>
            <td>TimeUnit is an enumeration that is used to specify the granularity (or resolution) of the timing.</td>
        </tr>
        <tr>
            <td rowspan="2">Locks</td>
            <td>Objects that offer an alternative to using synchronized to control access to a shared resource.</td>
        </tr>
        <tr>
            <td>Before accessing a shared resource, the lock that protects that resource is acquired. When access to the resource is complete, the lock is released.</td>
        </tr>
        <tr>
            <td>Atomic Operations</td>
            <td>Methods that get, set, or compare the value of a variable in one uninterruptible (that is, atomic) operation.</td>
        </tr>
    </table></div>
    &nbsp;
    <button class="collapsible">Concurrency Overview </button>
    <div class="innerContent">
        <h2>"Concurrent Program"</h2>
        <p>Refers to a program that makes extensive, integral use of concurrently executing threads.</p>
        <p>For Example: A program that uses separate threads to simultaneously compute the partial results of a larger computation.</p>
        <p>New threads can be created by implementing Runnable or by extending Thread.</p>
        <p>Inter-thread communication is supported by the wait() and notify() methods that are defined by Object.</p>
        <h2>Concurrent API Packages</h2>
        <p>The concurrency utilities are contained in the java.util.concurrent package and in its two subpackages: java.util.concurrent.atomic and java.util.concurrent.locks.</p>
        <h2>java.util.concurrent</h2>
        <p>Defines the core features that support alternatives to the built-in approaches to synchronization and interthread communication.</p>
        <ul>
            <li>Synchronizers</li>
            <li>Executors</li>
            <li>Concurrent collections</li>
            <li>The Fork/Join Framework</li>
        </ul>
        <h2>Synchronizers</h2>
        &nbsp;
        <div class="scrollableTable"><table>
            <tr>
                <td>Semaphore</td>
                <td>Controls access to a shared resource through the use of a counter.</td>
            </tr>
            <tr>
                <td rowspan="3">CountDownLatch</td>
                <td>Waits until a specified number of events have occurred.</td>
            </tr>
            <tr>
                <td>To wait on the latch, a thread calls await().</td>
            </tr>
            <tr>
                <td>Each call to countDown() decrements the count associated with the invoking object.</td>
            </tr>
            <tr>
                <td rowspan="2">CyclicBarrier</td>
                <td>Enables a group of threads to wait at a predefined execution point.</td>
            </tr>
            <tr>
                <td>When each thread reaches the barrier, have it call await() on that object pausing execution of the thread until all of the other threads also call await()..</td>
            </tr>
            <tr>
                <td>Exchanger</td>
                <td>Exchanges data between two threads.</td>
            </tr>
            <tr>
                <td>Phaser</td>
                <td>Synchronizes threads that advance through multiple phases of an operation.</td>
            </tr>
        </table></div>
        &nbsp;
        <h2>Executors</h2>
        <p>Manage thread execution.</p>
        <p>At the top of the executor hierarchy is the Executor interface, which is used to initiate a thread.</p>
        <h2>ExecutorService</h2>
        <p>Extends Executor and provides methods that manage execution.</p>
        <div class="scrollableTable"><table>
            <tr>
                <td>ThreadPoolExecutor</td>
            </tr>
            <tr>
                <td>ScheduledThreadPoolExecutor</td>
            </tr>
            <tr>
                <td>ForkJoinPool</td>
            </tr>
        </table></div>
        &nbsp;
        <h2>The Future and Callable Interfaces</h2>
        <p>Future contains a value that is returned by a thread after it executes. "its value gets defined in the future", when the thread terminates.</p>
        <p>Callable defines a thread that returns a value.</p>
        <h2>Concurrent Collection Classes</h2>
        &nbsp;
        <div class="scrollableTable"><table>
            <tr>
                <td>ArrayBlockingQueue</td>
            </tr>
            <tr>
                <td>ConcurrentHashMap</td>
            </tr>
            <tr>
                <td>ConcurrentLinkedDeque</td>
            </tr>
            <tr>
                <td>ConcurrentLinkedQueue</td>
            </tr>
            <tr>
                <td>ConcurrentSkipListMap</td>
            </tr>
            <tr>
                <td>ConcurrentSkipListSet</td>
            </tr>
            <tr>
                <td>CopyOnWriteArrayList</td>
            </tr>
            <tr>
                <td>CopyOnWriteArraySet</td>
            </tr>
            <tr>
                <td>DelayQueue</td>
            </tr>
            <tr>
                <td>LinkedBlockingDeque</td>
            </tr>
            <tr>
                <td>LinkedBlockingQueue</td>
            </tr>
            <tr>
                <td>LinkedTransferQueue</td>
            </tr>
            <tr>
                <td>PriorityBlockingQueue</td>
            </tr>
            <tr>
                <td>SynchronousQueue</td>
            </tr>
        </table></div>
        <p>These collections work much like the other collections except that they provide concurrency support.</p>
        <h2>TimeUnit Enumeration</h2>
        <p>To better handle thread timing, java.util.concurrent define the TimeUnit enumeration.</p>
        <h2>java.util.concurrent.atomic</h2>
        <p>Facilitates the use of variables in a concurrent environment.</p>
        <p>It provides a means of efficiently updating the value of a variable without the use of locks. Through the use of classes, such as AtomicInteger and AtomicLong, and methods, such as compareAndSet(), decrementAndGet(), and getAndSet().</p>
        <h2>java.util.concurrent.locks</h2>
        <p>Provides an alternative to the use of synchronized methods.</p>
        <p>At the core of this alternative is the Lock interface, which defines the basic mechanism used to acquire and relinquish access to an object.</p>
        <div class="scrollableTable"><table>
            <tr>
                <td>lock()</td>
            </tr>
            <tr>
                <td>tryLock()</td>
            </tr>
            <tr>
                <td>unlock()</td>
            </tr>
        </table></div>
        <p>The advantage to using these methods is greater control over synchronization.</p>
        <h2>ThreadLocal</h2>
        <p>Every thread has its own ThreadLocal variable and they can use it's get() and set() methods to get the default value or change it's value local to the Thread.</p>
        <p>ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread.</p>
    </div>
    &nbsp;
    <h2>Synchronization Objects</h2>
    <p>Synchronization objects are supported by the Semaphore, CountDownLatch, CyclicBarrier, Exchanger, and Phaser classes.</p>
    <button class="collapsible">Semaphore</button>
    <div class="innerContent">
        <h2>Semaphore</h2>
        <p>Controls access to a shared resource through the use of a counter.</p>
        <ul>
            <li>If the counter is > 0 then access is allowed.</li>
            <li>If the counter = 0 then access is denied.</li>
        </ul>
        <p>The counter is counting permits that allow access to the shared resource.</p>
        <p>Thus, to access the resource, a thread must be granted a permit from the semaphore.</p>
        <h3>Constructors:</h3>
        <ol>
            <li>Semaphore(int num)</li>
            <li>Semaphore(int num, boolean how)</li>
        </ol>
        <p>num specifies the number of permits or threads that can have access to the resource at a given time.</p>
        <p>By setting how to true, you can ensure that waiting threads are granted a permit in the order in which they requested access.</p>
        <h3>To acquire a permit, call the acquire() method</h3>
        <ol>
            <li>void acquire() throws InterruptedException</li>
            <li>void acquire(int num) throws InterruptedException</li>
        </ol>
        <h3>To release a permit, call the release() method</h3>
        <ol>
            <li>void release()</li>
            <li>void release(int num)</li>
        </ol>
    </div>
    &nbsp;
    <button class="collapsible">CountDownLatch</button>
    <div class="innerContent">
        <h2>CountDownLatch</h2>
        <p>A CountDownLatch is initially created with a count of the number of events that must occur before the latch is released.</p>
        <p>CountDownLatch(int num) <mark>// num specifies the number of events that must occur in order for the latch to open.</mark></p>
        <h3>To wait on the latch, a thread calls await()</h3>
        <ol>
            <li>void await() throws InterruptedException</li>
            <li>boolean await(long wait, TimeUnit tu) throws InterruptedException</li>
        </ol>
        <p>The second form waits only for the period of time specified by wait in the unit of time specified by tu.</p>
        <h3>To signal an event, call the countDown() method</h3>
        <ol>
            <li>void countDown() <mark>// Each call to countDown() decrements the count associated with the invoking object.</mark></li>
        </ol>
        <div class="code" id="concurrency1"><button class="copy" onclick="copyText('concurrency1')">Copy</button><br><p>
            import java.util.concurrent.CountDownLatch;<br>
            public class CDLDemo {<br>
            public static void main(String[] args) {<br><br>
            &emsp;&emsp;CountDownLatch cdl = new CountDownLatch(5);<br>
            &emsp;&emsp;System.out.println("Starting");<br>
            &emsp;&emsp;new MyThread(cdl);<br><br>
            &emsp;&emsp;try {<br>
            &emsp;&emsp;&emsp;cdl.await();<br>
            &emsp;&emsp;} catch (InterruptedException e) {<br>
            &emsp;&emsp;&emsp;System.out.println(e);<br>
            &emsp;&emsp;}<br><br>
            &emsp;&emsp;System.out.println("Done");<br>
            &emsp;}<br>
            }<br><br>
            class MyThread implements Runnable {<br>
            &emsp;CountDownLatch latch;<br><br>
            &emsp;MyThread(CountDownLatch c) {<br>
            &emsp;&emsp;latch = c;<br>
            &emsp;&emsp;new Thread(this).start();<br>
            &emsp;}<br><br>
            &emsp;@Override<br>
            &emsp;public void run() {<br>
            &emsp;&emsp;for (int i = 0; i &lt; 5; i++) {<br>
            &emsp;&emsp;&emsp;System.out.println(i);<br>
            &emsp;&emsp;&emsp;latch.countDown(); <mark>// decrement count</mark><br>
            &emsp;&emsp;}<br>
            &emsp; }<br>
            }
        </p>
        </div>
    </div>
    &nbsp;
    <button class="collapsible">CyclicBarrier</button>
    <div class="innerContent">
        <h2>CyclicBarrier</h2>
        <p>Used when a set of two or more threads must wait at a predetermined execution point until all threads in the set have reached that point.</p>
        <p>It enables you to define a synchronization object that suspends until the specified number of threads has reached the barrier point.</p>
        <h3>Constructors:</h3>
        <ol>
            <li>CyclicBarrier(int numThreads)</li>
            <li>CyclicBarrier(int numThreads, Runnable action)</li>
        </ol>
        <p>numThreads specifies the number of threads that must reach the barrier before execution continues.</p>
        <p>In the second form, action specifies a thread that will be executed when the barrier is reached.</p>
        <h3>Creating a CyclicBarrier</h3>
        <ol>
            <li>First, create a CyclicBarrier object, specifying the number of threads that you will be waiting for.</li>
            <li>Next, when each thread reaches the barrier, have it call await() on that object. This will pause execution of the thread until all of the other threads also call await().</li>
            <li>Once the specified number of threads has reached the barrier, await() will return and execution will resume.</li>
        </ol>
        <h3>The await() method</h3>
        <ol>
            <li>int await() throws InterruptedException, BrokenBarrierException</li>
            <li>int await(long wait, TimeUnit tu) throws InterruptedException, BrokenBarrierException, TimeoutException</li>
        </ol>
        <p>First form waits until all the threads have reached the barrier point.</p>
        <p>Second form waits only for the period of time specified by wait.</p>
        <p>A CyclicBarrier can be reused because it will release waiting threads each time the specified number of threads calls await().</p>
        <p>For Example: This will create a new CyclicBarrier and perform the first 3 thread executions, reach the barrier, and then perform the next 3, and reach the barrier again.</p>
        <div class="code" id="concurrency2"><button class="copy" onclick="copyText('concurrency2')">Copy</button><br><p>
            CyclicBarrier cb = new CyclicBarrier(3, new BarAction());<br>
            &emsp;new MyThread(cb, "A");<br>
            &emsp;new MyThread(cb, "B");<br>
            &emsp;new MyThread(cb, "C");<br>
            &emsp;new MyThread(cb, "X");<br>
            &emsp;new MyThread(cb, "Y");<br>
            &emsp;new MyThread(cb, "Z");
        </p>
        </div>
        <div class="center"><img src="../images/JavaImages/cyclic-barrier.png" alt="CyclicBarrier Image" onclick="displayModal(this)" style="max-height: 400px;"></div>
    </div>
    &nbsp;
    <button class="collapsible">Exchanger</button>
    <div class="innerContent">
        <h2>Exchanger</h2>
        <p>Designed the simplify the exchange of data between two threads.</p>
        <p>It simply waits until two separate threads call its exchange() method. When that occurs, it exchanges the data supplied by the threads.</p>
        <p>For Example: One thread might prepare a buffer for receiving information over a network connection. Another thread might fill that buffer with the information from the connection. Each time a new buffer is needed, an exchange is made.</p>
        <p>Exchanger &lt;V&gt; <mark>// Here, V specifies the type of the data being exchanged.</mark></p>
        <h3>Constructors</h3>
        <ol>
            <li>V exchange(V objRef) throws InterruptedException</li>
            <li>V exchange(V objRef, long wait, TimeUnit tu) throws InterruptedException, TimeoutException</li>
        </ol>
        <p>objRef is a reference to the data to exchange. The data received from the other thread is returned.</p>
        <p>The second form allows a time-out period to be specified.</p>
        <div class="center"><img src="../images/JavaImages/exchanger.png" alt="Exchanger Image" onclick="displayModal(this)"></div>
    </div>
    &nbsp;
    <button class="collapsible">Phaser</button>
    <div class="innerContent">
        <h2>Phaser</h2>
        <p>Primary purpose is to enable the synchronization of threads that represent one or more phases of activity.</p>
        <p>For Example: You might have a set of threads that implement three phases of an order-processing application.</p>
        <ol>
            <li>First phase, separate threads are used to validate customer information, check inventory, and confirm pricing.</li>
            <li>Second phase, two threads that compute shipping costs and all applicable tax.</li>
            <li>Final phase, confirms payment and determines estimated shipping time.</li>
        </ol>
        <p>A Phaser works a bit like a CyclicBarrier, described earlier, except that it supports multiple phases. As a result, Phaser lets you define a synchronization object that waits until a specific phase has completed.</p>
        <div class="scrollableTable"><table>
            <tr>
                <td>Phaser()</td>
                <td></td>
            </tr>
            <tr>
                <td>Phaser(int numParties)</td>
                <td></td>
            </tr>
            <tr>
                <td>register()</td>
                <td>To register parties after a Phaser has been constructed.</td>
            </tr>
            <tr>
                <td>int arrive()</td>
                <td>To signal that a party has completed a phase.</td>
            </tr>
            <tr>
                <td>arriveAndAwaitAdvance()</td>
                <td>If you want to indicate the completion of a phase and then wait until all other registrants have also completed that phase.</td>
            </tr>
            <tr>
                <td>arriveAndDeregister()</td>
                <td>A thread can arrive and then deregister itself, it returns the current phase number or a negative value if the phaser has been terminated.</td>
            </tr>
            <tr>
                <td>final int getPhase()</td>
                <td>To obtain the current phase number</td>
            </tr>
            <tr>
                <td>protected boolean onAdvance(int phase, int numParties)</td>
                <td>It is possible to take control of precisely what happens when a phase advance occurs. To terminate the phaser, onAdvance() must return true. To keep the phaser alive, onAdvance() must return false.</td>
            </tr>
        </table></div>
        <ol>
            <li>First, create a new instance of Phaser.</li>
            <li>Next, register one or more parties with the phaser, either by calling register() or by specifying the number of parties in the constructor.</li>
            <li>For each registered party, have the phaser wait until all registered parties complete a phase.</li>
            <li>A party signals this by calling one of a variety of methods supplied by Phaser, such as arrive() or arriveAndAwaitAdvance().</li>
            <li>After all parties have arrived, the phase is complete, and the phaser can move on to the next phase (if there is one), or terminate.</li>
        </ol>
    </div>
    &nbsp;
    <h2>Executor Services and more...</h2>
    &nbsp;
    <button class="collapsible">Executors (ExecutorService, Runnable, Callable, Future)</button>
    <div class="innerContent">
        <h2>Executor</h2>
        <p>Controls the execution of threads.</p>
        <p>void execute(Runnable thread) <mark>// execute() starts the specified thread.</mark></p>
        <h3>ExecutorService</h3>
        <p>The ExecutorService interface extends Executor by adding methods that help manage and control the execution of threads.</p>
        <p>Represents an asynchronous execution mechanism which is capable of executing tasks concurrently in the background.</p>
        <div class="scrollableTable"><table>
            <tr>
                <td>ThreadPoolExecutor</td>
                <td>Implements the Executor and ExecutorService interfaces and provides support for a managed pool of threads.</td>
            </tr>
            <tr>
                <td>ScheduledThreadPoolExecutor</td>
                <td>Also implements the ScheduledExecutorService interface to allow a pool of threads to be scheduled.</td>
            </tr>
            <tr>
                <td>ForkJoinPool</td>
                <td>Implements the Executor and ExecutorService interfaces and is used by the Fork/Join Framework.</td>
            </tr>
        </table></div>
        <h3>Task Delegation</h3>
        <p>Once the thread has delegated the task to the ExecutorService, the thread continues its own execution independent of the execution of that task.</p>
        <p>The ExecutorService then executes the task concurrently, independently of the thread that submitted the task.</p>
        <div class="center"><img src="../images/JavaImages/executor-service.png" alt="Executor Service Image" onclick="displayModal(this)" style="max-height: 400px;"></div>
        <h3>Example:</h3>
        <div class="code" id="concurrency3"><button class="copy" onclick="copyText('concurrency3')">Copy</button><br><p>
            <mark>// First an ExecutorService is created using the Executors newFixedThreadPool() factory method. This creates a thread pool with 10 threads executing tasks.</mark><br>
            ExecutorService executorService = Executors.newFixedThreadPool(10);<br><br>
            <mark>// Second, an anonymous implementation of the Runnable interface is passed to the execute() method. This causes the Runnable to be executed by one of the threads in the ExecutorService.</mark><br>
            executorService.execute(new Runnable() {<br>
            &emsp;public void run() {<br>
            &emsp;&emsp;System.out.println("Asynchronous task");<br>
            &emsp;}<br>
            });<br><br>
            <mark>// Shut down executor service</mark><br>
            executorService.shutdown();
        </p>
        </div>
        <h3>Java ExecutorService Implementations</h3>
        <p>The Java ExecutorService is very similar to a thread pool. In fact, the implementation of the ExecutorService interface present in the java.util.concurrent package is a thread pool implementation.</p>
        <p>Since ExecutorService is an interface, you need to use its implementations in order to make any use of it.</p>
        <ol>
            <li>ThreadPoolExecutor</li>
            <li>ScheduledThreadPoolExecutor</li>
        </ol>
        <h3>Thread Pool</h3>
        <p>Provides a set of threads that is used to execute various tasks. Instead of each task using its own thread, the threads in the pool are used.</p>
        <p>This reduces the overhead associated with creating many separate threads.</p>
        <p>Most often you will want to obtain an executor by calling one of the following static factory methods defined by the Executors utility class.</p>
        <div class="scrollableTable"><table>
            <tr>
                <td>static ExecutorService newCachedThreadPool()</td>
                <td>Creates a thread pool that adds threads as needed but reuses threads if possible.</td>
            </tr>
            <tr>
                <td>static ExecutorService newFixedThreadPool(int numThreads)</td>
                <td>Creates a thread pool that consists of a specified number of threads.</td>
            </tr>
            <tr>
                <td>static ScheduledExecutorService newScheduledThreadPool(int numThreads)</td>
                <td>Creates a thread pool that supports thread scheduling.</td>
            </tr>
        </table></div>
        <p>Each returns a reference to an ExecutorService that can be used to manage the pool.</p>
        <h3>Creating an ExecutorService</h3>
        <div class="scrollableTable"><table>
            <tr>
                <td>ExecutorService executorService1 = Executors.newSingleThreadExecutor();</td>
            </tr>
            <tr>
                <td>ExecutorService executorService2 = Executors.newFixedThreadPool(10);</td>
            </tr>
            <tr>
                <td>ExecutorService executorService3 = Executors.newScheduledThreadPool(10);</td>
            </tr>
        </table></div>
        <h3>ExecutorService Usage</h3>
        <p>There are a few different ways to delegate tasks for execution to an ExecutorService.</p>
        <div class="scrollableTable"><table>
            <tr>
                <td>execute(Runnable)</td>
                <td>Takes a java.lang.Runnable object and executes it asynchronously.</td>
            </tr>
            <tr>
                <td>submit(Runnable)</td>
                <td>Also takes a Runnable implementation, but returns a Future object. This Future object can be used to check if the Runnable has finished executing.</td>
            </tr>
            <tr>
                <td>submit(Callable)</td>
                <td>Takes a Java Callable instead of a Runnable. The Callable's result can be obtained via the Java Future object returned by the submit(Callable) method.</td>
            </tr>
            <tr>
                <td>invokeAny(...)</td>
                <td>Takes a collection of Callable objects, or subinterfaces of Callable. returns the result of one of the Callable objects. no guarantee which one though. If one of the tasks complete (or throws an exception), the rest of the Callable's are cancelled.</td>
            </tr>
            <tr>
                <td>invokeAll(...)</td>
                <td>Invokes all of the Callable objects you pass to it in the collection passed as a parameter. Returns a list of Future objects via which you can obtain the results of the executions of each Callable.</td>
            </tr>
        </table></div>
        <h3>Runnable vs. Callable</h3>
        <p>Both interfaces represents a task that can be executed concurrently by a thread or an ExecutorService. Both interfaces only have a single method.</p>
        <p>Runnable Interface Declaration</p>
        <div class="code" id="concurrency4"><button class="copy" onclick="copyText('concurrency4')">Copy</button><br><p>
            public interface Runnable {<br>
            &emsp;public void run();<br>
            }
        </p>
        </div>
        <p>Callable Interface Declaration</p>
        <div class="code" id="concurrency5"><button class="copy" onclick="copyText('concurrency5')">Copy</button><br><p>
            public interface Callable{<br>
            &emsp;public Object call() throws Exception;<br>
            }
        </p>
        </div>
        <p>The main difference is that the call() method can return an Object from the method call.</p>
        <p>Another difference between call() and run() is that call() can throw an exception.</p>
        <p>If you need to submit a task to a Java ExecutorService and you need a result from the task, then you need to make your task implement the Callable interface. Otherwise your task can just implement the Runnable interface.</p>
        <p>A Java Callable is different from a Runnable in that the Runnable interface's run() method does not return a value, and it cannot throw checked exceptions (only RuntimeExceptions).</p>
        <p>Additionally, a Runnable was originally designed for long running concurrent execution, e.g. running a network server concurrently, or watching a directory for new files. The Callable interface is more designed for one-off tasks that return a single result.</p>
        <h3>shutdown()</h3>
        <p>A call to shutdown() is important. If it were not present in the program, then the program would not terminate because the executor would remain active.</p>
        <button class="collapsible">Callable</button>
        <div class="innerContent">
            <h2>Callable</h2>
            <p>The Callable interface represents a thread that returns a value.</p>
            <p>An application can use Callable objects to compute results that are then returned to the invoking thread.</p>
            <p>It can also be used to run a thread that returns a status code that indicates the successful completion of the thread.</p>
            <h3>Callable is a generic interface that is defined like this:</h3>
            <p>interface Callable &lt;V&gt; <mark>// V indicates the type of data returned by the task.</mark></p>
            <h3>Callable defines only one method</h3>
            <p>V call() throws Exception</p>
            <p>Inside call() you define the task that you want performed. After that task completes, you return the result. If the result cannot be computer, call() must throw an exception.</p>
            <p>A Callable task is executed by an ExecutorService, by calling its submit() method.</p>
            <p>&lt;T&gt;Future&lt;T&gt;submit(Callable&lt;T&gt; task)</p>
            <p>Task is the Callable object that will be executed in its own thread. The result is returned through an object of type Future</p>
            <h3>Java Callable</h3>
            <p>The Java Callable interface, java.util.concurrent.Callable, represents an asynchronous task which can be executed by a separate thread. For instance, it is possible to submit a Callable object to a Java ExecutorService which will then execute it asynchronously.</p>
            <h3>Java Callable Interface Definition</h3>
            <p>The Java Callable interface is quite simple, it contains a single method named call().</p>
            <p>The call() method is called in order to execute the asynchronous task. The call() method can return a result. If the task is executed asynchronously, the result is typically propagated back to the creator of the task via a Java Future.</p>
            <div class="code" id="concurrency6"><button class="copy" onclick="copyText('concurrency6')">Copy</button><br><p>
                public interface Callable&lt;V&gt; {<br>
                &emsp;V call() throws Exception;<br>
                }
            </p>
            </div>
        </div>
        &nbsp;
        <button class="collapsible">Future</button>
        <div class="innerContent">
            <h2>Future</h2>
            <p>A generic interface that represents the value that will be returned by a Callable object.</p>
            <p>Because this value is obtained at some future time, the name Future is appropriate.</p>
            <p>interface Future&lt;V&gt; <mark>// V specifies the type of the result.</mark></p>
            <p>A Java Future, java.util.concurrent.Future, represents the result of an asynchronous computation.</p>
            <p>When the asynchronous task is created, a Java Future object is returned.</p>
            <p>Once the asynchronous task completes, the result can be accessed via the Future object returned when the task was started.</p>
            <h3>To obtain the returned value, you will call Future's get() method.</h3>
            <ol>
                <li>V get() throws InterruptedException, ExecutionException</li>
                <li>V get(long wait, TimeUnit tu) throws InterruptedException, ExecutionException, TimeoutException</li>
            </ol>
            <p>The first form waits for the result indefinitely. The second form allows you to specify a timeout period in wait. The units of wait are passed in tu, which is an object of the TimeUnit enumeration.</p>
            <ol>
                <li>boolean cancel(boolean mayInterruptIfRunning)</li>
                <li>boolean isCancelled();</li>
                <li>boolean isDone();</li>
            </ol>
            <h3>Cancel Task</h3>
            <p>You can cancel a task (Runnable or Callable) submitted to a Java ExecutorService by calling the cancel() method on the Future returned when the task is submitted.</p>
            <p>Cancelling the task is only possible if the task has not yet started executing.</p>
            <p>future.cancel();</p>
            <h3>Check if task is done.</h3>
            <p>You can check if the asynchronous task is done (and a result available) by calling the Future isDone() method.</p>
            <div class="code" id="concurrency7"><button class="copy" onclick="copyText('concurrency7')">Copy</button><br><p>
                if(future.isDone()) {<br>
                &emsp;Object result = future.get();<br>
                } else {<br>
                &emsp;<mark>// do something else</mark><br>
                }
            </p>
            </div>
            <h3>Check if task is cancelled</h3>
            <p>It is also possible to check if the asynchronous task represented by a Java Future is cancelled.</p>
            <div class="code" id="concurrency8"><button class="copy" onclick="copyText('concurrency8')">Copy</button><br><p>
                if(future.isCancelled()) {<br><br>
                } else {<br><br>
                }
            </p>
            </div>
        </div>
        &nbsp;
        <button class="collapsible">ThreadPoolExecutor</button>
        <div class="innerContent">
            <h2>ThreadPoolExecutor</h2>
            <p>The java.util.concurrent.ThreadPoolExecutor is an implementation of the ExecutorService interface.</p>
            <p>The ThreadPoolExecutor executes the given task (Callable or Runnable) using one of its internally pooled threads.</p>
            <p>The thread pool contained inside the ThreadPoolExecutor can contain a varying amount of threads.</p>
            <ul>
                <li>corePoolSize</li>
                <li>maximumPoolSize</li>
            </ul>
            <p>If less than corePoolSize threads are created in the the thread pool when a task is delegated to the thread pool, then a new thread is created, even if idle threads exist in the pool.</p>
            <p>If the internal queue of tasks is full, and corePoolSize threads or more are running, but less than maximumPoolSize threads are running, then a new thread is created to execute the task.</p>
            <h3>Creating a ThreadPoolExecutor</h3>
            <p>The ThreadPoolExecutor has several constructors available</p>
            <div class="code" id="concurrency9"><button class="copy" onclick="copyText('concurrency9')">Copy</button><br><p>
                int corePoolSize = 5;<br>
                int maxPoolSize = 10;<br>
                long keepAliveTime = 5000;<br>
                ExecutorService threadPoolExecutor =<br>
                new ThreadPoolExecutor(corePoolSize, maxPoolSize, keepAliveTime, TimeUnit.MILLISECONDS,<br>
                new LinkedBlockingQueue&lt;Runnable&gt;());<br>
            </p>
            </div>
            <p>However, unless you need to specify all these parameters explicitly for your ThreadPoolExecutor, it is often easier to use one of the factory methods in the java.util.concurrent.Executors class.</p>
        </div>
        &nbsp;
        <button class="collapsible">ScheduledExecutorService</button>
        <div class="innerContent">
            <h2>ScheduledExecutorService</h2>
            <p>The java.util.concurrent.ScheduledExecutorService is an ExecutorService which can schedule tasks to run after a delay, or to execute repeatedly with a fixed interval of time in between each execution.</p>
            <p>Tasks are executed asynchronously by a worker thread, and not by the thread handing the task to the ScheduledExecutorService.</p>
            <h3>ScheduledExecutorService Implementations</h3>
            <p>Since ScheduledExecutorService is an interface, you will have to use its implementation in the java.util.concurrent package, in order to use it.</p>
            <p>ScheduledThreadPoolExecutor</p>
            <h3>Creating a ScheduledExecutorService</h3>
            <p>How you create an ScheduledExecutorService depends on the implementation you use. However, you can use the Executors factory class to create ScheduledExecutorService instances too.</p>
            <div class="code" id="concurrency10"><button class="copy" onclick="copyText('concurrency10')">Copy</button><br><p>ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);</p></div>
            <h3>ScheduledExecutorService Usage</h3>
            <p>Once you have created a ScheduledExecutorService you use it by calling one of its methods:</p>
            <div class="scrollableTable"><table>
                <tr>
                    <td>schedule (Callable task, long delay, TimeUnit timeunit)</td>
                    <td>This method schedules the given Callable for execution after the given delay. The method returns a ScheduledFuture which you can use to either cancel the task before it has started executing, or obtain the result once it is executed.</td>
                </tr>
                <tr>
                    <td> schedule (Runnable task, long delay, TimeUnit timeunit)</td>
                    <td>This method works like the method version taking a Callable as parameter, except a Runnable cannot return a value, so the ScheduledFuture.get() method returns null when the task is finished.</td>
                </tr>
                <tr>
                    <td>scheduleAtFixedRate (Runnable, long initialDelay, long period, TimeUnit timeunit)</td>
                    <td>This method schedules a task to be executed periodically. The task is executed the first time after the initialDelay, and then recurringly every time the period expires.
                        If any execution of the given task throws an exception, the task is no longer executed. If no exceptions are thrown, the task will continue to be executed until the ScheduledExecutorService is shut down.
                        If a task takes longer to execute than the period between its scheduled executions, the next execution will start after the current execution finishes. The scheduled task will not be executed by more than one thread at a time.</td>
                </tr>
                <tr>
                    <td>scheduleWithFixedDelay (Runnable, long initialDelay, long period, TimeUnit timeunit)</td>
                    <td>This method works very much like scheduleAtFixedRate() except that the period is interpreted differently.
                        In the scheduleAtFixedRate() method the period is interpreted as a delay between the start of the previous execution, until the start of the next execution.
                        In this method, however, the period is interpreted as the delay between the end of the previous execution, until the start of the next. The delay is thus between finished executions, not between the beginning of executions.</td>
                </tr>
            </table></div>
        </div>
        &nbsp;
        <button class="collapsible">ExecutorService Shutdown</button>
        <div class="innerContent">
            <h2>ExecutorService Shutdown</h2>
            <p>When you are done using the ExecutorService you should shut it down, so the threads do not keep running.</p>
            <p>If your application is started via a main() method and your main thread exits your application, the application will keep running if you have an active ExexutorService in your application.</p>
            <p>The active threads inside this ExecutorService prevents the JVM from shutting down.</p>
            <h3>ScheduledExecutorService Shutdown</h3>
            <p>Just like an ExecutorService, the ScheduledExecutorService needs to be shut down when you are finished using it. If not, it will keep the JVM running, even when all other threads have been shut down.</p>
            <h3>"shutdown()</h3>
            <p>To terminate the threads inside the ExecutorService you call its shutdown() method.</p>
            <p>The ExecutorService will not shut down immediately, but it will no longer accept new tasks, and once all threads have finished current tasks, the ExecutorService shuts down.</p>
            <div class="code" id="concurrency11"><button class="copy" onclick="copyText('concurrency11')">Copy</button><br><p>
                executorService.shutdown();
            </p>
            </div>
            <h3>"shutdownNow()</h3>
            <p>If you want to shut down the ExecutorService immediately, you can call the shutdownNow() method.</p>
            <p>This will attempt to stop all executing tasks right away, and skips all submitted but non-processed tasks.</p>
            <div class="code" id="concurrency12"><button class="copy" onclick="copyText('concurrency12')">Copy</button><br><p>
                executorService.shutdownNow();
            </p>
            </div>
            <h3>"awaitTermination()</h3>
            <p>The ExecutorService awaitTermination() method will block the thread calling it until either the ExecutorService has shutdown completely, or until a given time out occurs.</p>
            <p>The awaitTermination() method is typically called after calling shutdown() or shutdownNow().</p>
            <div class="code" id="concurrency13"><button class="copy" onclick="copyText('concurrency13')">Copy</button><br><p>
                executorService.shutdown();<br>
                executorService.awaitTermination();
            </p>
            </div>
        </div>
    </div>
    &nbsp;
    <button class="collapsible">TimeUnit Enumeration</button>
    <div class="innerContent">
        <h2>TimeUnit Enumeration</h2>
        <p>TimeUnit is an enumeration that is used to specify the granularity (or resolution) of the timing.</p>
        <p>TimeUnit is defined within java.util.concurrent.</p>
        <div class="scrollableTable"><table>
            <tr>
                <td>DAYS</td>
            </tr>
            <tr>
                <td>HOURS</td>
            </tr>
            <tr>
                <td>Minutes</td>
            </tr>
            <tr>
                <td>SECONDS</td>
            </tr>
            <tr>
                <td>MICROSECONDS</td>
            </tr>
            <tr>
                <td>MILLISECONDS</td>
            </tr>
            <tr>
                <td>NANOSECONDS</td>
            </tr>
        </table></div>
        <h3>TimeUnit enumeration defines various methods that convert between units.</h3>
        <div class="scrollableTable"><table>
            <tr>
                <td>long convert(long tval, TimeUnit tu)</td>
            </tr>
            <tr>
                <td>long toMicros(long tval)</td>
            </tr>
            <tr>
                <td>long toMillis(long tval)</td>
            </tr>
            <tr>
                <td>long toNanos(long tval)</td>
            </tr>
            <tr>
                <td>long toSeconds(long tval)</td>
            </tr>
            <tr>
                <td>long toDays(long tval)</td>
            </tr>
            <tr>
                <td>long toHours(long tval)</td>
            </tr>
            <tr>
                <td>long toMinutes(long tval)</td>
            </tr>
        </table></div>
        <p>The convert() method converts tval into the specified unit and returns the result.</p>
        <h3>TimeUnit also defines the following time methods:</h3>
        <div class="scrollableTable"><table>
            <tr>
                <td>void sleep(long delay) throws InterruptedExecution</td>
                <td>Pauses execution</td>
            </tr>
            <tr>
                <td>void timedJoin(Thread thrd, long delay) throws InterruptedExecution</td>
                <td></td>
            </tr>
            <tr>
                <td>void timedWait(Object obj, long delay) throws InterruptedExecution</td>
                <td></td>
            </tr>
        </table></div>
    </div>
    &nbsp;
    <button class="collapsible">Locks</button>
    <div class="innerContent">
        <h2>Locks</h2>
        <h3>java.util.concurrent.locks</h3>
        <p>This package provides support for locks, which are objects that offer an alternative to using synchronized to control access to a shared resource.</p>
        <p>Before accessing a shared resource, the lock that protects that resource is acquired.</p>
        <p>When access to the resource is complete, the lock is released.</p>
        <p>If a second thread attempts to acquire the lock when it is in use by another thread, the second thread will suspend until the lock is released.</p>
        <div class="scrollableTable"><table>
            <tr>
                <td>lock()</td>
                <td>To acquire a lock. If the lock is unavailable, lock() will wait.</td>
            </tr>
            <tr>
                <td>unlock()</td>
                <td>To release a lock</td>
            </tr>
            <tr>
                <td>tryLock()</td>
                <td>To see if a lock is available, and to acquire it if it is.</td>
            </tr>
        </table></div>
        <p>The newCondition() method returns a Condition object associated with the lock.</p>
        <p>Using a Condition, you gain detailed control of the lock through methods such as await() and signal(), which provide functionality similar to Object.wait() and Object.notify().</p>
        <h3>ReentrantLock</h3>
        <p>java.util.concurrent.locks supplies an implementation of Lock called ReentrantLock.</p>
        <p>ReentrantLock implements a reentrant lock, which is a lock that can be repeatedly entered by the thread that currently holds the lock.</p>
        <h3>ReentrantReadWriteLock</h3>
        <p>java.util.concurrent.locks also defines the ReadWriteLock interface. This interface specifies a lock that maintains separate locks for read and write access.</p>
        <ul>
            <li>Read Lock – if no thread acquired the write lock or requested for it then multiple threads can acquire the read lock.</li>
            <li>Write Lock – if no threads are reading or writing then only one thread can acquire the write lock.</li>
        </ul>
        <h3>StampedLock</h3>
        <p>Lock acquisition methods return a stamp that is used to release a lock or to check if the lock is still valid.</p>
        <div class="scrollableTable"><table>
            <tr>
                <td>void lock()</td>
                <td>Waits until the invoking lock can be acquired.</td>
            </tr>
            <tr>
                <td>void lockInterruptibly() throws InterruptedException</td>
                <td>Waits until the invoking lock can be acquired, unless interrupted.</td>
            </tr>
            <tr>
                <td>Condition newCondition()</td>
                <td>Returns a Condition object that is associated with the invoking lock.</td>
            </tr>
            <tr>
                <td>boolean tryLock()</td>
                <td>Attempts to acquire the lock. This method will not wait if the lock is unavailable. Instead, it returns true if the lock has been acquired and false if the lock is currently in use by another thread.</td>
            </tr>
            <tr>
                <td>boolean tryLock(long wait, TimeUnit tu) throws InterruptedException</td>
                <td>Attempts to acquire the lock. If the lock is unavailable, this method will wait no longer than the period specified by wait, which is in tu units. It returns true if the lock has been acquired and false if the lock cannot be acquired within the specified period.</td>
            </tr>
            <tr>
                <td>void unlock()</td>
                <td>Releases the lock.</td>
            </tr>
        </table></div>
    </div>
    &nbsp;
    <button class="collapsible">Atomic Operations</button>
    <div class="innerContent">
        <h2>Atomic Operations</h2>
        <h3>java.util.concurrent.atomic</h3>
        <p>This package offers methods that get, set, or compare the value of a variable in one uninterruptible (that is, atomic) operation.</p>
        <p>This means that no lock or other synchronization mechanism is required.</p>
        <p>Atomic operations are accomplished through the use of classes, such as AtomicInteger and AtomicLong, and methods such as get(), set(), compareAndSet(), decrementAndGet(), and getAndSet(), which perform the action indicated by their names.</p>
        <p>java.util.concurrent.atomic also provides four classes that support lock-free cumulative operations. These are DoubleAccumulator, DoubleAdder, LongAccumulator, and LongAdder.</p>
        <p>The accumulator classes support a series of user-specified operations. The adder classes maintain a cumulative sum.</p>
    </div>
</div>
</div>
</div>
</body>
<script type="text/javascript" src="../scripts/SideNav.js"></script>
<script type="text/javascript" src="../scripts/collapsible.js"></script>
<script type="text/javascript" src="../scripts/modal.js"></script>
</html>