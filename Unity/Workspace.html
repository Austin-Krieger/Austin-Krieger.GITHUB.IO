<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Learning Unity</title>
    <link rel="stylesheet" type="text/css" href="../styles/Styles.css">
    <script type="text/javascript" src="../scripts/JSFunctions.js"></script>
    <link rel="icon" href="../images/ThirstyPenguin(Logo).ico">
</head>
<body>
<div class="navbar">
    <a href="index.html" style="float: left;">Home</a>
    <a href="" style="float: right;">Next</a>
</div>
<h1 style="text-align:center;">Unity Workspace</h1>
<div class="containButtons">
<button class="collapsible" id="autoClickBtn">Unity Workspace</button>
<div class="content">
    <button class="collapsible">Unity Editor Interface</button>
    <div class="content" style="max-width: 1200px; background: #d6d6d6; margin: auto; box-shadow: 1px 1px 1px 4px #c8c8c8 inset;">
        <h2>Unity Editor Interface</h2>
        <div class="center"><img src="../images/UnityImages/UnityEditorInterface.jpg" alt="Unity Workspace Image"></div>
        <h2>Project Window</h2>
        <p>The Project window lists all the files and directories in your current Project. These files include all the images, sounds, 3D models and other items used in your Project. They are collectively known as Assets.</p>
        <div class="center"><img src="../images/UnityImages/ProjectWindow.jpg" alt="Project Window Image"></div>
        <h2>Console Window</h2>
        <p>The Console window shows you the warnings and errors that your game is producing, and can give you useful information for fixing those errors. By default, the Console window tab is next to the Project window tab. You can move it by dragging and dropping the Console tab to dock the window next to the Project window.</p>
        <div class="center"><img src="../images/UnityImages/ConsoleWindow.jpg" alt="Console Window Image"></div>
        <h2>Hierarchy Window</h2>
        <p>In Unity, games are made up of Scenes (Levels). Within every Scene, you have a list of objects that have a place within that Scene (The characters &amp; environment objects). These objects are called GameObjects in Unity.</p>
        <div class="center"><img src="../images/UnityImages/HierarchyWindow.jpg" alt="Hierarchy Window Image"></div>
        <h2>Scene View</h2>
        <p>The Scene view is a live preview window. It shows your currently loaded Scenes and all the GameObjects in the Hierarchy window. You can use this window to place and move GameObjects in your Scene. Clicking on a GameObject in the Scene view will highlight it in the Hierarchy window.</p>
        <div class="center"><img src="../images/UnityImages/SceneView.jpg" alt="Scene View Window Image"></div>
        <h2>Game Window</h2>
        <p>The Game view is hidden as a tab next to the Scene view by default. While the Scene view allows you to move GameObjects and look around your entire Scene, the Game view shows you what the player will see when they play the game. This is determined by what the camera in your Scene is looking at.</p>
        <p>Currently there is nothing visible in the Scene, so you can’t see anything in the example image.</p>
        <div class="center"><img src="../images/UnityImages/GameWindow.jpg" alt="Scene View Window Image"></div>
        <h2>Inspector Window</h2>
        <p>When you select a GameObject in another window, the Inspector window will display all of the data relating to that object. Unity uses an Object - Component model, which means that you can add different components to GameObjects to change their features. For example, a Camera component allows the player to have a view into the scene.</p>
        <p>All GameObjects start with a Transform component that allows you to specify their position and rotation in the Scene. Other components are optional and you can add them as needed.</p>
        <div class="center"><img src="../images/UnityImages/InspectorWindow.jpg" alt="Inspector Window Image"></div>
    </div>
    &nbsp;
    <button class="collapsible">Toolbar and NAvigation UI</button>
    <div class="content" style="max-width: 1200px; background: #d6d6d6; margin: auto; box-shadow: 1px 1px 1px 4px #c8c8c8 inset;">
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">The Toolbar</h2>
        <p>The toolbar includes a range of useful tool buttons to help you design and test your game.</p>
        <div style="width: 100%; overflow-x: scroll;"><img src="../images/UnityImages/Toolbar.jpg" alt="Toolbar Image" style="height: 40px;"></div><br>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Play buttons</h2>
        <div class="center"><img src="../images/UnityImages/PlayButtons.jpg" alt="Play Buttons Image" style="max-height: 40px;"></div>
        <h3>Play</h3>
        <p>Play is used to test the Scene which is currently loaded in the Hierarchy window, and enables you to try out your game live in the Editor.</p>
        <h3>Pause</h3>
        <p>Pause allows you to pause the game playing in the Game window. This helps you spot visual problems or gameplay issues that you wouldn't otherwise see.</p>
        <h3>Step</h3>
        <p>Step is used to walk through the paused scene frame by frame. This works well when you're looking for live changes in the game world that it would be helpful to see in real time.</p>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Manipulating Objects</h2>
        <p>These tools move and manipulate the GameObjects in the Scene window. You can click on the buttons to activate them, or use a shortcut key.</p>
        <div class="center"><img src="../images/UnityImages/ManipulatingObjects.jpg" alt="Manipulating Objects Image" style="max-height: 40px;"></div>
        <img src="../images/UnityImages/HandTool.jpg" alt="Hand Tool Image" style="max-height: 20px; float: left; position: relative; bottom: -22px; padding-right: 5px;">
        <h2>Hand Tool</h2>
        <p>You can use this tool to move your Scene around in the window. You can also use middle click with the mouse to access the tool.</p>
        <img src="../images/UnityImages/MoveTool.jpg" alt="Move Tool Image" style="max-height: 20px; float: left; position: relative; top: 7px; padding-right: 5px;">
        <h2>Move Tool</h2>
        <p>This tool enables you to select items and move them individually.</p>
        <img src="../images/UnityImages/RotateTool.jpg" alt="Rotate Tool Image" style="max-height: 20px; float: left; position: relative; top: 7px; padding-right: 5px;">
        <h2>Rotate Tool</h2>
        <p>Select items and rotate them with this tool.</p>
        <img src="../images/UnityImages/ScaleTool.jpg" alt="Scale Tool Image" style="max-height: 20px; float: left; position: relative; top: 7px; padding-right: 5px;">
        <h2>Scale Tool</h2>
        <p>This tool is used to scale your GameObjects up and down.</p>
        <img src="../images/UnityImages/RectTransformTool.jpg" alt="Rect Transform Tool Image" style="max-height: 20px; float: left; position: relative; top: 7px; padding-right: 5px;">
        <h2>Rect Transform Tool</h2>
        <p>This tool combines moving, scaling and rotation into a single tool that's specialized for 2D and UI.</p>
        <img src="../images/UnityImages/RotateMoveScale.jpg" alt="Rotate, Move or Scale Tool Image" style="max-height: 20px; float: left; position: relative; top: 7px; padding-right: 5px;">
        <h2>Rotate, Move or Scale</h2>
        <p>This tool also enables you to move, rotate, or scale GameObjects, but is more specialized for 3D.</p>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Shortcuts</h2>
        <div class="columns">
            <div class="shortcutIcon">
            <img src="../images/UnityImages/HandTool.jpg" alt="Hand Tool Image"><p>Shortcut Q</p><br>
            <img src="../images/UnityImages/MoveTool.jpg" alt="Move Tool Image"><p>Shortcut W</p><br>
            <img src="../images/UnityImages/RotateTool.jpg" alt="Rotate Tool Image"><p>Shortcut E</p><br>
            </div>
            <div class="shortcutIcon">
            <img src="../images/UnityImages/ScaleTool.jpg" alt="Scale Tool Image"><p>Shortcut R</p><br>
            <img src="../images/UnityImages/RectTransformTool.jpg" alt="Rect Transform Tool Image"><p>Shortcut T</p><br>
            <img src="../images/UnityImages/RotateMoveScale.jpg" alt="Rotate, Move or Scale Tool Image"><p>Shortcut Y</p><br>
            </div>
        </div>
        <h2>Shortcut F</h2><p>Enables you to focus on a selected object. If you forget where a GameObject is in you Scene, just select it in the Hierarchy, move your cursor over to the Scene window, and press F to center it in the Scene window.</p>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Navigating with the mouse</h2>
        <p>When you're in the Scene window, you can also:</p>
        <ul>
            <li>Left click to select your GameObject in the Scene.</li>
            <li>Middle click and drag to move the Scene view's camera using the hand tool.</li>
            <li>Right click and drag to rotate the Scene view's camera using flythrough mode - a variation on the hand tool. While doing this, you can also move the camera left and right using A and D, forward and back using W and S, and down and up using Q and E.</li>
        </ul>
    </div>
    &nbsp;
    <button class="collapsible">Layouts</button>
    <div class="content" style="max-width: 1200px; background: #d6d6d6; margin: auto; box-shadow: 1px 1px 1px 4px #c8c8c8 inset;">
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Default Layouts</h2>
        <p>You can lay out your Editor in several ways. Each layout has its own advantages and you'll find out which layout works best for you.</p>
        <p>To switch layouts, select Windows > Layouts (or use the Layouts drop-down menu in the top right corner of the Editor). You can choose from the following layouts:</p>
        <h3>2 by 3</h3>
        <p>This layout lets you see both your Scene view and Game view together with your Inspector, Project view and Hierarchy in columns to the right.</p>
        <h3>4 Split</h3>
        <p>This layout is good for looking at 3D models from different angles.</p>
        <h3>Tall</h3>
        <p>This layout makes the Scene view and Inspector nice and clear.</p>
        <h3>Wide</h3>
        <p>This layout pushes the Hierarchy, Project window and Assets to the bottom of the Editor.</p>
        <h3>Default</h3>
        <p>This layout makes your Scene or Game view take up most of the Editor, and there's also room for your Assets, Hierarchy and Inspector on either side.</p>
    </div>
    &nbsp;
    <button class="collapsible">Creating a Project</button>
    <div class="content" style="max-width: 1200px; background: #d6d6d6; margin: auto; box-shadow: 1px 1px 1px 4px #c8c8c8 inset;">
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Creating a Project</h2>
        <ol>
            <li>Open the Unity Hub.</li>
            <li>Log in with your Unity account.</li>
            <li>Click the New button in the top right corner.</li>
            <div class="center" style="padding: 10px;"><img src="../images/UnityImages/UnityHub.JPG" alt="Unity Hub Image"></div>
            <li>Enter a Project name.</li>
            <li>Set the Unity Version.</li>
            <li>Choose the folder where you want to save your Project.</li>
            <li>Choose your Template (2D/3D)</li>
            <li>Click Create project.</li>
            <div class="center" style="padding: 10px;"><img src="../images/UnityImages/NewProject.JPG" alt="Unity New Project Image"></div>
        </ol>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Save the Scene</h2>
        <p>When a new Project is created, Unity automatically creates an empty Scene called "Untitled".</p>
        <div class="center" style="padding: 10px; max-width: 500px;"><img src="../images/UnityImages/HierarchyWindow.jpg" alt="Untitle Scene Image"></div>
        <p>Go to <b>File > Save</b> or press <b>Ctrl/Cmd + S</b>, then select where you want to save the file. A folder named Scenes is generally used, so let's save this Scene in that folder as "MainScene".</p>
        <p>You will see this creates a Scene Asset called MainScene in the Project window.</p>
        <div class="center" style="padding: 10px; max-width: 400px;"><img src="../images/UnityImages/MainScene.jpg" alt="Main Scene Image"></div>
        <p>You now have a Scene to work in. Remember to press <b>Ctrl/Cmd + S</b> regularly to save your changes. <b>"Save early, Save often!"</b>.</p>
    </div>
    &nbsp;
    <button class="collapsible">Add a Character Model</button>
    <div class="content" style="max-width: 1200px; background: #d6d6d6; margin: auto; box-shadow: 1px 1px 1px 4px #c8c8c8 inset;">
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Adding a Character Model</h2>
        <p>Import a character model from your own files or from the asset store.</p>
        <ol>
            <li>In the Project window, go to the <b>Assets > Models > Characters</b> folder and find the model you wish to add to your Scene.</li>
            <li>Drag the model from the Project window into the Scene view. This enables you to choose exactly where you want to place the model. (You can also drag models into the Hierarchy to create GameObjects at the default position.)</li>
            <li>With your cursor over the Scene view, press <b>F</b> to focus.<p>You should now see the model in the scene!</p></li>
            <li>In the Hierarchy window, find the GameObject. If there is an arrow next to the name of the GameObject - this means that the GameObject has children.</li>
            <li>Click on the arrow to expand and see its children.</li>
            <p>Select the child GameObject with the same name as your character. This GameObject should have a component called a <b>Skinned Mesh Renderer.</b>. This is what enables you to see the character.</p>
            <p>Models are made up of a mesh of triangles, and a Mesh Renderer "renders" that mesh so you can see it. A Skinned Mesh Renderer is a special type of Mesh Renderer that allows the mesh to change shape based on the positions and rotations of all of a model’s bones. These bones are child GameObjects of the model. The characters bones are all children of the Root GameObject.</p>
            <li>In the Hierarchy, select the <b>Root</b> GameObject. Hold alt/Option and click the arrow to the left of its name to expand all its child GameObjects. Each of these GameObjects represents a part of the character's body (RightLeg/Hips/Spine/Neck/LeftShoulder/etc.)</li>
            <li>In the Hierarchy, select the GameObject called LeftForeArm. In its Transform component, find the Rotation field and change the Y value to 90. You will see that the left arm has bent 90 degrees.</li>
            <div class="center" style="padding: 10px; max-width: 500px;"><img src="../images/UnityImages/LeftForearm.jpg" alt="Left Forearm Transform Image"></div>
            <p>The Animator component on the character's parent GameObject will change the rotation of all the bone GameObject Tranform components, and these changes will happen together to animate the character.</p>
            <li>Collapse all the GameObjects again by holding alt/Option and clicking the arrow next to the name of the parent GameObject.</li>
        </ol>
    </div>
    &nbsp;
    <button class="collapsible">Prefabs</button>
    <div class="content" style="max-width: 1200px; background: #d6d6d6; margin: auto; box-shadow: 1px 1px 1px 4px #c8c8c8 inset;">
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">What are Prefabs?</h2>
        <p>Prefabs are a special type of Asset that represent a GameObject or collection of GameObjects with components that are already set up. They're like a blueprint which you can use to easily make instances of the same thing. Each instance of a prefab is linked to the Prefab Asset, so changing the Asset will change all versions of the Prefab in all Scenes. This also means that if you go on to make mulitple level for a game, you won't need to remake a character for every level - you can just instantiate a new Prefab.</p>
        <p>Prefabs can be identified in the Hierarchy by their blue name and icon:</p>
        <div class="center" style="padding: 10px;"><img src="../images/UnityImages/Prefab.jpg" alt="Prefab Image" style="max-height: 100px;"></div>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Making a Prefab</h2>
        <ol>
            <li>Drag the GameObject from the Hierarchy into the <b>Assets > Prefab</b> folder in the Project window. A dialogue box will appear asking if you want to make an Original Prefab or a Prefab Variant - select <b>Original Prefab</b>.</li>
            <p>Dragging a GameObject like this makes it a Prefab regardless of the folder it is dragged into. Best practice would be to place them in a folder named Prefabs.</p>
            <div class="center" style="padding: 10px;"><img src="../images/UnityImages/PrefabDialogueBox.JPG" alt="Prefab Dialogue Box Image" style="max-height: 150px;"></div>
            <li>Now the Prefab has been created, any changes you make will be reflected on the instance of the GameObject in the Scene. In order to make changes to a Prefab, you will need to open the Prefab for editing in Prefab Mode.</li>
            <li>Click on the Prefab and in the Inspector window you will see a button that reads "Open Prefab". Clicking on this button will put the Unity Editor in Prefab Mode.</li>
            <p>This mode takes you out of your current Scene and puts you in a temporary Scene with just the Prefab. The Scene has changed slighlty; at the top there is a new bar with <b>Scenes | Prefab Name</b> on the left and a checkbox labeled Auto Save on the right.</p>
            <li>Disable the <b>Auto Save</b> checkbox. A Save button will appear so you can manually save any changes that you make to the Prefab.</li>
            <li>The Hierarchy window also has a new bar at the top. The arrow on the left will take you back along the breadcrumn. If you clicked it now, it would take you back to MainScene.</li>
        </ol>
    </div>
    &nbsp;
    <button class="collapsible">Animate your character</button>
    <div class="content" style="max-width: 1200px; background: #d6d6d6; margin: auto; box-shadow: 1px 1px 1px 4px #c8c8c8 inset;">
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Animating your character</h2>
        <p>Two important animations to have for your player character are a walking animation and an idle animation for when the player is walking and not walking respectively.</p>
        <p>Select your player character GameObject and take a look at its Animator component in the Inspector. The first property is called Controller. This takes a reference to a type of Asset called an Animator Controller, which your're going to use to get the characer moving.</p>
        <p>Animator Controllers contain a <b>state machine</b> which determines what animation the Animator component should be setting for its hierarchy at any given time. This animation is based on animation clips which have been set up on the Animator Controller.</p>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Create the Animator Controller</h2>
        <ol>
            <li>In the Project Window, find the <b>Assets > Animation > Animators</b> folder. Right click on it and select <b>Create > Animator Controller</b>.</li>
            <li>Name the Animator Controller, then double click on it to open it for editing in the Animator window.</li>
            <p>The Animator window has two main sections:</p>
            <ul>
                <li>A panel for editing Animator Layers and Animator Parameters on the left.</li>
                <li>An area which displays the state machine itself on the right.</li>
            </ul>
            <li>Click the <b>Parameters</b> tab on the top left of the Animator window.</li>
            <p>The Animator Controller's state machine makes decisions based on the current values of its <b>Animator Parameters</b>. These Animator Parameters have values set by script. You will need one parameter for every independent variable which can affect the animation that the character is playing.</p>
            <p>There are four types of parameter:</p>
            <ul>
                <li>A <b>float</b> parameter has the value of a floating point variable (a number with a decimal place).</li>
                <li>An <b>int</b> parameter has the value of an integer (a number without a decimal place).</li>
                <li>A <b>bool</b> parameter has the value of a boolean (which can be true or false).</li>
                <li>A <b>trigger</b> parameter is a special type of parameter which doesn't hold a value - this causes a change from one animation to another.</li>
            </ul>
            <p>In this case, you know that the character is either walking or stationary, so a bool parameter makes the most sense.</p>
            <li>Click the <b>+</b> button and select <b>Bool</b> from the drop-down to create a new Bool Animator Parameter.</li>
            <li>Name the new Animator Parameter "IsWalking". The spelling and capitalisation is important for the scripting later.</li>
            <p>This is the default value for the parameter.  Without player input your character is going to be stationary, so IsWalking should be false. This means you don’t need to change anything here.</p>
        </ol>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Set Up the Animations</h2>
        <ol>
            <li>In the Project window, go to the <b>Assets > Animation > Animation</b> window.</li><p>A slider on the bottom right can change the folder from icon view to list view.</p>
            <li>The list of animations should have a naming convention such as "PlayerCharacter@Idle", "PlayerCharacter@Walk" and so on.</li>
            <li>In order to use these animations in your Animator Controller, drag them from the Project window to the Animator window. Start with Idle.</li>
            <li>Animations exist in an Animator Controller in <b>Animator States</b>. When you dragged in the Idle and Walkanimations, the Animator Controller created two states containing them and named them after the animations.</li>
            <p>An Animator State is part of the state machine that an Animator Controller contains. The state machine contains logic which determines which state is the current state. The current state then determines the animation that is being played.</p>
            <div class="center" style="padding: 10px;"><img src="../images/UnityImages/AnimatorDefaultState.jpg" alt="Animator Default State Image" style="max-height: 150px;"></div>
            <p>The default state is displayed in orange (Idle). Your state machine now has two states in it, but no logic to define which state should play. Currently, the state machine will start in the default state and never change, so the character will always be idle. We will need to make <b>Animator Transitions</b>.</p>
        </ol>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Create Animator Transitions</h2>
        <ol>
            <li>Right click on the Idle state and select <b>Make Transition</b>. This starts a transition that follows the mouse cursor.</li>
            <div class="center" style="padding: 10px;"><img src="../images/UnityImages/AnimatorDefaultState.jpg" alt="Make Transition Image" style="max-height: 150px;"></div>
            <p>To finish creating the transition, click on the Walk state.</p>
            <li>Your character needs to be able to change back to idle from walking, so repeat this process to create a trainsition from Walk to Idle.</li>
            <div class="center" style="padding: 10px;"><img src="../images/UnityImages/Transition.JPG" alt="Transition Image" style="max-height: 200px;"></div>
            <li>The state machine now has a way of transitioning between the two animations, but it doesn't yet know when to transition. Select the transition from Idle to Walk by clicking on the connecting line.</li>
            <li>In the inspector, look at the settings from this transition. The first thing you need to change is the <b>Has Exit Time checkbox</b>.</li>
            <div class="center" style="padding: 10px;"><img src="../images/UnityImages/HasExitTime.JPG" alt="Has Exit Time Image" style="max-height: 220px;"></div>
            <p>If Has Exit Time is true (the checkbox is enabled) then after a certain amount of time has passed the transition will automatically be taken and the state machine will play the next state. So, <b>disable</b> the <b>Has Exit Time checkbox</b>.</p>
            <p>You will now see a warning, because there is no longer a reason to ever take this transition. We need to provide one by adding a <b>Condition</b>.</p>
            <div class="center" style="padding: 10px;"><img src="../images/UnityImages/ConditionsWarning.JPG" alt="Condition Warning Image" style="max-height: 150px;"></div>
        </ol>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Add Conditions to your Transition</h2>
        <ol>
            <li>Click the <b>+</b> button beneath the (currently empty) Conditions list.</li>
            <li>The transition from Idle to Walk is required when the character is walking - that is, when <b>IsWalking</b> is true.</li>
            <div class="center" style="padding: 10px; max-width: 500px;"><img src="../images/UnityImages/IsWalkingCondition.JPG" alt="Is Walking Condition Image" style="max-height: 100px;"></div>
            <p>Next, you need to set up the transition from Walk to Idle.</p>
            <li>Select the transition from <b>Walk to Idle</b> in the Animator window. <b>Disable</b> the <b>Has Exit Time checkbox</b> - as before, you don't want the state to change after a certain amount of time, just when you want it to.</li>
            <li>Now that the Has Exit Time checkbox is disabled, you need to create another Condition.</li>
            <p>This Condition should also check IsWalking, but this time the value should be set as false.  If the character is not walking then it should transition from Walk to Idle.</p>
            <div class="center" style="padding: 10px; max-width: 500px;"><img src="../images/UnityImages/WalkTransition.JPG" alt="Walk Transition Image" style="max-height: 100px;"></div>
        </ol>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Assign the Animator Controller to the Prefab</h2>
        <ol>
            <li>In the Project window, go to <b>Assets > Animation > Animators</b> and find your character Animator Controller.</li>
            <li>Select the character GameObject in the Hierarchy, then drag the Animator Controller to the Controller property of its Animator component in the Inspector. Without doing this step the character won't move.</li>
            <li>Remember to Save.</li>
        </ol>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Make your Character React to Physics</h2>
        <p>We don't want the player walking through walls in this case.</p>
        <ol>
            <li>Open the character Prefab for editing in Prefab Mode. In the Inspector, you'll find two components: a Transform and an Animator. In order to react to physics your character needs two more components: a Rigidbody and a Collider.</li>
            <p>A <b>Rigidbody</b> component marks a GameObject as something that is part of the physics system that can move.</p>
            <li>Click the <b>Add Component</b> button.</li>
            <div class="center" style="padding: 10px; max-width: 500px;"><img src="../images/UnityImages/AddComponent.jpg" alt="Add Component Image" style="max-height: 50px;"></div>
            <li>In the search bar that appears, type “Rigidbody” and select this from the options that appear.</li>
            <div class="center" style="padding: 10px; max-width: 500px;"><img src="../images/UnityImages/Rigidbody.jpg" alt="Rigidbody Image" style="max-height: 500px;"></div>
            <p>Since this is a 3D Project we want to make sure to choose Rigidbody and not Rigidbody 2D. To remove a component click on the cog in the top right of the component and select Remove Component.</p>
            <li>Save your work.</li>
            <li>Your character will now react to the effects of physics such as gravity. Press the play button to test the physics of the player and press play again to stop the test, since the physics isn't quite working correctly.</li>
            <p>The Animator component has <b>Apply Root Motion</b> enabled. If it is Dissabled your character will fall forever (there is no floor), but let's leave it enabled for now.</p> 
        </ol>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">What is Root Motion?</h2>
        <p>Animations are used to move and rotate all the GameObjects within a particular hierarchy.  Most of these movements and rotations are done relative to their parents, however the parent GameObject of the hierarchy has no parent and therefore their movement is not relative. This parent GameObject can also be called the Root, and its movement is therefore called Root Motion.</p>
        <p>The root GameObject is whichever GameObject the Animator component is on.</p>
        <p>Apply Root Motion is enabled on your Animator component, so any movement of the root in the animation will be applied every frame.  Since the Animator is playing Idle there is no movement, so the Animator will apply no movement.  So why does the character GameObject move at all? This is due to the Update Mode of the Animator.</p>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">What is the Update loop?</h2>
        <p>Games work in a similar way to films and television: an image is displayed on a screen and this image changes many times per second giving the illusion of movement. We call these images frames; the process of drawing these frames to the screen is called rendering. For films and television the next image to show on screen is often predefined, but in games the next image can vary wildly because the user has influence over what happens next. Each image needs to be worked out based on the user input - and since this variation can happen every split second, the programming that works out what to display also works at this speed. This is called the Update loop.</p>
        <p>Each time a frame is displayed, a number of things happen in order. All you need to know for now is that custom components have their Update method called, and a new image is rendered to the screen. These Updates vary in length, depending on the complexity of the computations and rendering. However, there is another separate loop that runs all the physics operations. This loop doesn’t vary how often it updates, and is therefore called the FixedUpdate.</p>
        <p>An Animator component can change when it performs its Update. By default it performs this in line with rendering. This means that the Animator is moving the character in Update and the Rigidbody is simultaneously moving the character in Fixed Update.  This is what’s causing your problem, and it can easily be fixed!</p>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Fix Character Movement</h2>
        <ol>
            <li>Select your character in the Hierarchy and in the Inspector window click the Prefab Open button.</li>
            <div class="center" style="padding: 10px; max-width: 500px;"><img src="../images/UnityImages/PrefabOpen.jpg" alt="Prefab Open Image" style="max-height: 45px;"></div>
            <li>Go to the Animator component. In the Update Mode property drop-down, select <b>Animate Physics</b>.</li>
            <div class="center" style="padding: 10px; max-width: 500px;"><img src="../images/UnityImages/AnimatePhysicsl.jpg" alt="Animate Physics Image" style="max-height: 45px;"></div>
            <p>This change will cause the Animator to move the character in time with physics. Now there should be no competition between update loops to move the character, and it will react to physics as it should.</p>
            <li>Now we need to contrain the characters movement using physics. We don't want the character moving vertically after colliding with something.</li>
            <li>Find the RigidBody component and click the arrow to expand the Contraints propterty.</li>
            <div class="center" style="padding: 10px; max-width: 400px;"><img src="../images/UnityImages/Constraints.jpg" alt="Rigidbody Contraints Image"></div>
            <p>These Contraint propterties restrict the directions in which the Rigidbody can move.</p>
        </ol>
    </div>
    &nbsp;
    <button class="collapsible">Coordinates in Unity</button>
    <div class="content" style="max-width: 1200px; background: #d6d6d6; margin: auto; box-shadow: 1px 1px 1px 4px #c8c8c8 inset;">
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Coordinates in Unity</h2>
        <p>Positions and directions in Unity work in 3D coordinates represented by x, y and z - together these make a vector. You’ll find out more about vectors later. A Scene has a global definition of these directions that you can see in the top right of the Scene window.</p>
        <div class="center" style="padding: 10px; max-width: 400px;"><img src="../images/UnityImages/Coordniates.jpg" alt="Coordinates Image"></div>
        <p>The colored arrows represent the positive direction of each axis, with the grey arrow opposite representing the negative direction:</p>
        <ul>
            <li>x-axis is red</li>
            <li>y-axis is green</li>
            <li>z-axis is blue</li>
        </ul>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Positions and Rotation</h2>
        <p>GameObjects without parents in the scene all have positions relative to the scene’s origin (0, 0, 0). GameObjects with parents all have positions relative to their parent.  However, since GameObjects can be rotated, a child’s relative (or local) position will be in their parent’s rotated coordinates. It is these local coordinates (or axes) that the Rigidbody Constraints refer to.</p>
        <ol>
            <li>Select the character GameObject, and then look at the Scene view. You will see that:</li>
            <ul>
                <li>the x-axis (red) is pointing to the character’s <b>right</b></li>
                <li>the y-axis (green) is pointing <b>upward</b></li>
                <li>the z-axis (blue) is pointing <b>forward</b></li>
            </ul>
            <li>So what constraints should your character have?</li>
            <p>Your character needs to be able to move forward and from side to side, so there’s no need to constrain its x or z position. However, it’s important that it doesn’t move up and down; to stop that, enable the Freeze Position Y checkbox.</p>
            <li>Rotation refers to a rotation around a specific axis. For example, if the character were rotated around its x-axis then it would look like it was lying down on its front or back.</li>
            <p>If it were rotated around its z-axis, it would look like it was lying down on its side.</p>
            <p>Our character shouldn’t move in either of these ways, so enable the Freeze Rotation X and Z checkboxes.</p>
            <div class="center" style="padding: 10px; max-width: 400px;"><img src="../images/UnityImages/Constraints2.jpg" alt="Constraints Image"></div>
            <p>The Rigidbody component is now set up, and your character will react to the physics system. However, it doesn’t really have any physical presence in the Scene yet - nothing can bump into it and it can’t bump into anything else. In order for it to have a physical presence in the scene, it needs a <b>Collider.</b></p>
        </ol>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Add a Collider to your Character</h2>
        <p>A Collider is a general term that covers a number of different components. Colliders define the shape of an object for the purpose of physical collisions, allowing your character to hit things and be hit. There are Collider components of many different shapes, but the simplest one that best fits our character is the Capsule Collider.</p>
        <ol>
            <li>Click the Add Component button in the Inspector window, and search for Capsule Collider. Select the <b>Capsule Collider</b> option, making sure not to click on Capsule Collider 2D.</li>
            <div class="center" style="padding: 10px; max-width: 400px;"><img src="../images/UnityImages/CapsuleCollider.jpg" alt="Capsule Collider Image"></div>
            <p>Change the Capsule Collider's Height, Radius and Center properties to fit your character.</p>
        </ol>
    </div>
    &nbsp;
    <button class="collapsible">Scripting</button>
    <div class="content" style="max-width: 1200px; background: #d6d6d6; margin: auto; box-shadow: 1px 1px 1px 4px #c8c8c8 inset;">
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">What is a script?</h2>
        <p>A script is a text document containing a series of instructions for the computer.  These instructions are commonly called code.  The instructions are written in a way that the computer can understand, in this case using a programming language called C#.</p>
        <p>C# defines the way the instructions are written and some of the words that are used.  Luckily, the words used often have a similar meaning in C# as they do in English.  For example, the first word we’ll come across in C# is "using" - this means that the script it is written is using code from somewhere else. Another example is "public", which means that anything can access something. There are too many examples to go through them all here.</p>
        <p>MonoBehaviours are special types of scripts that can be attached to GameObjects just as components can. This is because they are a specific case of component that you can write yourself.</p>
        <p>Scripts share some minor similarities with Prefabs:</p>
        <ul>
            <li>A script is created as an Asset, just like a Prefab is.</li>
            <li>Adding a script to a GameObject as a component is actually instantiating that script, just as adding a Prefab to a scene is instantiating that Prefab.</li>
        </ul>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Creating your First Script (PlayerMovement)</h2>
        <ol>
            <li>Find or create the <b>Assets > Scripts</b> folder in the Project window. Right-click on the folder and choose <b>Create > C# Script</b>. Name the script <b>"PlayerMovement"</b>.</li>
            <p><b>Note:</b> Scripts that are going to be used as a component need to have the same name on the asset as the class name in the script itself.  When Unity creates a script file, it gives it a class name which matches what the Asset was first named. However, when the Asset is renamed, the class name does not change. </p>
            <li>Select your script, and look at the Inspector window. You should see the following code:</li>
            <div class="unityCode" id="DefaultScript"><button class="copy" onclick="copyText('DefaultScript')">Copy</button><br><p>
                using System.Collections;<br>
                using System.Collections.Generic;<br>
                using UnityEngine;<br><br>
                public class PlayerMovement : MonoBehaviour<br>
                {<br>
                &emsp;<mark>// Start is called before the first frame update</mark><br>
                &emsp;void Start()<br>
                &emsp;{<br><br>
                &emsp;}<br><br>
                &emsp;<mark>// Update is called once per frame</mark><br>
                &emsp;void Update()<br>
                &emsp;{<br><br>
                &emsp;}<br>
                }
            </p>
            </div>
            <p>Find the line which starts <b>“public class PlayerMovement”</b>. This is what defines the class name. If your script doesn’t say PlayerMovement, delete the script Asset then create a new one named PlayerMovement.</p>
            <li> Now you have created your script Asset, open it for editing. You can either double click on the Asset, or click the "Open…" button in the Inspector window.</li>
            <div class="center" style="padding: 10px; max-width: 400px;"><img src="../images/UnityImages/PlayerMovementInInspector.jpg" alt="Player Movement In Inspector Image"></div>
            <p>Script editing is not done inside Unity - instead scripts open in another program called Visual Studio. Once that’s opened, you’ll be able to edit the script.</p>
        </ol>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Explore the default script</h2>
        <ol>
            <li>The first three lines of code are called using directives.</li>
            <div class="unityCode" id="FirstThreeLines"><button class="copy" onclick="copyText('FirstThreeLines')">Copy</button><br><p>
                using System.Collections;<br>
                using System.Collections.Generic;<br>
                using UnityEngine;
            </p></div>
            <p>They allow you to use code implemented elsewhere within this script file. For example, the word "MonoBehaviour" in the next line would not be usable if you didn’t have "using UnityEngine;" here.  In most cases, the using directives that are included by Unity by default are enough, so you don’t need to worry about these.</p>
            <li>The next line is:</li>
            <div class="unityCode" id="Monobehaviour"><button class="copy" onclick="copyText('Monobehaviour')">Copy</button><br><p>
                public class PlayerMovement : MonoBehaviour
            </p></div>
            <p>This is the start of a class declaration. Classes are like the plans for instances which are called Objects. When a class is instantiated (for example, by attaching a script as a component to a GameObject), that instance is called an object. Objects are the building blocks of code, and they exist throughout the work you’ve already done!</p>
            <p>Classes you have already met include Animator, Rigidbody, GameObject, and Transform. These exist in your game already. Another way to think of classes is that they are factory buildings: the factory takes an input, does a few things to it, and then produces an output afterward. We’ll return to this factory analogy with other code elements.</p>
            <li>The next line is simply an open curly brace/bracket: {</li>
            <p>Braces are an essential part of the C# language, as they define code blocks. Code blocks are lines of code which exist between an open and close brace. Braces must always exist in pairs.</p>
            <p>For the class declaration code block, the close brace is at the bottom but there are two more code blocks within the class declaration. The two code blocks contained in the class declaration are indented. Indentation is not technically necessary, but is very helpful in defining where code blocks begin and end.</p>
            <li>The next line is:</li>
            <div class="unityCode" id="Comment"><button class="copy" onclick="copyText('Comment')">Copy</button><br><p>
                <mark>// Start is called before the first frame update</mark>
            </p></div>
            <p>Any text that is preceded by a double forward slash like this is known as a comment. A comment is anything that you want to be completely ignored by the computer. In most cases, they work as a sort of label to explain something about the code around them.  In this case, the comment gives a very brief explanation of what is declared below it.</p>
            <li>After the comment is the start of the first method declaration:</li>
            <div class="unityCode" id="StartMethod"><button class="copy" onclick="copyText('StartMethod')">Copy</button><br><p>
                void Start()
            </p></div>
            <p>Let’s return to the factory analogy. If a class is a factory, then a method is a machine within that factory. Methods can take in data, perform an operation, and then give out (or return) data.</p>
            <p>All method declarations have the same format:</p>
            <ul>
                <li>First they state the return type. This is the type of data that is going to be given out when the method is finished. In this example, the return type is void.  This is a special C# word that means nothing — the method returns literally nothing.</li>
                <li>After the return type comes the name of the method, in this case Start.</li>
                <li>After the name there is a pair of open and close curved brace/brackets: (). Within these parentheses, methods have the chance to declare what type of data they want to take in. These pieces of data are called parameters. Since there is nothing between the parentheses, there are no parameters declared.</li>
            </ul>
            <p>These three pieces of information (the return type, name and parameters) form a method’s signature. In most cases, a method can have whatever signature you like. However, MonoBehaviour classes can use some special methods which need to have specific signatures. These special methods don’t need to be called from your code, and instead are called at specific times by Unity. Start is one example of a special method. It is called as soon as the GameObject it is on starts, which is usually as soon as the Scene starts. This makes it ideal for doing things like setup that you don’t want to repeat.</p>
            <li>After the Start method signature is a code block. This defines all the code that is executed whenever the method is called. Calling a method is how you use it - you’ll do this yourself later. To return to the factory analogy: the method declaration is how the machine in the factory works, and calling the method is actually making use of that machine.</li>
            <p>A method signature declaration followed by the code block are together known as a method definition. The terms method declaration and method definition are commonly interchanged when talking about C#, because they happen at the same time. The difference only really matters in other languages (such as C++).</p>
            <li>Now is a good time to talk about the order in which things are written in a class. Keeping with the factory and machines analogy, it doesn’t matter where in your factory the machines are, but the order in which machines perform their operations is very important. In C# it doesn’t matter in which order methods are declared in a class, but the order in which methods perform their operations matters a lot.</li>
            <li>The last two parts of the script are another comment and then another method definition. The Update method is another special method for MonoBehaviours. It is called every frame, before something is rendered to the screen. Now you have a basic understanding of some of the parts of the default script.</li>
        </ol>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Create variables for the Horizontal and Vertical axes</h2>
        <p>Your PlayerMovement script needs to take user input and translate that into character movement.</p>
        <p>The first thing you’re going to need to do is get some data from Unity’s input system. The script needs to check what’s happening with the input all the time, and since Update is called every frame it makes perfect sense to check the input there. But what specifically does it need to check?</p>
        <p>It makes sense to move the character using the arrow keys or WASD, so the script needs to check the values of those specific keys on the keyboard. It could check whether or not each of those keys are individually either held or not and decide what the character should do (or not), but there’s an alternative that’ll make this a little easier.</p>
        <p>Unity has an input manager that defines various buttons and axes which can be found by name. For example, it has an axis called Horizontal, which is represented by the A and D keys and the left and right keys. So by checking that, the player’s computer could decide whether the character should move left or right.</p>
        <p>Let's get started by adding the following inside the Update method:</p>
        <div class="unityCode" id="NewUpdateMethod"><button class="copy" onclick="copyText('NewUpdateMethod')">Copy</button><br><p>
            <mark>// Update is called once per frame</mark><br>
            void Update()<br>
            {<br>
            &emsp;float horizontal = Input.GetAxis ("Horizontal");<br>
            }<br>
        </p></div>
        <p>In short, your new line of code is telling the computer, “Create a new float variable and call it horizontal; set that variable equal to the result of this method call.”</p>
        <p>If classes are factories and methods are machines in those factories, variables are boxes containing stuff in those factories.  In other words, variables are a way of storing data. The data you need to store is the value of the horizontal input axis.  In Unity, input axes return a number between -1 and 1 — this type of data is called float. A float represents a number with decimal places.</p>
        <p>There are a few pieces of important syntax (structure) in this line of code:</p>
        <ul>
            <li>In C#, an equal sign means assign whatever is on the right (the result of a method) to the variable on the left (a newly created float variable).</li>
            <li>The full stop between Input and GetAxis allows the computer to access something inside the previous object (GetAxis is a method within Input, so to get from Input to GetAxis a full stop is used).</li>
            <li>C# code is made up of things called statements. Each statement can contain one or more instructions to the computer, and can be thought of like sentences. The semicolon marks the end of the statement, and so functions like a full stop does at the end of a sentence.</li>
        </ul>
        <p>You have the class Input, and you are drilling into that to find the method called GetAxis. You are then calling that method by putting parentheses after the name. However, unlike Start and Update, GetAxis has a parameter - that is a piece of data it needs to perform its task. Specifically, GetAxis needs the name of the axis it’s trying to find the value of. You’re trying to find the Horizontal axis value here, so you have given that as a parameter.</p>
        <p>The data type for this piece of information is called a string. This refers to a string of characters, for example a word or sentence. By putting speech marks around the word Horizontal, you are instructing the computer that it should be treated like a string.</p>
        <p>Once the computer has retrieved the value of the axis it will need to store it somewhere. To the left of method call, you have introduced a new float variable called horizontal and set it equal to the value found from GetAxis.</p>
        <p>Next, add another line of code to find the value of the axis called Vertical and store that in a variable called vertical.</p>
        <div class="unityCode" id="NewUpdateMethod1"><button class="copy" onclick="copyText('NewUpdateMethod1')">Copy</button><br><p>
            <mark>// Update is called once per frame</mark><br>
            void Update()<br>
            {<br>
            &emsp;float horizontal = Input.GetAxis ("Horizontal");<br>
            &emsp;float vertical = Input.GetAxis ("Vertical");<br>
            }<br>
        </p></div>
        <p>You now have the values for both the horizontal and vertical axes. The next step is to combine them into a vector, so that they can be used to change position.</p>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Make a Vector</h2>
        <p>In Unity, 3D space is represented by three coordinates which together made a vector. The data type to represent a vector in Unity is called Vector3. This is what a GameObject’s position is represented by, and so you will need to make a Vector3 representing that change. The movement that the user input represents is fundamental to this class, and you may need to use it for other things too.</p>
        <p>With this in mind, it’s important to consider the scope of the variable you need to create.</p>
        <p>The scope of a variable is the area of code where it can be used. Usually this is as simple as the code block in which it is declared. For example, both float variables you just declared (horizontal and vertical) are in scope for the whole of the Update method, because that is the code block in which they were declared. They are said to be local to the Update method.</p>
        <p>If you want to use a variable in multiple different methods, you can create variables outside of the method’s scope. These are local to the class instead.</p>
        <p>Above the method definitions, add the following line:</p>
        <div class="unityCode" id="Vector3"><button class="copy" onclick="copyText('Vector3')">Copy</button><br><p>
            Vector3 m_Movement;
        </p></div>
        <p>The new line of code is instructing the computer to create a Vector3 variable called m_Movement that you can use wherever you want in the PlayerMovement class.</p>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Naming Conventions</h2>
        <p>But what does m_ mean at the beginning of the name? This is part of something called a naming convention. Naming conventions are used to identify a particular object or class of object. All variables start with a lowercase letter but subsequent words start with an uppercase letter - this is called camelCase.</p>
        <p>The exception to this is non-public member variables, which start with the m_ prefix and all words start with an uppercase letter - this is called PascalCase. Member variables are ones that belong to a class rather than a specific method. The m_ part of the non-public member variables comes from them being 'member' variables.</p>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Set the Values for your Variable</h2>
        <p>Now that you have a variable to store the movement for the character, you need to set the value for it. Since this could change every frame, you need to set it every frame — you should do this in the Update method.</p>
        <div class="unityCode" id="MovementSet"><button class="copy" onclick="copyText('MovementSet')">Copy</button><br><p>
            m_Movement.Set(horizontal, 0f, vertical);
        </p></div>
        <p>Vectors in 3D space have three values — this Set method assigns a value to each. It has three parameters, one for each coordinate of the vector. The movement vector now has a value of the horizontal input in the x axis, 0 in the y axis and the vertical input in the z axis. There’s also an f after the 0 for the second parameter, which is instructing the computer to treat that number as a float.</p>
        <p>Now you need to fix a small problem. The movement vector is made up of two numbers that can have a maximum value of 1. If they both have a value of 1, the length of the vector (known as its magnitude) will be greater than 1. This is the relation between sides of a triangle described by Pythagoras’ theorem.</p>
        <div class="center" style="padding: 10px; max-width: 200px;"><img src="../images/UnityImages/TriangleDiagram.jpg" alt="Triangle Diagram Image"></div>
        <p>This means that your character will move faster diagonally than it will along a single axis. In order to make sure this doesn’t happen, you need to ensure the movement vector always has the same magnitude. You can do this by normalizing it. Normalizing a vector means keeping the vector’s direction the same, but changing its magnitude to 1.</p>
        <p>Add the following script beneath the previous line you wrote, to call a method on the vector itself:</p>
        <div class="unityCode" id="Normalize"><button class="copy" onclick="copyText('Normalize')">Copy</button><br><p>
            m_Movement.Normalize ();
        </p></div>
        <p>Your full script should now look like this:</p>
        <div class="unityCode" id="DefaultScript"><button class="copy" onclick="copyText('DefaultScript')">Copy</button><br><p>
            using System.Collections;<br>
            using System.Collections.Generic;<br>
            using UnityEngine;<br><br>
            public class PlayerMovement : MonoBehaviour<br>
            {<br>
            &emsp;Vector3 m_Movement;<br><br>
            &emsp;<mark>// Start is called before the first frame update</mark><br>
            &emsp;void Start()<br>
            &emsp;{<br><br>
            &emsp;}<br><br>
            &emsp;<mark>// Update is called once per frame</mark><br>
            &emsp;void Update()<br>
            &emsp;{<br>
            &emsp;&emsp;float horizontal = Input.GetAxis ("Horizontal");<br>
            &emsp;&emsp;float vertical = Input.GetAxis ("Vertical");<br><br>
            &emsp;&emsp;m_Movement.Set(horizontal, 0f, vertical);<br>
            &emsp;&emsp;m_Movement.Normalize ();<br>
            &emsp;}<br>
            }
        </p>
        </div>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Set up the Animator component</h2>
        <p>Now that you’ve created a movement vector, there are some other jobs that need to be done every frame. You need to instruct the computer to:</p>
        <ul>
            <li>Tell the Animator component whether or not the character is walking.</li>
            <li>Get a rotation for the character from player input (similar to the way you got its movement).</li>
            <li>Apply the movement and rotation to the character.</li>
        </ul>
        <p>If there is any player input then your character should be walking, and if there is not then it should be idle.</p>
        <ol>
            <li>To start off, you need to write a line of code that determines whether or not there is horizontal input. Add the following code after the line normalizing the movement vector:</li>
            <div class="unityCode" id="HorizontalInput"><button class="copy" onclick="copyText('HorizontalInput')">Copy</button><br><p>
            bool hasHorizontalInput = !Mathf.Approximately (horizontal, 0f);
            </p></div>
            <p>Here you are creating a bool variable (one that can be either true or false) and calling it hasHorizontalInput. Then you’re setting that equal to the return value of a method. This method is called Approximately and is from the Mathf class. It takes two float parameters and returns a bool — true if the two floats are approximately equal and false otherwise. So in this scenario, the method will return true if the horizontal variable is approximately zero.</p>
            <p>There’s another character in this line you haven’t encountered before: the exclamation mark in front of the method call. This is the logical negation operator and it inverts a bool, setting true to false and false to true. This means that hasHorizontalInput is being set to true when horizontal is not approximately equal to 0. In other words, hasHorizontalInput is true when horizontal is non-zero.</p>
            <li>It’s not just the horizontal axis you care about, though. Add a similar line for the vertical axis:</li>
            <div class="unityCode" id="VerticalInput"><button class="copy" onclick="copyText('VerticalInput')">Copy</button><br><p>
            bool hasVerticalInput = !Mathf.Approximately (vertical, 0f);
            </p></div>
            <li>Now that you know when you are getting input on the axes, you need to combine them into a single bool. Add the following line of code:</li>
            <div class="unityCode" id="boolIsWalking"><button class="copy" onclick="copyText('boolIsWalking')">Copy</button><br><p>
            bool isWalking = hasHorizontalInput || hasVerticalInput;
            </p></div>
            <p>This line is creating another new bool variable called isWalking, which is set to hasHorizontalInput OR hasVerticalInput. The two vertical lines are the logical or operator. This compares the bool on each side. If either of them or both of them are true then it equates to true, otherwise it equates to false. That means that if hasHorizontalInput or hasVerticalInput are true then isWalking is true, and otherwise it is false.</p>
        </ol>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Create a variable to store a reference to the Animator component</h2>
        <p>Next, you need to tell the Animator component whether or not the character should be walking using the bool you have just created. To do this, you need to access the Animator component.</p>
        <p>Why do you need to do something special to access the Animator component, when you didn’t need to do it to call methods on Input or Mathf? This is due to the methods on Input and Mathf being static.</p>
        <p>Static methods are methods which are called on a class’s type, rather than an instance of that class. There is no need to have a single instance of the Input class in order to determine axis values, because input is more of a global concept. As such, the methods which obtain those values have been made static. Likewise, the Mathf class is full of helper methods (methods which help another method perform its task) which don’t involve any specific data for a specific instance of Mathf, and so those methods have also been made static.</p>
        <p>However, consider your m_Movement variable. You needed to set values specific to that particular instance of Vector3, so those methods were not static. The important thing to remember is that static methods are called using a type name and non-static methods (or 'instance' methods) are called using an instance name.</p>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Get a reference to the Animator component</h2>
        <p>Before you can access the Animator component you need a reference to it, and this is obtained using a method called GetComponent.  This reference will be used throughout the class and not just in a single method; it makes sense to keep it as member variable (like the movement vector) so its scope is local to the class.</p>
        <p>At the top of the class, above the movement vector declaration but below the class declaration, add the following line:</p>
        <div class="unityCode" id="Animator"><button class="copy" onclick="copyText('Animator')">Copy</button><br><p>
        Animator m_Animator;
        </p></div>
        <h2 style="text-align: center; background-color: #c8c8c8; border-top: 2px solid #555; border-bottom: 2px solid #555;">Set up the reference to the Animator component</h2>
        <p>You’ve created a variable to store a reference to the Animator component, but so far you haven’t set this variable to anything and it’s empty. When a variable is empty in this way in C#, it is said that its value is null.  Whenever there could be a reference to something and there isn’t one, the reference is null.</p>
        <p>You don’t want a null reference here, and so now you need to set up the reference properly. You also need to be able to access the Animator component in any method, so it’s important to set the reference as soon as possible. 
        One of the earliest methods to be called on a MonoBehaviour is the Start method, so it makes perfect sense to set up the reference there. Add the following line to the Start method:</p>
        <div class="unityCode" id="GetAnimatorComponent"><button class="copy" onclick="copyText('GetAnimatorComponent')">Copy</button><br><p>
        void Start ()<br>
        {<br>
        &emsp;m_Animator = GetComponent&lt;Animator&gt;();<br>
        }
        </p></div>
        <p>This line of code uses some familiar and some new syntax:</p>
        <ol>
            <li>The variable that you’re assigning to is on the left.</li>
            <li>The name of a method is on the right (but it doesn’t have anything written before it).</li>
            <li>There are angle-shaped brackets around Animator, before the parentheses that you have encountered before.</li>
            <li>The line ends with a semicolon.</li>
        </ol>
    </div>
</div>
</div>
<script type="text/javascript" src="../scripts/collapsible.js"></script>
</body>
</html>