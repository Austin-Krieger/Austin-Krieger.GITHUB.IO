<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Learning Java</title>
    <link rel="stylesheet" type="text/css" href="Styles.css">
</head>
<script type="text/javascript">
    function showAnswer(el1, el2){
        var element1 = document.getElementById(el1);
        var element2 = document.getElementById(el2);
        element1.style.transform = "perspective(600px) rotateY(-180deg)";
        element2.style.transform = "perspective(600px) rotateY(0deg)";
    }

    function hideAnswer(el1, el2){
        var element1 = document.getElementById(el1);
        var element2 = document.getElementById(el2);
        element1.style.transform = "perspective(600px) rotateY(0deg)";
        element2.style.transform = "perspective(600px) rotateY(180deg)";
    }
</script>
<body>
<h1 style="text-align:center;">Learning Java</h1><br>
<div class="flip3D" style="float: left;">
    <div class="back" id="Q1Back" onclick="hideAnswer('Q1Front', 'Q1Back')"><p>Java is the high-level, object-oriented, robust, secure programming language, platform-independent, high performance, Multithreaded, and portable programming language.</p></div>
    <div class="front" id="Q1Front" onclick="showAnswer('Q1Front', 'Q1Back')"><p>What is Java?</p></div>
</div>
<div class="flip3D" style="float: right;">
    <div class="back" id="Q2Back" onclick="hideAnswer('Q2Front', 'Q2Back')"><p>Classloader is a subsystem of JVM which is used to load class files. Whenever we run the java program, it is loaded first by the classloader. There are three built-in classloaders in Java: Bootstrap, Extension, System/Application.</p></div>
    <div class="front" id="Q2Front" onclick="showAnswer('Q2Front', 'Q2Back')"><p>What is classloader?</p></div>
</div>
<!-- <a href="FlashCards.html"><button class="collapsible">Interview Questions (Randomized)</button></a> -->
&nbsp;
<button class="collapsible">Features of Java</button>
<div class="content">
    <table>
        <tr>
            <th>Feature</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>Object Oriented</td>
            <td>Java can be easily extended since it is based on the Object model</td>
        </tr>
        <tr>
            <td>Platform Independent</td>
            <td>Java is compiled into platform independent byte code, which is interpreted by the JVM</td>
        </tr>
        <tr>
            <td>Simple</td>
            <td>Java is designed to be easy to learn</td>
        </tr>
        <tr>
            <td>Secure</td>
            <td>With Java's secure feature it enables to develop virus-free, tamper-free systems. Authentication techniques are based on public-key encryption</td>
        </tr>
        <tr>
            <td>Architecture-neutral</td>
            <td>Java compiler generates an architecture-neutral object file format known as byte code, so the users installed JVM will execute the code</td>
        </tr>
        <tr>
            <td>Portable</td>
            <td>Being architecture-neutral and having no implementation dependent aspects of the specification makes Java portable</td>
        </tr>
        <tr>
            <td>Robust</td>
            <td>Java makes an effort to eliminate error-prone situations by emphasizing mainly on compile time error checking and runtime checking</td>
        </tr>
        <tr>
            <td>Multithreaded</td>
            <td>With Java's multithreaded feature it is possible to write programs that can perform many tasks simultaneously. This design feature allows the developers to construct interactive applications that can run smoothly</td>
        </tr>
        <tr>
            <td>Interpreted</td>
            <td>Java byte code is translated on the fly to native machine instructions and is not stored anywhere. The development process is more rapid and analytical since the linking is an incremental and light-weight process</td>
        </tr>
        <tr>
            <td>High Performance</td>
            <td>With the use of Just-In-Time compilers, Java enables high performance</td>
        </tr>
        <tr>
            <td>Distributed</td>
            <td>Java is designed for the distributed environment of the internet</td>
        </tr>
        <tr>
            <td>Dynamic</td>
            <td>Java is considered to be more dynamic than C or C++ since it is designed to adapt to an evolving environment. Java programs can carry an extensive amount of run-time information that can be used to verify and resolve accesses to objects at run-time</td>
        </tr>
    </table>
    &nbsp;
    <button class="collapsible">JRE, JDK and JVM</button>
    <div class="content">
        <h2>Running your Java Program</h2>
        <p>Source Code is given to the compiler which Generates Byte code (.class files) which are given to the JVM (interprets the byte code) and the program executes.</p>
        <p>Anytime you want to run your program you need to have your JRE</p>
        <table>
            <tr>
                <td>JRE (Java Runtime Environment)</td>
                <td>Provides the libraries, the JVM, and other components to run applications written in Java. In short the JRE enables Java bytecode to run on any platform.</td>
            </tr>
            <tr>
                <td>JDK (Java Development Kit)</td>
                <td>Contains everything that is in the JRE as well as the Compilers and Debuggers necessary for developing Java Applications. In short the JRE is used to develop Java applications/programs.</td>
            </tr>
            <tr>
                <td>JVM (Java Virtual Machine)</td>
                <td>Sits in between the compiler and the CPU and interprets the bytecode into readable machine language for the CPU. In short the JVM Interpret the byte codes and performs the execution on it.</td>
            </tr>
        </table>
        <p>Byte Code: When we compile the Java program it generates byte code (.class files), which can be interpreted by the JVM.</p>
        <h3>JVM</h3>
        <ul>
            <li>The Java Virtual Machine is an abstract layer between a Java program and the platform that Java program is running on.</li>
            <li>JVM is platform dependent and available for specific platforms (Operating Systems).</li>
            <li>JVM cannot understand Java (source code). It can only understand the bytecode (.class file) we get from compiling our .java source file.</li>
            <li>The compiled bytecode doesn't run on CPU directly, JVM sits in between and interprets the bytecode into readable machine language for the CPU.</li>
        </ul>
        <h3>JRE</h3>
        <ul>
            <li>Provides the libraries, the JVM, and other components to run applications written in Java.</li>
            <li>Enables Java bytecode to run on any platform.</li>
            <li>JRE enables Java bytecode to run on any platform. Bytecodes are interpreted by the JVM, at runtime classes found in the JRE when they need to perform actions, they cannot do by themselves.</li>
            <li>Platform Dependent</li>
        </ul>
        <h3>JDK</h3>
        <ul>
            <li>A superset of the JRE, containing everything that is in the JRE, it also includes development tools such as the compilers and debuggers necessary for developing java applications.</li>
            <li>Platform Dependent</li>
        </ul>
        <h2>Programming Paradigms</h2>
        <ol>
            <li>Process-Oriented Model: A program is a series of linear steps (that is, code).</li>
            <ul>
                <li>Characterized as code acting on data.</li>
                <li>Includes Procedural Languages such as C.</li>
                <li>To manage increasing complexity, the second approach was conceived</li>
            </ul>
            <li>Object-Oriented Programming: Organizes a program around its data (that is, objects) and a set of well-defined interfaces to that data.</li>
            <ul>
                <li>Characterized as data controlling access to code.</li>
                <li>By switching the controlling entity to data, you can achieve several organizational benefits.</li>
                <li>OOP is a programming language model in which programs are organized around data, or objects, rather than functions and logic.</li>
                <li>OOP helps us reduce complexity, promote code reuse, and prevent code redundancies.</li>
            </ul>
        </ol>
        <h2>The Java Programming Language Platforms</h2>
        <ul>
            <li>Java Platform, Standard Edition (Java SE)</li>
            <li>Java Platform, Enterprise Edition (Java EE)</li>
            <li>Java Platform, Micro Edition (Java ME)</li>
            <li>JavaFX</li>
        </ul>
        <p>All of the above platforms consist of a Java Virtual Machine (JVM) and an application programming interface (API).</p>
        <p>The Java Virtual Machine is a program, for a particular hardware and software platform, that runs Java technology applications.</p>
        <p>An API is a collection of interfaces components that you can use to create other software components or applications.</p>
        <h3>Java SE (Java Standard Edition)</h3>
        <p>This is the core Java programming platform. It contains all of the libraries and APIs that any Java programmer should learn (java.lang, java.io, java.math, java.net, java.util, etc…).When most people think of the Java programming language, they think of the Java SE API. Java SE’s API provides the core functionality of the Java programming language. It defines everything from the basic types and objects of the Java programming language to high-level classes that are used for networking, security, database access, graphical user interface (GUI) development, and XML parsing.</p>
        <p>In addition to the core API, the Java SE platform consists of a virtual machine, development tools, deployment technologies, and other class libraries and toolkits commonly used in Java technology applications.</p>
        <h3>Java EE (Java Enterprise Edition)</h3>
        <p>The Java EE platform is built on top of the Java SE platform. The Java EE platform provides an API and runtime environment for developing and running large-scale, multi-tiered, scalable, reliable, and secure network applications.</p>
        <h3>Java ME (Java Micro Edition)</h3>
        <p>The Java ME platform provides an API and a small-footprint virtual machine for running Java programming language applications on small devices, like mobile phones. The API is a subset of the Java SE API, along with special class libraries useful for small device application development. Java ME applications are often clients of Java EE platform services.</p>
        <h3>JavaFX</h3>
        <p>JavaFX is a platform for creating rich internet applications using a lightweight user-interface API. JavaFX applications use hardware-accelerated graphics and media engines to take advantage of higher-performance clients and a modern look-and-feel as well as high-level APIs for connecting to networked data sources. JavaFX applications may be clients of Java EE platform services.</p>
        <p style="font-weight: bold;">Packages: Essentially a grouping of classes.</p>
        <ul>
            <li>Used to segregate the code for easy import and export.</li>
        </ul>
    </div>
</div>
&nbsp;
<button class="collapsible">Object Oriented Programming Principles</button>
<div class="content">
<h2>Object Oriented Programming Principles</h2>
<button class="collapsible">Abstraction</button>
<div class="content">
    <p>Abstraction</p>
    <ul>
        <li>Data abstraction is the process of hiding certain details and showing only essential information to the user. Abstraction can be achieved with either abstract classes or interfaces.</li>
        <li>Managing the complexity of a system through the use of hierarchical classifications.</li>
        <li>On a high level we are hiding the functionality of the underlying systems.</li>
        <li>From the outside, a car is a single object, once inside, you see that the car consists of several subsystems: steering, brakes, sounds system, and so on.</li>
        <li>People do not think of a car as a set of thousands of parts, but a well defined object with its own unique behaviour.</li>
        <li>People can ignore the details of how the engine, and braking systems work and instead utilize the object as a whole.</li>
    </ul>
    <p>Example:</p>
    <ul>
        <p>Thinking of it as a folder structure on your operating system: Car would be the first folder and inside you would see folders for all of its subsystems inside the Sound System folder their could be folders for the Radio, CD player, and MP3 Systems and so on</p>
    </ul>
</div>
<button class="collapsible"> Encapsulation </button>
<div class="content">
    <p>Encapsulation</p>
    <ul>
        <li>The mechanism that binds together code and the data it manipulates, and keeps both safe from outside interference and misuse.</li>
        <li>In Java, the basis of encapsulation is the class which defines the structure and behaviour that will be shared by a set of objects.</li>
        <li>"A class is a logical construct, an object has physical reality"</li>
    </ul>
    <p>Example:</p>
    <ul>
        <p>A protective wrapper that prevents the code and data from being arbitrarily accessed by other code defined outside the wrapper.</p>
        <p>The gear-shift lever is a well-defined interface to the transmission in your vehicle, you can't affect the transmission by using the turn signal or windshield wipers.</p>
    </ul>
</div>
<button class="collapsible"> Inheritance </button>
<div class="content">
    <h3>Inheritance</h3>
    <ul>
        <li>The process by which one object acquires the properties of another object.</li>
        <li>Useful when you are not changing the implementations, but the definitions.</li>
        <li>The object can inherit its general properties from its parent.</li>
        <li>A deeply inherited subclass inherits all of the attributes form each of its ancestors in the class hierarchy.</li>
        <li>Inheritance interacts with encapsulation as well. If a given class encapsulates some attributes, then any subclass will have the same attributes plus any that it adds as part of its specialization.</li>
    </ul>
    <h3>Multiple Inheritance</h3>
    <p>A class can inherit properties of more than one parent class. However, there is a problem associated with this known as the "Diamond Problem".</p>
    <h3>The Diamond Problem</h3>
    <p>When more than one parent class has a method of the same name the compiler cannot determine which super classes' method to use; causing a compilation error.</p>
    <h3>Tight Coupling</h3>
    <p>Tight Coupling: this is bad because, changing something in class A could change the functionality of class B which is extending it, and returning incorrect values. This is making the system rigged and no longer extensible.</p>
    <p>Example:</p>
    <ul>
        <p>A golden retriever is part of the classification dog, which is in turn a part of the mammal class, which is under the larger class animal.</p>
    </ul>
</div>
<button class="collapsible"> Polymorphism </button>
<div class="content">
    <p>Polymorphism</p>
    <ul>
        <li>A feature that allows one interface to be used for a general class of actions.</li>
        <li>The specific action is determined by the exact nature of the situation.</li>
        <li>This helps reduce complexity by allowing the same interface to be used to specify a general class of actions.</li>
        <li>It is the compiler's job to select the specific action (that is, method) as it applies to each situation.</li>
    </ul>
    <p>Example:</p>
    <ul>
        <p>A dog's sense of smell is polymorphic:</p>
        <ul>
            <p>If the dog smells a cat, it will bark and run after it.</p>
            <p>If the dog smells food, it will salivate and run to its bowl.</p>
        </ul>
    </ul>
    <h2>Two Types:</h2>
    <ul>
        <p>Static/Compile-Time Polymorphism:</p>
        <ul>
            <p>Specifying different forms during compile time.</p>
            <p>Method Overloading</p>
        </ul>
        <p>Dynamic/Runtime Polymorphism:</p>
        <ul>
            <p>Method Overriding</p>
        </ul>
    </ul>
    <h2>Dynamic Method Dispatch:</h2>
    <ul>
        <p>The mechanism by which a call to an overridden method is resolved at runtime rather than compile time.</p>
        <p>This is how Java implements runtime polymorphism.</p>
    </ul>
</div>
<p>Polymorphism, Encapsulation, and Inheritance Working Together:</p>
<ul>
    <li>A well-designed hierarchy of classes is the basis for reusing the code in which you have invested time and effort developing and testing.</li>
    <li>Encapsulation allows you to migrate your implementations over time without breaking the code that depends on the public interface of your classes.</li>
    <li>Polymorphism allows you to create clean, sensible, readable, and resilient code.</li>
</ul>
</div>
&nbsp;
<button class="collapsible">Data Types, Variables and Arrays</button>
<div class="content">
<button class="collapsible">Data Types</button>
<div class="content">
    <h2>Primitive Types (8): byte, short, int, long, char, float, double, boolean</h2>
    <p>Not object-oriented, found in most other languages, the reason for their non-object-oriented existence is for efficiency.</p>
    <p>Java does not support unsigned, positive-only integers.</p>
    <table>
        <tr>
            <td colspan="2" style="background-color: black; color: white;">Four Integer Types</td>
        </tr>
        <tr>
            <td rowspan="2">byte</td>
            <td>(8 bit) -128 to 127</td>
        </tr>
        <tr>
            <td>byte b = 127;</td>
        </tr>
        <tr>
            <td rowspan="2">short</td>
            <td>(16 bit) -32,768 to 32,767</td>
        </tr>
        <tr>
            <td>short s = 32767;</td>
        </tr>
        <tr>
            <td rowspan="2">int</td>
            <td>(32 bit) -2,147,483,648 to 2,147,483,647</td>
        </tr>
        <tr>
            <td>int i = 2147483647;</td>
        </tr>
        <tr>
            <td rowspan="2">long</td>
            <td>(64 bit) -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
        </tr>
        <tr>
            <td>long l = 9223372036854775807;</td>
        </tr>
        <tr>
            <td colspan="2" style="background-color: black; color: white;">Floating-point Numbers (#'s with fractional precision)</td>
        </tr>
        <tr>
            <td rowspan="2">float</td>
            <td>(32 bit) 1.4e to 3.4e+038</td>
        </tr>
        <tr>
            <td>float f = 1.1754890;</td>
        </tr>
        <tr>
            <td rowspan="2">double</td>
            <td>(64 bit) 4.9e-324 to 1.8e+308</td>
        </tr>
        <tr>
            <td>double d = 2.2738490948485;</td>
        </tr>
        <tr>
            <td colspan="2" style="background-color: black; color: white;">Characters (Represent symbols in a character set)</td>
        </tr>
        <tr>
            <td rowspan="2">char</td>
            <td>(16 bits rather than the usual 8-bits in other languages) 0 to 65,536</td>
        </tr>
        <tr>
            <td>char c = 'a';</td>
        </tr>
        <tr>
            <td colspan="2" style="background-color: black; color: white;">Boolean (Special type for representing True/False)</td>
        </tr>
        <tr>
            <td rowspan="2">boolean</td>
            <td>True / False</td>
        </tr>
        <tr>
            <td>boolean t = true;</td>
        </tr>
    </table>
    <h3>Wrapper Class</h3>
    <p>The primitive data types (integers, floats, doubles, ...) are not objects, so their corresponding object versions are called wrapper classes.</p>
    <h3>Wrapper Type</h3>
    <p>The object version of the primitive data types for example "Double" is the object version of double.</p>
    <h2>Literals</h2>
    <h3>Integer Literals</h3>
    <p>Any whole number value is an integer literal.</p>
    <table>
        <tr>
            <td>base 10 numbers</td>
            <td>(decimal)</td>
        </tr>
        <tr>
            <td>base 8 numbers</td>
            <td>(octal) denoted by a leading zero, Range: 0-7</td>
        </tr>
        <tr>
            <td>base 16 numbers</td>
            <td>(hexadecimal) signified by a leading 0x or 0X</td>
        </tr>
    </table>
    <p>Assigning an integer literal to one of java's other integer types is easy as long as the literal value is within the range of the target type.</p>
    <p>You can assign an integer literal to a long variable by explicitly telling the compiler that the literal value is of type long.</p>
    <h3>Floating-Point Literals</h3>
    <p>Represent decimal values with a fractional component and can be expressed in standard or scientific notation.</p>
    <p>To specify a float literal you must append an F or f to the constant.</p>
    <p>To Explicity specify a double literal you must append a D or d to the constant, but doing so is redundant.</p>
    <h3>Boolean Literals</h3>
    <p>Boolean Literals do not convert into any numerical representation, they can have the values true or false.</p>
    <h3>Character Literals</h3>
    <p>Represented inside a pair of single quotes 'a', 'z', '@'.</p>
    <ul>
        <li>\ddd Octal character ddd</li>
        <li>\uxxxx Hexadecimal Unicode character xxxx</li>
        <li>\' Single-quote</li>
        <li>\" Double-quote</li>
        <li>\n Newline</li>
        <li>\\ Backslash</li>
        <li>\r Carriage return</li>
        <li>\f Form feed</li>
        <li>\t Tab</li>
        <li>\b Backspace</li>
    </ul>
    <p>Octal notation: '\141' is the letter 'a'</p>
    <p>Hexadecimal notation: '\u0061' is the ISO-Latin-1 'a'</p>
    <h3>String Literals</h3>
    <p>Specified by enclosing a sequence of characters in a pair of double quotes. "Hello World!"</p>
    <p>Strings must begin and end on the same line, there is no line-continuation escape sequence.</p>
</div>
&nbsp;
<button class="collapsible">Variables</button>
<div class="content">
    <h2>Variables</h2>
    <p>The basic unit of storage in a Java program.</p>
    <h2>Declaring a Variable</h2>
    <p>Variables must be declared before they can be used.</p>
    <div class="code">
        Type identifier [ = value ][, identifier [ = value ] ...];<br>
        int value1 = 12, value2 = 24;
    </div>
    <h3>Java Identifiers</h3>
    <p>All Java variables must be identified with unique names known as identifiers.</p>
    <p>Identifiers can be short names (like x and y) or more descriptive names "recommended" (age, sum, totalVolume).</p>
    <p>The general rules for constructing names for variables (unique identifiers) are:</p>
    <ul>
        <li>Names can contain letters, digits, underscores, and dollar signs</li>
        <li>Names should begin with a letter</li>
        <li>Names can also begin with $ and _</li>
        <li>Names are case sensitive ("myVar" and "myvar" are different variables)</li>
        <li>Names should start with a lowercase letter and it cannot contain whitespace</li>
        <li>Reserved words (like Java keywords, such as int or String) cannot be used as names</li>
    </ul>
    <table>
        <tr>
            <th rowspan="2">Instance Variables</th>
            <td>"The data, or variables, defined within a class"</td>
        </tr>
        <tr>
            <td>Each instance/object of a class contains its own copy of these variables</td>
        </tr>
        <tr>
            <th rowspan="2">Local Variables</th>
            <td>A variable declared inside the body of the method/block. Only visible within that method/blcok.</td>
        </tr>
        <tr>
            <td>Braces indicate the scope of this variable (where it can be seen and used).</td>
        </tr>
        <tr>
            <th rowspan="2">Static Variables (Class Variables)</th>
            <td>Exist without creating an object and share the same value among all objects created from the same class.</td>
        </tr>
        <tr>
            <td>A variable that has been allocated "statically", meaning that its lifetime (or "extent") is the entire run of the program.</td>
        </tr>
    </table>
    <p style="font-weight: bold;">Dynamically Initializing Variables:</p>
    <ul>
        <li>Java allows variable to be initialized dynamically, using any expression valid at the time the variable is declared.</li>
        <li>double c = Math.sqrt(a * a + b * b);</li>
    </ul>
    <p style="font-weight: bold;">Scope and Lifetime of Variables:</p>
    <ul>
        <li>All variables have a scope, which defines their visibility and lifetime.</li>
        <li>Variables are created when their scope is entered and destroyed when their scope is left.</li>
        <li>A variable will not hold its value once it has gone out of scope.</li>
    </ul>
    <p style="font-weight: bold;">Conversion and Casting:</p>
    <ul>
        <li>Assign a value of one type to a variable of another type.</li>
        <li>If the two types are compatible then Java will perform the conversion automatically or "implicitly".</li>
        <li>Not all types are compatible, but it is still possible to perform the conversion explicitly using a cast.</li>
        <ul>
            <li style="font-weight: bold;">Implicit type conversion: "Automatic Type Conversion" Occurs when:</li>
            <ul>
                <li>Two types are compatible.</li>
                <li>The target type is larger than the source type.</li>
            </ul>
            <br>
            <ol>
                <li>If one of the operands is double, the other is promoted to double before the operation is carried out.</li>
                <li>Otherwise, if one of the operands is float, the other is promoted to float before the operation is carried out.</li>
                <li>Otherwise, if one of the operands is long, the other is promoted to long before the operation is carried out.</li>
                <li>Otherwise if either operand is int, the other operand is promoted to int.</li>
                <li>If neither operand is double, float, long or int, both operands are promoted to int.</li>
            </ol>
            <div class="code">byte b = 10; <br> long l = 1 + 8; <br> double d = b * 2.5 + l; <br><br> System.out.println("I = " + i); <br> System.out.println("J = " + j); <br> System.out.println("K =" + k); <br><br> <b>Output:</b> <br><br>I = 10 <br>J = 9 <br>K = 34.0</div>
        </ul>
        <ul>
            <li style="font-weight: bold;">Explicit type conversion: (target-type) value</li>
        </ul>
        <div class="code">int a; <br> byte b; <br> b = (byte) a;</div>
    </ul>
    </div>
    &nbsp;
    <button class="collapsible">Arrays</button>
    <div class="content">
    <h3>Arrays</h3>
    <ul></ul>
        <li>An array is a group of like-typed variables that are referred to by a common name.</li>
        <li>Arrays of any type can be created and may have one or more dimensions.</li>
        <li>A specific element in an array is accessed by its index, and indexes start at 0</li>
        <li>Arrays offer a convenient means of grouping related information.</li>
    </ul>
    <h3>One-Dimensional Arrays</h3>
    <p>One-dimensional arrays are essentially lists of like-types variables.</p>
    <div class="code">
        type var-name[]; or type[] var-name;
    </div>
    <p>The base type of the array determines what type of data the array will hold and new is a special operator that allocates memory.</p>
    <div class="code">
        array-var = new type[size];
    </div>
    <p>type specifies the type of data being allocated and size specifies the number of elements.</p>
    <p>array-var is the array variable that is linked to the array.</p>
    <div class="code">
        month_days = new int[12]; <mark>// Create a new integer array</mark><br>
        month_days[1] = 28; <mark>// Give index 1 a value of 28</mark>
    </div>
    <p>Combine the declaration of the array with the allocation of the array.</p>
    <div class="code">
        int month_days[] = new int[12];
    </div>
    <p>Arrays can also be initialized when they are declared.</p>
    <div class="code">
        int month_days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    </div>
    <h3>Multidimensional Arrays</h3>
    <p>Multidimensional Arrays are "Arrays of Arrays"</p>
    <div class="code">
        <mark>// Allocate a 4 by 5 array and assign it to twoD</mark><br>
        int twoD[][] = new int [4][5];
    </div>
    <p>When you allocate the memory for a multi-dimentional array, you need only specify the memory for the first (leftmost) dimension. You can allocate the memory for the remaining dimensions separately.</p>
    <div class="code">
        int twoD[][] = new int[4][];<br>
        twoD[0] = new int[5];<br>
        twoD[1] = new int[5];<br>
        twoD[2] = new int[5];<br>
        twoD[3] = new int[5];
    </div>
    </div>
</div>
&nbsp;
<button class="collapsible">String</button>
<div class="content">
    <h3>Strings</h3>
    <p>Strings are used for storing text. A String variable contains a collection of characters surrounded by double quotes</p>
    <div class="code">
        String greeting = "Hello";
    </div>
    <h3>String Length</h3>
    <p>A String in Java is actually an object, which contain methods that can perform certain operations on strings. For example, the length of a string can be found with the length() method.</p>
    <h3>String Methods</h3>
    <button class="collapsible">String Methods</button>
    <div class="content">
    <table>
        <tr>
            <th>Method</th>
            <th>Description</th>
            <th>Return Type</th>
        </tr>
        <tr>
            <td>charAt()</td>
            <td>Returns the character at the specified index (position)</td>
            <td>char</td>
        </tr>
        <tr>
            <td>codePointAt()</td>
            <td>Returns the Unicode of the character at the specified index</td>
            <td>int</td>
        </tr>
        <tr>
            <td>codePointBefore()</td>
            <td>Returns the Unicode of the character before the specified index</td>
            <td>int</td>
        </tr>
        <tr>
            <td>codePointCount()</td>
            <td>Returns the Unicode in the specified text range of this String</td>
            <td>int</td>
        </tr>
        <tr>
            <td>compareTo()</td>
            <td>Compares two strings lexicographically</td>
            <td>int</td>
        </tr>
        <tr>
            <td>compareToIgnoreCase()</td>
            <td>Compares two strings lexicographically, ignoring case differences</td>
            <td>int</td>
        </tr>
        <tr>
            <td>concat()</td>
            <td>Appends a string to the end of another string</td>
            <td>String</td>
        </tr>
        <tr>
            <td>contains()</td>
            <td>Checks whether a string contains a sequence of characters</td>
            <td>boolean</td>
        </tr>
        <tr>
            <td>contentEquals()</td>
            <td>Checks whether a string contains the exact same sequence of characters of the specified CharSequence or StringBuffer</td>
            <td>boolean</td>
        </tr>
        <tr>
            <td>copyValueOf()</td>
            <td>Returns a String that represents the characters of the character array</td>
            <td>String</td>
        </tr>
        <tr>
            <td>endsWith()</td>
            <td>Checks whether a string ends with the specified character(s)</td>
            <td>boolean</td>
        </tr>
        <tr>
            <td>equals()</td>
            <td>Compares two strings. Returns true if the strings are equal, and false if not</td>
            <td>boolean</td>
        </tr>
        <tr>
            <td>equalsIgnoreCase()</td>
            <td>Compares two strings, ignoring case considerations</td>
            <td>boolean</td>
        </tr>
        <tr>
            <td>format()</td>
            <td>Returns a formatted string using the specified locale, format string, and arguments</td>
            <td>String</td>
        </tr>
        <tr>
            <td>getBytes()</td>
            <td>Encodes this String into a sequence of bytes using the named charset, storing the result into a new byte array</td>
            <td>byte[]</td>
        </tr>
        <tr>
            <td>getChars()</td>
            <td>Copies characters from a string to an array of chars</td>
            <td>void</td>
        </tr>
        <tr>
            <td>hashCode()</td>
            <td>Returns the hash code of a string</td>
            <td>int</td>
        </tr>
        <tr>
            <td>indexOf()</td>
            <td>Returns the position of the first found occurrence of specified characters in a string</td>
            <td>int</td>
        </tr>
        <tr>
            <td>intern()</td>
            <td>Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index</td>
            <td>String</td>
        </tr>
        <tr>
            <td>isEmpty()</td>
            <td>Checks whether a string is empty or not</td>
            <td>boolean</td>
        </tr>
        <tr>
            <td>lastIndexOf()</td>
            <td>Returns the position of the last found occurrence of specified characters in a string</td>
            <td>int</td>
        </tr>
        <tr>
            <td>length()</td>
            <td>Returns the length of a specified string</td>
            <td>int</td>
        </tr>
        <tr>
            <td>matches()</td>
            <td>Searches a string for a match against a regular expression, and returns the matches</td>
            <td>boolean</td>
        </tr>
        <tr>
            <td>offsetByCodePoints()</td>
            <td>Returns the index within this String that is offset from the given index by codePointOffset code points</td>
            <td>int</td>
        </tr>
        <tr>
            <td>regionMatches()</td>
            <td>Tests if two string regions are equal	</td>
            <td>boolean</td>
        </tr>
        <tr>
            <td>replace()</td>
            <td>Searches a string for a specified value, and returns a new string where the specified values are replaced</td>
            <td>String</td>
        </tr>
        <tr>
            <td>replaceFirst()</td>
            <td>Replaces the first occurrence of a substring that matches the given regular expression with the given replacement</td>
            <td>String</td>
        </tr>
        <tr>
            <td>replaceAll()</td>
            <td>Replaces each substring of this string that matches the given regular expression with the given replacement</td>
            <td>String</td>
        </tr>
        <tr>
            <td>split()</td>
            <td>Splits a string into an array of substrings</td>
            <td>String[]</td>
        </tr>
        <tr>
            <td>startsWith()</td>
            <td>Checks whether a string starts with specified characters</td>
            <td>boolean</td>
        </tr>
        <tr>
            <td>subSequence()</td>
            <td>Returns a new character sequence that is a subsequence of this sequence</td>
            <td>CharSequence</td>
        </tr>
        <tr>
            <td>substring()</td>
            <td>Extracts the characters from a string, beginning at a specified start position, and through the specified number of character</td>
            <td>String</td>
        </tr>
        <tr>
            <td>toCharArray()</td>
            <td>Converts this string to a new character array</td>
            <td>char[]</td>
        </tr>
        <tr>
            <td>toLowerCase()</td>
            <td>Converts a string to lower case letters</td>
            <td>String</td>
        </tr>
        <tr>
            <td>toString()</td>
            <td>Returns the value of a String object</td>
            <td>String</td>
        </tr>
        <tr>
            <td>toUpperCase()</td>
            <td>Converts a string to upper case letters</td>
            <td>String</td>
        </tr>
        <tr>
            <td>trim()</td>
            <td>Removes whitespace from both ends of a string</td>
            <td>String</td>
        </tr>
        <tr>
            <td>valueOf()</td>
            <td>Returns the primitive value of a String object</td>
            <td>String</td>
        </tr>
    </table>
    </div>
    <p>Java counts positions from zero. 0 is the first position in a string, 1 is the second, 2 is the third ..</p>
    <h3>concat() Method</h3>
    <p>The Java String concat() method concatenates one string to the end of another string. This method returns a string with the value of the string passed into the method, appended to the end of the string.</p>
    <div class="code">
        String s = "Java";<br>
        s = s.concat("! is the best.");<br>
        System.out.println(s);
    </div>
    <p>Output:</p>
    <div class="code">
        Java! is the best.
    </div>
    <h3>+ Operator</h3>
    <p>+ operator is used to concatenate strings on either side.</p>
    <div class="code">
        String s1 = "Java";<br>
        String s2 = "! is the best.";<br>
        String s3 = s1 + s2;<br>
        System.out.println(s3);
    </div>
    <p>Output:</p>
    <div class="code">
        Java! is the best.
    </div>
    <h3>Difference between concat() and + operator</h3>
    <p>Although concat() and + operator are both used for concatenation of strings, but there are some differences between them:</p>

    <table>
        <tr>
            <th>Points</th>
            <th>concat() Method</th>
            <th>+ Operator</th>
        </tr>
        <tr>
            <td>Definition</td>
            <td>A concat() method is method to combine two strings .</td>
            <td>+ operator used to concatenate any number of strings.</td>
        </tr>
        <tr>
            <td>Number of arguments</td>
            <td>concat() method takes only one argument of string and concat it with other string.</td>
            <td>+ operator takes any number of arguments and concatenates all the strings.</td>
        </tr>
        <tr>
            <td>Type of arguments</td>
            <td>strong>concat() method takes only string arguments, if there is any other type is given in arguments then it will raise an error.</td>
            <td>+ operator takes any type and converts to string type and then concatenates the strings.</td>
        </tr>
        <tr>
            <td>concat() method raises java.lang.NullPointer Exception</td>
            <td>concat() method throws NullPointer Exception when string is concatenated with null</td>
            <td>+ operator did not raise any Exception when the string is concatenated with null.</td>
        </tr>
        <tr>
            <td>Creates a new String object</td>
            <td>concat() method takes concatenates two strings and return new string object only string length is greater than 0, otherwise it returns same object.</td>
            <td>+ operator creates a new string object every time irrespective of length of string.</td>
        </tr>
        <tr>
            <td>NullPointer Exception</td>
            <td>In concat() method raises NullPointer Exception when string is concatenated with null .</td>
            <td>+ operator concatenates string with without any error.</td>
        </tr>
        <tr>
            <td>Performance</td>
            <td>concat() method is better than + operator because it creates a new object only when the string length is greater than zero(0) but + operator always a creates a new string irrespective of length of string.</td>
            <td>+ operator always a creates a new string irrespective of length of string therefore it takes more memory.</td>
        </tr>
    </table>
    <h3>Special Characters</h3>
    <p>Because strings must be written within quotes, Java will misunderstand this string, and generate an error</p>
    <div class="code">
        String txt = "We are the so-called "Vikings" from the north.";
    </div>
    <p>To avoid this problem we have the backslash excape character. (\)</p>
    <table>
        <tr>
            <th>Escape Character</th>
            <th>Result</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>\'</td>
            <td>'</td>
            <td>Single quote</td>
        </tr>
        <tr>
            <td>\"</td>
            <td>"</td>
            <td>Double quote</td>
        </tr>
        <tr>
            <td>\\</td>
            <td>\</td>
            <td>Backslash</td>
        </tr>
        <tr>
            <td>\n</td>
            <td>New Line</td>
            <td>Text after \n will print on the next line</td>
        </tr>
        <tr>
            <td>\r</td>
            <td>Carriage Return</td>
            <td>Text after \r will print on the next line</td>
        </tr>
        <tr>
            <td>\t</td>
            <td>Tab</td>
            <td>Insert 4 spaces</td>
        </tr>
        <tr>
            <td>\b</td>
            <td>Backspace</td>
            <td>Delete a character</td>
        </tr>
        <tr>
            <td>\f</td>
            <td>Form Feed</td>
            <td>Form Feed</td>
        </tr>
    </table>
    <h3>Adding Numbers and Strings</h3>
    <p>If you add a number and a string, the result will be a string concatenation.</p>
    <div class="code">
        String x = "10";<br>
        int y = 20;<br>
        String z = x + y; <mark>// z will be 1020 (a String)</mark>
    </div>
</div>
&nbsp;
<button class="collapsible">Access Modifiers</button>
<div class="content">
    <h2>Access Modifiers</h2>
    <p>Allow the programmer to control the visibility of class members.</p>
    <h3>Class level</h3>
    <p>Without a modifier a class is assumed package-private and visible only within its own package.</p>
    <p>Public: class is visible to all classes everywhere.</p>
    <h3>Member level</h3>
    <table>
        <tr>
            <th rowspan="2">Public</th>
            <td>That member may be accessed by any code within its package.</td>
        </tr>
        <tr>
            <td>Example: Your name, birthday, things that anyone can access.</td>
        </tr>
        <tr>
            <th rowspan="2">Private</th>
            <td>That member can only be accessed by other members of its class, unless a public interface is provided (getters/setters).</td>
        </tr>
        <tr>
            <td>Example: Only you have access to this information.</td>
        </tr>
        <tr>
            <th rowspan="2">Protected</th>
            <td>Can be accessed within the same package or classes that subclass your class directly from other packages.</td>
        </tr>
        <tr>
            <td>Example: Parents and relatives can access.</td>
        </tr>
        <tr>
            <th rowspan="2">No Modifier (default)</th>
            <td>Can be accessed from anywhere within the same package.</td>
        </tr>
        <tr>
            <td>Example: People with whom you live can access.</td>
        </tr>
    </table>
    <p>Example a 10 year old could understand: Cookies left on the counter are for anyone and cookies in the cookie jar are private/protected.</p>
</div>
&nbsp;
<button class="collapsible">Methods</button>
<div class="content">
    <h3>Methods</h3>
    <p>A method is a block of code which only runs when it is called.</p>
    <ul>
        <li>You can pass data, known as parameters, into a method.</li>
        <li>Methods are used to perform certain actions, and they are also known as functions.</li>
        <li>Why use methods? To reuse code: define the code once, and use it many times.</li>
    </ul>
    <h3>Create a Method</h3>
    <p>A method must be declared within a class. It is defined with the name of the method, followed by parentheses (). Java provides some pre-defined methods, such as System.out.println(), but you can also create your own methods to perform certain actions</p>
    <h3>static</h3>
    <p>the method belongs to the class and not an object.</p>
    <h3>void</h3>
    <p>The method does not have a return value.</p>
    <h3>Call a Method</h3>
    <p>To call a method in Java, write the method's name followed by two parentheses () and a semicolon;</p>
    <h3>Method Parameters</h3>
    <ul>
        <li>Information can be passed to functions as parameter. Parameters act as variables inside the method.</li>
        <li>Parameters are specified after the method name, inside the parentheses. You can add as many parameters as you want, just separate them with a comma.</li>
    </ul>
    <h3>Return Values</h3>
    <p>If you want the method to return a value, you can use a primitive data type (such as int, char, etc.) instead of void, and use the return keyword inside the method.</p>
    <div class="code">
        static int myMethod(int x) {<br>
        &emsp;return 5 + x;<br>
        }
    </div>
    <table>
        <tr>
            <th>Finalize Method</th>
            <td>Method which will be called during garbage collection process before data is removed from memory.</td>
        </tr>
        <tr>
            <th>Static Method</th>
            <td>Methods that are part of the class and not the instance, so they can be called without creating a new object.</td>
        </tr>
        <tr>
            <th>Default Method</th>
            <td>Lets you define a default implementation for an interface method.</td>
        </tr>
        <tr>
            <th>Abstract Method</th>
            <td>You can require that certain methods be overridden by subclasses by specifying the abstract type modifier.</td>
        </tr>
    </table>
    <h3>Abstract Method</h3>
    <p>Can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from).</p>
    <p><b>general form:</b> abstract type name (parameter-list);</p>
    <h3>Static Block</h3>
    <p>Static Block: Like a static method, but without a name.</p>
    <ol>
        <li>Called whenever the class is being loaded by the JVM and executed even before the main method.</li>
        <li>Executed once when the class is being loaded, we cannot call static blocks.</li>
        <li>Not part of the object, but part of the class.</li>
    </ol>
    <div class="code">
        class Test {<br>
        &emsp;static int i;<br><br>
        &emsp;<mark>// start of static block</mark><br>
        &emsp;static {<br>
        &emsp;&emsp;i = 10;<br>
        &emsp;&emsp;System.out.println("static block called");<br>
        &emsp;}<br>
        &emsp;<mark>// end of static block</mark><br>
        }<br><br>
        class Main {<br>
        &emsp;public static void main(String args[]) {<br>
        &emsp;&emsp;<mark>// Although we don't have an object of Test, static block is</mark><br>
        &emsp;&emsp;<mark>// called because i is being accessed in the following statement.</mark><br>
        &emsp;&emsp;System.out.println(Test.i);<br>
        &emsp;}<br>
        }
    </div>
    <p>Example of static blocks being called before constructors:</p>
    <div class="code">
        class Test {<br>
        &emsp;static int i;<br>
        &emsp;static {<br>
        &emsp;&emsp;i = 10;<br>
        &emsp;&emsp;System.out.println("static block called ");<br>
        &emsp;}<br><br>
        &emsp;Test(){<br>
        &emsp;&emsp;System.out.println("Constructor called");<br>
        &emsp;}<br>
        }<br><br>
        class Main {<br>
        &emsp;public static void main(String args[]) {<br>
        &emsp;<mark>// Although we have two objects, static block is executed only once.</mark><br>
        &emsp;Test t1 = new Test();<br>
        &emsp;Test t2 = new Test();<br>
        &emsp;}<br>
        }
    </div>
    <h3>Java Class Methods</h3>
    <div class="code">
        public class MyClass {<br>
        &emsp;<mark>// Static method</mark><br>
        &emsp;static void myStaticMethod() {<br>
        &emsp;&emsp;System.out.println("Static methods can be called without creating objects");<br>
        &emsp;}<br><br>
        &emsp;<mark>// Public method</mark><br>
        &emsp;public void myPublicMethod() {<br>
        &emsp;&emsp;System.out.println("Public methods must be called by creating objects");<br>
        &emsp;}<br><br>
        &emsp;<mark>// Main method</mark><br>
        &emsp;public static void main(String[] args) {<br>
        &emsp;&emsp;myStaticMethod(); <mark>// Call the static method</mark><br>
        &emsp;&emsp;<mark>// myPublicMethod(); This would compile an error</mark><br><br>
        &emsp;&emsp;MyClass myObj = new MyClass(); <mark>// Create an object of MyClass</mark><br>
        &emsp;&emsp;myObj.myPublicMethod(); <mark>// Call the public method on the object</mark><br>
        &emsp;}<br>
        }
    </div>
    <p>The dot (.) is used to access the object's attributes and methods.</p>
    <p>To call a method in Java, write the method name followed by a set of parentheses (), followed by a semicolon (;).</p>
    <p>A class must have a matching filename (MyClass and MyClass.java).</p>
    <h3>Using Multiple Classes</h3>
    <div class="code">
        public class Car {<br>
        &emsp;public void fullThrottle() {<br>
        &emsp;&emsp;System.out.println("The car is going as fast as it can!");<br>
        &emsp;}<br><br>
        &emsp;public void speed(int maxSpeed) {<br>
        &emsp;&emsp;System.out.println("Max speed is: " + maxSpeed);<br>
        &emsp;}<br>
        }
    </div>
    <div class="code">
        class OtherClass {<br>
        &emsp;public static void main(String[] args) {<br>
        &emsp;&emsp;Car myCar = new Car();  <mark>// Create a myCar object</mark><br>
        &emsp;&emsp;myCar.fullThrottle();  &emsp;&emsp;<mark>// Call the fullThrottle() method</mark><br>
        &emsp;&emsp;myCar.speed(200);        &emsp;&emsp;<mark>// Call the speed() method</mark><br>
        &emsp;}<br>
        }
    </div>
    <p>Output:</p>
    <div class="code">
        The car is going as fast as it can!<br>
        Max speed is: 200
    </div>
</div>
&nbsp;
<button class="collapsible">Constructors</button>
<div class="content">
<h2>Constructors</h2>
    <p>In Java, constructor refers to a block of code which is used to initialize an object. It must have the same name as that of the class. Also, it has no return type and it is automatically called when an object is created.</p>
    <p>There are two types of constructors:</p>
    <ol>
        <li><b>Default Constructor:</b> In Java, a default constructor is the one which does not take any inputs. In other words, default constructors are the no argument constructors which will be created by default in case you no other constructor is defined by the user. Its main purpose is to initialize the instance variables with the default values. Also, it is majorly used for object creation.</li>
        <li><b>Parameterized Constructor:</b> The parameterized constructor in Java, is the constructor which is capable of initializing the instance variables with the provided values. In other words, the constructors which take the arguments are called parameterized constructors.</li>
    </ol>
    <h3>What is constructor overloading in Java?</h3>
    <p>In Java, constructor overloading is a technique of adding any number of constructors to a class each having a different parameter list. The compiler uses the number of parameters and their types in the list to differentiate the overloaded constructors.</p>
    <div class="code">
        <mark>// Create a class</mark><br>
        public class MyClass {<br>
        &emsp;int x; <mark>// Create a class attribute</mark><br><br>
        &emsp;<mark>// Create a class constructor for MyClass</mark><br>
        &emsp;public MyClass() {<br>
        &emsp;&emsp;x = 5; <mark>// Set the initial value for the class attribute x</mark><br>
        &emsp;}<br><br>
        &emsp;<mark>// Parameterized Constructor</mark><br>
        &emsp;public MyClass(int y) {<br>
        &emsp;&emsp;x = y;<br>
        &emsp;}<br><br>
        &emsp;public static void main(String[] args) {<br>
        &emsp;&emsp;<mark>// Create an object of class MyClass (This will call the constructor)</mark><br>
        &emsp;&emsp;MyClass myObj1 = new MyClass();<br><br>
        &emsp;&emsp;<mark>// Create an object of class MyClass (This will call the parameterized constructor)</mark><br>
        &emsp;&emsp;MyClass myObj2 = new MyClass(5);<br><br>
        &emsp;&emsp;<mark>// Print the value of x</mark><br>
        &emsp;&emsp;System.out.println(myObj1.x);<br>
        &emsp;&emsp;System.out.println(myObj2.x);<br>
        &emsp;}<br>
        }
    </div>
    <p>Output:</p>
    <div class="code">
        5<br>
        5
    </div>
    <h3>Private Constructors</h3>
    <p>If a constructor is made private, then it can only be accessed inside the class.</p>
    <p>There are various scenarios where we can use private constructors. The major ones are</p>
    <ol>
        <li>Internal Constructor chaining</li>
        <li>Singleton class design pattern</li>
    </ol>
    <h3>Copy Constructor</h3>
    <p>Copy Constructor in java class is a special type of constructor that takes the same class as an argument. Copy constructor is used to provide a copy of the specified object.</p>
    <p>Copy constructor is an easy alternative to java cloning mechanism.</p>
    <p>Copy constructor is helpful when we want to copy an object that is heavy to instantiate.</p>
    <div class="code">
        <mark>// Create a class</mark><br>
        public class MyClass {<br>
        &emsp;int x; <mark>// Create a class attribute</mark><br><br>
        &emsp;<mark>// Create a class constructor for MyClass</mark><br>
        &emsp;public MyClass() {<br>
        &emsp;&emsp;x = 5; <mark>// Set the initial value for the class attribute x</mark><br>
        &emsp;}<br><br>
        &emsp;<mark>// Parameterized Constructor</mark><br>
        &emsp;public MyClass(int y) {<br>
        &emsp;&emsp;x = y;<br>
        &emsp;}<br><br>
        &emsp;<mark>// Copy Constructor</mark><br>
        &emsp;public MyClass(MyClass m) {<br>
        &emsp;&emsp;x = m.x<br>
        &emsp;}<br><br>
        &emsp;public static void main(String[] args) {<br>
        &emsp;&emsp;<mark>// Create an object of class MyClass (This will call the constructor)</mark><br>
        &emsp;&emsp;MyClass myObj1 = new MyClass();<br><br>
        &emsp;&emsp;<mark>// Create an object of class MyClass (This will call the parameterized constructor)</mark><br>
        &emsp;&emsp;MyClass myObj2 = new MyClass(5);<br><br>
        &emsp;&emsp;<mark>// Create an object of class MyClass (This will use the copy constructor)</mark><br>
        &emsp;&emsp;MyClass myObj3 = new MyClass(myObj2);<br><br>
        &emsp;&emsp;<mark>// Print the value of x</mark><br>
        &emsp;&emsp;System.out.println(myObj1.x);<br>
        &emsp;&emsp;System.out.println(myObj2.x);<br>
        &emsp;&emsp;System.out.println(myObj3.x);<br>
        &emsp;}<br>
        }
    </div>
    <p>Output:</p>
    <div class="code">
        5<br>
        5<br>
        5
    </div>
    <h3>Constructor Chaining</h3>
    <p>Constructor chaining can be done in two ways:</p>
    <ul>
        <li>Within same class: It can be done using this() keyword for constructors in same class</li>
        <li>From base class: by using super() keyword to call constructor from the base class.</li>
    </ul>
    <p>Rules of constructor chaining:</p>
    <ol>
        <li>The this() expression should always be the first line of the constructor.</li>
        <li>There should be at-least be one constructor without the this() keyword (constructor 3 in above example).</li>
        <li>Constructor chaining can be achieved in any order.</li>
    </ol>
    <h3>Constructor Chaining using this() Keyword</h3>
    <div class="code">
        class Temp {<br>
        &emsp;<mark>// default constructor 1</mark><br>
        &emsp;<mark>// default constructor will call another constructor</mark><br>
        &emsp;<mark>// using this keyword from same class</mark><br><br>
        &emsp;Temp() {<br>
        &emsp;&emsp;<mark>// calls constructor 2</mark><br>
        &emsp;&emsp;this(5);<br>
        &emsp;&emsp;System.out.println("The Default constructor");<br>
        &emsp;}<br><br>
        &emsp;<mark>// parameterized constructor 2</mark><br>
        &emsp;Temp(int x) {<br>
        &emsp;&emsp;<mark>// calls constructor 3</mark><br>
        &emsp;&emsp;this(5, 15);<br>
        &emsp;&emsp;System.out.println(x);<br>
        &emsp;}<br><br>
        &emsp;<mark>// parameterized constructor 3</mark><br>
        &emsp;Temp(int x, int y) {<br>
        &emsp;&emsp;System.out.println(x * y);<br>
        &emsp;}<br><br>
        &emsp;public static void main(String args[]) {<br>
        &emsp;&emsp;<mark>// invokes default constructor first</mark><br>
        &emsp;&emsp;new Temp();<br>
        &emsp;}<br>
        }
    </div>
    <p>Output:</p>
    <div class="code">
        default<br>
        5<br>
        80
    </div>
    <h3>Constructor Chaining using super() keyword</h3>
    <div class="code">
        class Base {<br>
        &emsp;String name;<br><br>
        &emsp;<mark>// constructor 1</mark><br>
        &emsp;Base() {<br>
        &emsp;&emsp;this("");<br>
        &emsp;&emsp;System.out.println("No-argument constructor of" + " base class");<br>
        &emsp;}<br><br>
        &emsp;<mark>// constructor 2</mark><br>
        &emsp;Base(String name) {<br>
        &emsp;&emsp;this.name = name;<br>
        &emsp;&emsp;System.out.println("Calling parameterized constructor" + " of base");<br>
        &emsp;}<br>
        }<br><br>
        class Derived extends Base {<br>
        &emsp;<mark>// constructor 3</mark><br>
        &emsp;Derived() {<br>
        &emsp;&emsp;System.out.println("No-argument constructor " + "of derived");<br>
        &emsp;}<br><br>
        &emsp;<mark>// parameterized constructor 4</mark><br>
        &emsp;Derived(String name) {<br>
        &emsp;&emsp;<mark>// invokes base class constructor 2</mark><br>
        &emsp;&emsp;super(name);<br>
        &emsp;&emsp;System.out.println("Calling parameterized " + "constructor of derived");<br>
        &emsp;}<br><br>
        &emsp;public static void main(String args[]) {<br>
        &emsp;&emsp;<mark>// calls parameterized constructor 4</mark><br>
        &emsp;&emsp;Derived obj = new Derived("test");<br><br>
        &emsp;&emsp;<mark>// Calls No-argument constructor</mark><br>
        &emsp;&emsp;<mark>// Derived obj = new Derived();</mark><br>
        &emsp;}<br>
        }
    </div>
    <p>Output:</p>
    <div class="code">
        Calling parameterized constructor of base<br>
        Calling parameterized constructor of derived
    </div>
    <h3>Init Block</h3>
    <p>When we want certain common resources to be executed with every constructor we can put the code in the init block. Init block is always executed before any constructor, whenever a constructor is used for creating a new object.</p>
    <div class="code">
        class Temp {<br>
        &emsp;<mark>// block to be executed before any constructor.</mark><br>
        &emsp;{<br>
        &emsp;&emsp;System.out.println("init block");<br>
        &emsp;}<br><br>
        &emsp;<mark>// no-arg constructor</mark><br>
        &emsp;Temp() {<br>
        &emsp;&emsp;System.out.println("default");<br>
        &emsp;}<br><br>
        &emsp;<mark>// constructor with one argument.</mark><br>
        &emsp;Temp(int x) {<br>
        &emsp;&emsp;System.out.println(x);<br>
        &emsp;}<br><br>
        &emsp;public static void main(String args[]) {<br>
        &emsp;&emsp;<mark>// Object creation by calling no-argument constructor.</mark><br>
        &emsp;&emsp;new Temp();<br><br>
        &emsp;&emsp;<mark>// Object creation by calling parameterized constructor with one parameter.</mark><br>
        &emsp;&emsp;new Temp(10);<br>
        &emsp;}<br>
        }
    </div>
    <p>Output:</p>
    <div class="code">
        init block<br>
        default<br>
        init block<br>
        10
    </div>
    <h3>Why Constructors are not inherited in Java</h3>
    <p>Constructors are special and have same name as class name. So if constructors were inherited in child class then child class would contain a parent class constructor which is against the constraint that constructor should have same name as class name.</p>
    <div class="code">
        class Parent {<br>
        &emsp;public Parent() {<br>
        &emsp;}<br><br>
        &emsp;public void print() {<br>
        &emsp;}<br>
        }<br><br>
        public class Child extends Parent {<br>
        &emsp;public Parent() {<br>
        &emsp;}<br><br>
        &emsp;public void print() {<br>
        &emsp;}<br><br>
        &emsp;public static void main(String[] args) {<br>
        &emsp;&emsp;Child c1 = new Child(); <mark>// allowed</mark><br>
        &emsp;&emsp;Child c2 = new Parent(); <mark>// not allowed</mark><br>
        &emsp;}<br>
        }
    </div>
    <h3>Inheritance and Constructors</h3>
    <p>In Java, constructor of base class with no argument gets automatically called in derived class constructor.</p>
    <p>But, if we want to call parameterized contructor of base class, then we can call it using super(). The point to note is base class constructor call must be the first line in derived class constructor.</p>
    <div class="code">
        class Base {<br>
        &emsp;int x;<br><br>
        &emsp;Base(int x) {<br>
        &emsp;&emsp;this.x = x;<br>
        &emsp;}<br>
        }<br><br>
        class Derived extends Base {<br>
        &emsp;int y;<br><br>
        &emsp;Derived(int x, int y) {<br>
        &emsp;&emsp;super(x);<br>
        &emsp;&emsp;this.y = y;<br>
        &emsp;}<br><br>
        &emsp;void Display() {<br>
        &emsp;&emsp;System.out.println("x = " + x + ", y = " + y);<br>
        &emsp;}<br>
        }<br><br>
        public class Main {<br>
        &emsp;public static void main(String[] args) {<br>
        &emsp;&emsp;Derived d = new Derived(10, 20);<br>
        &emsp;&emsp;d.Display();<br>
        &emsp;}<br>
        }
    </div>
    <p>Output:</p>
    <div class="code">
        x = 10, y = 20
    </div>
</div>
&nbsp;
<button class="collapsible">Keywords</button>
<div class="content">
    <p>Java has a set of keywords that are reserved words that cannot be used as variables, methods, classes, or any other identifiers:</p>
    <button class="collapsible">A - C</button>
    <div class="content">
    <table>
        <tr>
            <th>Keyword</th>
            <th>Description</th>
        </tr>
        <tr>
            <th>abstract</th>
            <td>A non-access modifier. Used for classes and methods: An abstract class cannot be used to create objects (to access it, it must be inherited from another class). An abstract method can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from)</td>
        </tr>
        <tr>
            <th>assert</th>
            <td>For debugging</td>
        </tr>
        <tr>
            <th>boolean</th>
            <td>A data type that can only store true and false values</td>
        </tr>
        <tr>
            <th>break</th>
            <td>Breaks out of a loop or a switch block</td>
        </tr>
        <tr>
            <th>byte</th>
            <td>A data type that can store whole numbers from -128 and 127</td>
        </tr>
        <tr>
            <th>case</th>
            <td>Marks a block of code in switch statements</td>
        </tr>
        <tr>
            <th>catch</th>
            <td>Catches exceptions generated by try statements</td>
        </tr>
        <tr>
            <th>char</th>
            <td>A data type that is used to store a single character</td>
        </tr>
        <tr>
            <th>class</th>
            <td>Defines a class</td>
        </tr>
        <tr>
            <th>continue</th>
            <td>Continues to the next iteration of a loop</td>
        </tr>
        <tr>
            <th>const</th>
            <td>Defines a constant. (use final instead)</td>
        </tr>
    </table>
    </div>
    &nbsp;
    <button class="collapsible">D - F</button>
    <div class="content">
    <table>
        <tr>
            <th>Keyword</th>
            <th>Description</th>
        </tr>
        <tr>
            <th>default</th>
            <td>Specifies the default block of code in a switch statement</td>
        </tr>
        <tr>
            <th>do</th>
            <td>Used together with while to create a do-while loop</td>
        </tr>
        <tr>
            <th>double</th>
            <td>A data type that can store whole numbers from 1.7e−308 to 1.7e+038</td>
        </tr>
        <tr>
            <th>else</th>
            <td>Used in conditional statements</td>
        </tr>
        <tr>
            <th>enum</th>
            <td>Declares an enumerated (unchangeable) type</td>
        </tr>
        <tr>
            <th>exports</th>
            <td>Exports a package with a module. New in Java 9</td>
        </tr>
        <tr>
            <th>extends</th>
            <td>Extends a class (indicates that a class is inherited from another class)</td>
        </tr>
        <tr>
            <th rowspan="5">final</th>
            <td>A non-access modifier used for classes, attributes and methods, which makes them non-changeable (impossible to inherit or override)</td>
        </tr>
        <tr>
            <td>Declaring a field as final prevents its contents from being modified after it has been initialized.</td>
        </tr>
        <tr>
            <td>Its value can also be assigned within a constructor.</td>
        </tr>
        <tr>
            <td>Making a class final means you cannot make sub-classes to it (extend it).</td>
        </tr>
        <tr>
            <td>Making a method final means that sub-classes cannot override that method.</td>
        </tr>
        <tr>
            <th>finally</th>
            <td>Used with exceptions, a block of code that will be executed no matter if there is an exception or not</td>
        </tr>
        <tr>
            <th>float</th>
            <td>A data type that can store whole numbers from 3.4e−038 to 3.4e+038</td>
        </tr>
        <tr>
            <th>for</th>
            <td>Create a for loop</td>
        </tr>
    </table>
    </div>
    &nbsp;
    <button class="collapsible">G - P</button>
    <div class="content">
    <table>
        <tr>
            <th>Keyword</th>
            <th>Description</th>
        </tr>
        <tr>
            <th>goto</th>
            <td>Not in use, and has no function</td>
        </tr>
        <tr>
            <th>if</th>
            <td>Makes a conditional statement</td>
        </tr>
        <tr>
            <th>implements</th>
            <td>Implements an interface</td>
        </tr>
        <tr>
            <th rowspan="2">import</th>
            <td>Used to import a package, class or interface.</td>
        </tr>
        <tr>
            <td>General Form: import pkg1.[pkg2].(classname|*);</td>
        </tr>
        <tr>
            <th>instanceof</th>
            <td>Checks whether an object is an instance of a specific class or an interface</td>
        </tr>
        <tr>
            <th>int</th>
            <td>A data type that can store whole numbers from -2147483648 to 2147483647</td>
        </tr>
        <tr>
            <th rowspan="2">interface</th>
            <td>Used to declare a special type of class that only contains abstract methods</td>
        </tr>
        <tr>
            <td>Can be used to fully abstract a class' interface from its implementation.</td>
        </tr>
        <tr>
            <th>long</th>
            <td>A data type that can store whole numbers from -9223372036854775808 to 9223372036854775808</td>
        </tr>
        <tr>
            <th>module</th>
            <td>Declares a module. New in Java 9</td>
        </tr>
        <tr>
            <th>native</th>
            <td>Specifies that a method is not implemented in the same Java source file (but in another language)</td>
        </tr>
        <tr>
            <th>new</th>
            <td>Creates new objects</td>
        </tr>
        <tr>
            <th>package</th>
            <td>Declares a package</td>
        </tr>
        <tr>
            <th>private</th>
            <td>An access modifier used for attributes, methods and constructors, making them only accessible within the declared class</td>
        </tr>
        <tr>
            <th>protected</th>
            <td>An access modifier used for attributes, methods and constructors, making them accessible in the same package and subclasses</td>
        </tr>
        <tr>
            <th>public</th>
            <td>An access modifier used for classes, attributes, methods and constructors, making them accessible by any other class</td>
        </tr>
    </table>
    </div>
    &nbsp;
    <button class="collapsible">Q - T</button>
    <div class="content">
        <table>
            <tr>
                <th>Keyword</th>
                <th>Description</th>
            </tr>
            <tr>
                <th>requires</th>
                <td>Specifies required libraries inside a module. New in Java 9</td>
            </tr>
            <tr>
                <th>return</th>
                <td>Finished the execution of a method, and can be used to return a value from a method</td>
            </tr>
            <tr>
                <th>short</th>
                <td>A data type that can store whole numbers from -32768 to 32767</td>
            </tr>
            <tr>
                <th rowspan="2">static</th>
                <td>Allows a method to be called without having to instantiate a particular instance of the class.</td>
            </tr>
            <tr>
                <td>Necessary for main() which is called by the Java Virtual Machine before any objects are made.</td>
            </tr>
            <tr>
                <th>strictfp</th>
                <td>Restrict the precision and rounding of floating point calculations</td>
            </tr>
            <tr>
                <th>super</th>
                <td>Refers to superclass (parent) objects</td>
            </tr>
            <tr>
                <th>switch</th>
                <td>Selects one of many code blocks to be executed</td>
            </tr>
            <tr>
                <th>synchronized</th>
                <td>A non-access modifier, which specifies that methods can only be accessed by one thread at a time</td>
            </tr>
            <tr>
                <th>this</th>
                <td>Refers to the current object in a method or constructor</td>
            </tr>
            <tr>
                <th>throw</th>
                <td>Creates a custom error</td>
            </tr>
            <tr>
                <th>throws</th>
                <td>Indicates what exceptions may be thrown by a method</td>
            </tr>
            <tr>
                <th>transient</th>
                <td>A non-access modifier, which specifies that an attribute is not part of an object's persistent state</td>
            </tr>
            <tr>
                <th>try</th>
                <td>Creates a try...catch statement</td>
            </tr>
        </table>
    </div>
    &nbsp;
    <button class="collapsible">U - Z</button>
    <div class="content">
        <table>
            <tr>
                <th>Keyword</th>
                <th>Description</th>
            </tr>
            <tr>
                <th>var</th>
                <td>Declares a variable. New in Java 10</td>
            </tr>
            <tr>
                <th>void</th>
                <td>Tells the compiler that the method does not return a value.</td>
            </tr>
            <tr>
                <th>volatile</th>
                <td>Indicates that an attribute is not cached thread-locally, and is always read from the "main memory"</td>
            </tr>
            <tr>
                <th>while</th>
                <td>Creates a while loop</td>
            </tr>
        </table>
    </div>
    <p>true, false, and null are not keywords, but they are literals and reserved words that cannot be used as identifiers.</p>
    </div>
</div>
&nbsp;
<button class="collapsible">Classes</button>
<div class="content">
    <h2>Classes</h2>
    <ul>
        <li>A template for an object, also known as a "blueprint"</li>
        <li>Everything in Java is associated with classes and objects, along with its attributes and methods. For example: in real life, a car is an object. The car has attributes, such as weight and color, and methods, such as drive and brake.</li>
    </ul>
    <p>General form:</p>
    <div class="code">class className { <br>&emsp; type instance-variable1; <br> }</div>
    <h3>Create a Class</h3>
    <p>To create a class, use the keyword class.</p>
    <h3>Create an Object</h3>
    <p>In Java, an object is created from a class. To create an object, specify the class name, followed by the object name and use the keyword new.</p>
    <div class="code">
        public class MyClass {<br>
        &emsp;int x = 5;<br><br>
        &emsp;public static void main(String[] args) {<br>
        &emsp;&emsp;MyClass myObj = new MyClass();<br>
        &emsp;&emsp;System.out.println(myObj.x);<br>
        &emsp;}<br>
        }
    </div>
    <h3>Using Multiple Classes</h3>
    <p>You can also create an object of a class and access it in another class. This is often used for better organization of classes (one class has all the attributes and methods, while the other class holds the main() method (code to be executed)).</p>
    <p>Remember that the name of the java file should match the class name.</p>
    <div class="code">
        public class MyClass {<br>
        &emsp;int x = 5;<br>
        }
    </div>
    <div class="code">
        class OtherClass {<br>
        &emsp;public static void main(String[] args) {<br>
        &emsp;&emsp;MyClass myObj = new MyClass();<br>
        &emsp;&emsp;System.out.println(myObj.x);<br>
        &emsp;}<br>
        }
    </div>
    <p>Members: "The methods and variables defined within a class"</p>
    <h3>Class Attributes</h3>
    <p>Class attributes are variables within a class</p>
    <h3>Accessing Attributes</h3>
    <p>You can access attributes by creating an object of the class, and by using the dot syntax (.)</p>
    <div class="code">
        public class MyClass {<br>
        &emsp;int x = 5;<br><br>
        &emsp;public static void main(String[] args) {<br>
        &emsp;&emsp;MyClass myObj = new MyClass();<br>
        &emsp;&emsp;System.out.println(myObj.x);<br>
        &emsp;}<br>
        }
    </div>
    <h3>Modify Attributes</h3>
    <p>You can also modify or override existing attribute values.</p>
    <p>If you don't want the ability to override existing values, declare the attribute as final</p>
    <ul>
        <li>The final keyword is useful when you want a variable to always store the same value, like PI (3.14159...).</li>
        <li>The final keyword is called a "modifier".</li>
    </ul>
    <h3>Multiple Objects</h3>
    <p>If you create multiple objects of one class, you can change the attribute values in one object, without affecting the attribute values in the other.</p>
    <h3>Multiple Attributes</h3>
    <p>You can specify as many attributes as you want.</p>
    <h3>Final Class</h3>
    <p>Making a class final means that class can't be extended.</p>
    <h3>Abstract Class</h3>
    <p>A class where we won't have a full implementations (not a blueprint).</p>
    <p>A restricted class that cannot be used to create objects (to access it, it must be inherited from another class).</p>
    <h3>Concrete Class</h3>
    <p>Will have a full implementation (a blueprint).</p>
    <h3>Implementation</h3>
    <p>Methods defined and implemented (have a body).</p>
    <h3>Singleton Class</h3>
    <ul>
        <li>As the name implies, a class is said to be singleton if it limits the number of objects of that class to one.</li>
        <li>We can’t have more than a single object for such classes.</li>
        <li>Singleton classes are employed extensively in concepts like Networking and Database Connectivity.</li>
    </ul>
    <h3>Java Class Methods</h3>
    <div class="code">
        public class MyClass {<br>
        &emsp;<mark>// Static method</mark><br>
        &emsp;static void myStaticMethod() {<br>
        &emsp;&emsp;System.out.println("Static methods can be called without creating objects");<br>
        &emsp;}<br><br>
        &emsp;<mark>// Public method</mark><br>
        &emsp;public void myPublicMethod() {<br>
        &emsp;&emsp;System.out.println("Public methods must be called by creating objects");<br>
        &emsp;}<br><br>
        &emsp;<mark>// Main method</mark><br>
        &emsp;public static void main(String[] args) {<br>
        &emsp;&emsp;myStaticMethod(); <mark>// Call the static method</mark><br>
        &emsp;&emsp;<mark>// myPublicMethod(); This would compile an error</mark><br><br>
        &emsp;&emsp;MyClass myObj = new MyClass(); <mark>// Create an object of MyClass</mark><br>
        &emsp;&emsp;myObj.myPublicMethod(); <mark>// Call the public method on the object</mark><br>
        &emsp;}<br>
        }
    </div>
    <p>The dot (.) is used to access the object's attributes and methods.</p>
    <p>To call a method in Java, write the method name followed by a set of parentheses (), followed by a semicolon (;).</p>
    <p>A class must have a matching filename (MyClass and MyClass.java).</p>
    <h3>Using Multiple Classes</h3>
    <div class="code">
        public class Car {<br>
        &emsp;public void fullThrottle() {<br>
        &emsp;&emsp;System.out.println("The car is going as fast as it can!");<br>
        &emsp;}<br><br>
        &emsp;public void speed(int maxSpeed) {<br>
        &emsp;&emsp;System.out.println("Max speed is: " + maxSpeed);<br>
        &emsp;}<br>
        }
    </div>
    <div class="code">
        class OtherClass {<br>
        &emsp;public static void main(String[] args) {<br>
        &emsp;&emsp;Car myCar = new Car();  <mark>// Create a myCar object</mark><br>
        &emsp;&emsp;myCar.fullThrottle();  &emsp;&emsp;<mark>// Call the fullThrottle() method</mark><br>
        &emsp;&emsp;myCar.speed(200);        &emsp;&emsp;<mark>// Call the speed() method</mark><br>
        &emsp;}<br>
        }
    </div>
    <p>Output:</p>
    <div class="code">
        The car is going as fast as it can!<br>
        Max speed is: 200
    </div>
    <h3>Java Inner Classes</h3>
    <p>In Java, it is also possible to nest classes (a class within a class). The purpose of nested classes is to group classes that belong together, which makes your code more readable and maintainable.</p>
    <p>To access the inner class, create an object of the outer class, and then create an object of the inner class</p>
    <div class="code">
        class OuterClass {<br>
        &emsp;int x = 10;<br><br>
        &emsp;class InnerClass {<br>
        &emsp;&emsp;int y = 5;<br>
        &emsp;}<br>
        }<br><br>
        public class MyMainClass {<br>
        &emsp;public static void main(String[] args) {<br>
        &emsp;&emsp;OuterClass myOuter = new OuterClass();<br>
        &emsp;&emsp;OuterClass.InnerClass myInner = myOuter.new InnerClass();<br>
        &emsp;&emsp;System.out.println(myInner.y + myOuter.x);<br>
        &emsp;}<br>
        }
    </div>
    <h3>Private Inner Class</h3>
    <p>Unlike a "regular" class, an inner class can be private or protected. If you don't want outside objects to access the inner class, declare the class as private</p>
    <h3>Static Inner Class</h3>
    <p>An inner class can also be static, which means that you can access it without creating an object of the outer class.</p>
    <p>Just like static attributes and methods, a static inner class does not have access to members of the outer class.</p>
    <h3>Access Outer Class From Inner Class</h3>
    <p>One advantage of inner classes, is that they can access attributes and methods of the outer class.</p>
</div>
&nbsp;
<button class="collapsible">Interfaces</button>
<div class="content">
    <h3>Interfaces</h3>
    <p>An interface is a completely "abstract class" that is used to group related methods with empty bodies.</p>
    <ul>
        <li>Using Interfaces you can specify what a class must do, but not how it does it.</li>
        <li>A class implements an interface, thereby inheriting the abstract methods of the interface.</li>
        <li>Along with abstract methods, an interface may also contain constants, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods.</li>
        <li>Unless the class that implements the interface is abstract, all the methods of the interface need to be defined in the class.</li>
        <li>An interface is implicitly abstract. You do not need to use the abstract keyword while declaring an interface.</li>
        <li>Each method in an interface is also implicitly abstract, so the abstract keyword is not needed.</li>
        <li>Methods in an interface are implicitly public.</li>
    </ul>
    <h3>Similarities with a Class</h3>
    <ul>
        <li>An interface can contain any number of methods.</li>
        <li>An interface is written in a file with a .java extension, with the name of the interface matching the name of the file.</li>
        <li>The byte code of an interface appears in a .class file.</li>
        <li>Interfaces appear in packages, and their corresponding bytecode file must be in a directory structure that matches the package name.</li>
    </ul>
    <h3>Differences from a Class</h3>
    <ul>
        <li>You cannot instantiate an interface.</li>
        <li>An interface does not contain any constructors.</li>
        <li>All of the methods in an interface are abstract.</li>
        <li>An interface cannot contain instance fields. The only fields that can appear in an interface must be declared both static and final.</li>
        <li>An interface is not extended by a class; it is implemented by a class.</li>
        <li>An interface can extend multiple interfaces.</li>
    </ul>
    <h3>Declaring Interfaces</h3>
    <p>The interface keyword is used to declare an interface.</p>
    <p><b>Naming Convention for Interfaces:</b> Start with a capital "I" followed by the name of the interface "Player".</p>
    <div class="code">interface IPlayer { <br>&emsp; final int id = 10; <br>&emsp; int move(); <br> }</div>
    <div class="code">
        public interface NameOfInterface {<br>
        <mark>// Any number of final, static fields</mark><br>
        <mark>// Any number of abstract method declarations</mark><br>
        }
    </div>
    <p>To access the interface methods, the interface must be "implemented" by another class with the implements keyword (instead of extends).</p>
    <p>The body of the interface is provided by the implementing class</p>
    <p>A class uses the implements keyword to implement an interface. The implements keyword appears in the class declaration following the extends portion of the declaration.</p>
    <div class="code">
        <mark>// Interface</mark><br>
        interface IAnimal {<br>
        &emsp;public void animalSound(); <mark>// interface method (does not have a body)</mark><br>
        &emsp;public void sleep(); <mark>// interface method (does not have a body)</mark><br>
        }<br><br>
        <mark>// Pig "implements" the Animal interface</mark><br>
        class Pig implements IAnimal {<br>
        &emsp;public void animalSound() {<br>
        &emsp;&emsp;<mark>// The body of animalSound() is provided here</mark><br>
        &emsp;&emsp;System.out.println("The pig says: wee wee");<br>
        &emsp;}<br><br>
        &emsp;public void sleep() {<br>
        &emsp;&emsp;<mark>// The body of sleep() is provided here</mark><br>
        &emsp;&emsp;System.out.println("Zzz");<br>
        &emsp;}<br>
        }
    </div>
    <h3>Overriding Interface Methods</h3>
    <ul>
        <li>Checked exceptions should not be declared on implementation methods other than the ones declared by the interface method or subclasses of those declared by the interface method.</li>
        <li>The signature of the interface method and the same return type or subtype should be maintained when overriding the methods.</li>
        <li>An implementation class itself can be abstract and if so, interface methods need not be implemented.</li>
    </ul>
    <h3>Implementing Interfaces</h3>
    <ul>
        <li>A class can implement more than one interface at a time.</li>
        <li>A class can extend only one class, but implement many interfaces.</li>
        <li>An interface can extend another interface, in a similar way as a class can extend another class.</li>
    </ul>
    <h3>Extending Interfaces</h3>
    <p>An interface can extend another interface in the same way that a class can extend another class. The extends keyword is used to extend an interface, and the child interface inherits the methods of the parent interface.</p>
    <h3>Extending Multiple Interfaces</h3>
    <p>A Java class can only extend one parent class. Multiple inheritance is not allowed. Interfaces are not classes, however, and an interface can extend more than one parent interface.</p>
    <p>The extends keyword is used once, and the parent interfaces are declared in a comma-separated list.</p>
    <h3>Notes on Interfaces:</h3>
    <ul>
        <li>Like abstract classes, interfaces cannot be used to create objects (in the example above, it is not possible to create an "Animal" object in the MyMainClass)</li>
        <li>Interface methods do not have a body - the body is provided by the "implements" class</li>
        <li>On implementation of an interface, you must override all of its methods</li>
        <li>Interface methods are by default abstract and public</li>
        <li>Interface attributes are by default public, static and final</li>
        <li>An interface cannot contain a constructor (as it cannot be used to create objects)</li>
    </ul>
    <h3>Why and when to use Interfaces</h3>
    <ol>
        <li>To achieve security - hide certain details and only show the important details of an object (interface).</li>
        <li>Java does not support "multiple inheritance" (a class can only inherit from one superclass). However, it can be achieved with interfaces, because the class can implement multiple interfaces. Note: To implement multiple interfaces, separate them with a comma.</li>
    </ol>
    <div class="code">
        class DemoClass implements FirstInterface, SecondInterface {
    </div>
    <h3>Functional Interfaces</h3>
    <p>A functional interface is an interface that specifies only one abstract method.</p>
    <p>An interface method is abstract only if it does not specify a default implementation.</p>
    <p>Using Default Methods however, it is possible to specify the behaviour for a method declared in an interface.</p>
    <p>Non-default interface methods are implicitly abstract, so there is no need to use the abstract modifier (although you can specify it, if you like).</p>
    <div class="code">
        &emsp;interface INumber { <br>
        &emsp;&emsp;double getValue();<br>
        &emsp;}
    </div>
    <h3>Marker Interface</h3>
    <p>It is an empty interface (no field or methods). Examples of marker interface are Serializable, Clonnable and Remote interface. All these interfaces are empty interfaces.</p>
</div>
&nbsp;
<button class="collapsible">Abstract Class Vs Interface</button>
<div class="content">
    <p><b>Abstract class:</b> A class where we won't have a full implementations (not a blueprint).</p>
    <p><b>Interface:</b> Using Interfaces you can specify what a class must do, but not how it does it.</p>
    <h2>Major Difference</h2>
    <p>Abstract Classes can have partial implementations.</p>
    <ol>
        <li>Type of methods: Interface can have only abstract methods. Abstract class can have abstract and non-abstract methods. From Java 8, it can have default and static methods also.</li>
        <li>Final Variables: Variables declared in a Java interface are by default final. An abstract class may contain non-final variables.</li>
        <li>Type of variables: Abstract class can have final, non-final, static and non-static variables. Interface has only static and final variables.</li>
        <li>Implementation: Abstract class can provide the implementation of interface. Interface can’t provide the implementation of abstract class.</li>
        <li>Inheritance vs Abstraction: A Java interface can be implemented using keyword “implements” and abstract class can be extended using keyword “extends”.</li>
        <li>Multiple implementation: An interface can extend another Java interface only, an abstract class can extend another Java class and implement multiple Java interfaces.</li>
        <li>Accessibility of Data Members: Members of a Java interface are public by default. A Java abstract class can have class members like private, protected, etc.</li>
    </ol>
    <h2>Consider using abstract classes if any of these statements apply to your situation:</h2>
    <ul>
        <li>In java application, there are some related classes that need to share some lines of code then you can put these lines of code within abstract class and this abstract class should be extended by all these related classes.</li>
        <li>You can define non-static or non-final field(s) in abstract class, so that via a method you can access and modify the state of Object to which they belong.</li>
        <li>You can expect that the classes that extend an abstract class have many common methods or fields, or require access modifiers other than public (such as protected and private).</li>
    </ul>
    <h2>Consider using interfaces if any of these statements apply to your situation:</h2>
    <ul>
        <li>It is total abstraction, All methods declared within an interface must be implemented by the class(es) that implements this interface.</li>
        <li>A class can implement more than one interface. It is called multiple inheritance.</li>
        <li>You want to specify the behavior of a particular data type, but not concerned about who implements its behavior.</li>
    </ul>
</div>
&nbsp;
<button class="collapsible">Exception Handling</button>
<div class="content">
    <h2>Exception Handling</h2>
    <div class="center"><img src="images/exception-in-java.png" alt="Exception Hierarchy Image"></div>
    <h3>Errors:</h3>
    <p>Errors are the conditions which cannot get recovered by any handling techniques  and cause the program to terminate at runtime.</p>
    <h3>Exceptions:</h3>
    <p>Is something that causes an abnormal flow in your program and it can no longer continue.</p>
    <p><b>Abnormal Flow Example:</b> You wrote a method to divide two number, but it was dividing by zero, so it throws an exception.</p>
    <p>Exceptions are the conditions that occur at runtime and may cause the termination of the program. But they are recoverable using try, catch and throw keywords.</p>
    <p>Exceptions are abnormal conditions that arise in a code sequence at run time.</p>
    <h3>Checked & Unchecked</h3>
    <p>Checked Exceptions: are the exceptions that are checked at compile time. If some code within a method throws a checked exception, then the method must either handle the exception or it must specify the exception using throws keyword.</p>
    <p>Unchecked: are the exceptions that are not checked at compiled time.</p>
    <h3>Checked (Compile-time) Exceptions Defined in java.lang</h3>
    <table>
        <tr>
            <th>Exception</th>
            <th>Meaning</th>
        </tr>
        <tr>
            <td>ClassNotFoundException</td>
            <td>Class not found.</td>
        </tr>
        <tr>
            <td>CloneNotSupportedException</td>
            <td>Attempt to clone an object that does not implement the Cloneable interface.</td>
        </tr>
        <tr>
            <td>IllegalAccessException</td>
            <td>Access to a class is denied.</td>
        </tr>
        <tr>
            <td>InstantiationException</td>
            <td>Attempt to create an object of an abstract class or interface.</td>
        </tr>
        <tr>
            <td>InterruptedException</td>
            <td>One thread has been interrupted by another thread.</td>
        </tr>
        <tr>
            <td>NoSuchFieldException</td>
            <td>A requested field does not exist.</td>
        </tr>
        <tr>
            <td>NoSuchMethodException</td>
            <td>A requested method does not exist.</td>
        </tr>
        <tr>
            <td>ReflectiveOperationException</td>
            <td>Superclass of reflection-related exceptions.</td>
        </tr>
    </table>
    <h3>Unchecked (Runtime) Exception Defined in java.lang</h3>
    <table>
        <tr>
            <th>Exception</th>
            <th>Meaning</th>
        </tr>
        <tr>
            <td>ArithmeticException</td>
            <td>Arithmetic error, such as divide-by-zero.</td>
        </tr>
        <tr>
            <td>ArrayIndexOutOfBoundsException</td>
            <td>Array index is out-of-bounds.</td>
        </tr>
        <tr>
            <td>ArrayStoreException</td>
            <td>Assignment to an array element of an incompatible type.</td>
        </tr>
        <tr>
            <td>ClassCastException</td>
            <td>Invalid cast.</td>
        </tr>
        <tr>
            <td>EnumConstantNotPresentException</td>
            <td>An attempt is made to use an undefined enumeration value.</td>
        </tr>
        <tr>
            <td>IllegalArgumentException</td>
            <td>Illegal argument used to invoke a method.</td>
        </tr>
        <tr>
            <td>IllegalMonitorStateException</td>
            <td>Illegal monitor operation, such as waiting on an unlocked thread.</td>
        </tr>
        <tr>
            <td>IllegalStateException</td>
            <td>Environment or application is in incorrect state.</td>
        </tr>
        <tr>
            <td>IllegalThreadStateException</td>
            <td>Requested operation not compatible with current thread state.</td>
        </tr>
        <tr>
            <td>IndexOutOfBoundsException</td>
            <td>Some type of index is out-of-bounds.</td>
        </tr>
        <tr>
            <td>NegativeArraySizeException</td>
            <td>Array created with a negative size.</td>
        </tr>
        <tr>
            <td>NullPointerException</td>
            <td>Invalid use of a null reference.</td>
        </tr>
        <tr>
            <td>NumberFormatException</td>
            <td>Invalid conversion of a string to a numeric format.</td>
        </tr>
        <tr>
            <td>SecurityException</td>
            <td>Attempt to violate security.</td>
        </tr>
        <tr>
            <td>StringIndexOutOfBounds</td>
            <td>Attempt to index outside the bounds of a string.</td>
        </tr>
        <tr>
            <td>TypeNotPresentException</td>
            <td>Type not found.</td>
        </tr>
        <tr>
            <td>UnsupportedOperationException</td>
            <td>An unsupported operation was encountered.</td>
        </tr>
    </table>
    <h3>Errors vs Exceptions</h3>
    <table>
        <tr>
            <th>Errors</th>
            <th>Exceptions</th>
        </tr>
        <tr>
            <td>Recovering from Error is not possible.</td>
            <td>We can recover from exceptions by either using try-catch block or throwing exceptions back to caller.</td>
        </tr>
        <tr>
            <td>All errors in java are unchecked type.</td>
            <td>Exceptions include both checked as well as unchecked type.</td>
        </tr>
        <tr>
            <td>Errors are mostly caused by the environment in which program is running.</td>
            <td>Program itself is responsible for causing exceptions.</td>
        </tr>
        <tr>
            <td>Errors occur at runtime and not known to the compiler.</td>
            <td>All exceptions occur at runtime but checked exceptions are known to compiler while unchecked are not.</td>
        </tr>
        <tr>
            <td>They are defined in java.lang.Error package.</td>
            <td>They are defined in java.lang.Exception package</td>
        </tr>
        <tr>
            <td><b>Examples:</b><br>
                java.lang.StackOverflowError, java.lang.OutOfMemoryError</td>
            <td><b>Examples:</b><br>
                <b>Checked Exceptions:</b><br> SQLException, IOException
                <br><b>Unchecked Exceptions:</b><br> ArrayIndexOutOfBoundException, NullPointerException, ArithmeticException.</td>
        </tr>
    </table>
    <h3>Managing Exceptions</h3>
    <p>When an exceptional condition arises, an object representing that exception is created and thrown in the method that caused the error.</p>
    <p>Exception Handling is managed through five keywords: try, catch, throw, throws, and finally.</p>
    <table>
        <tr>
            <td>Try block</td>
            <td>Encloses the code that you want to monitor for run-time errors.</td>
        </tr>
        <tr>
            <td>Catch clause</td>
            <td>Specifies the exception type that you wish to catch. If an error occurs within a try block it is thrown, your code can catch this exception using catch and handle it in some manner.
                <br>Goal: To resolve the exceptional condition and then continue on as if the error had never happened.</td>
        </tr>
        <tr>
            <td>Throw keyword</td>
            <td>Used to manually throw and exception.</td>
        </tr>
        <tr>
            <td>Throws clause</td>
            <td>Specifies any exception that is thrown out of a method.</td>
        </tr>
        <tr>
            <td>Finally block</td>
            <td>Always runs, any code that absolutely must be executed after a try block.</td>
        </tr>
    </table>
    <p>General Form:</p>
    <div class="code">
        try {<br>
        &emsp;<mark>// block of code to monitor for errors</mark><br>
        }<br>
        catch (ExceptionType1 exOb) {<br>
        &emsp;<mark>// exception handler for ExceptionType1</mark><br>
        }<br>
        catch (ExceptionType2 exOb) {<br>
        &emsp;<mark>// exception handler for ExceptionType2</mark><br>
        }<br>
        &emsp;<mark>// ...</mark><br>
        finally {<br>
        &emsp;<mark>// block of code to be executed after try block ends</mark><br>
        }
    </div>
    <p>Try Catch Blocks can be written in multiple forms: try/catch, try/catch/finally, and try/finally.</p>
    <h3>Multiple Catch Clauses</h3>
    <p>Multi-catch: feature allows two or more exceptions to be caught by the same catch clause each multi-catch parameter is implicitly final.</p>
    <p>In some cases, more than one exception could be raised by a single piece of code.</p>
    <p>You can specify two or more catch clauses, each catching a different type of exception.</p>
    <p>When you use multiple catch statements, it is important to remember that exception subclasses must come before any of their superclasses otherwise they will never run (unreachable code).</p>
    <div class="code">
        try {<br>
        &emsp;<mark>//...</mark><br>
        } catch (SQLException | ClassNotFoundException e) {<br>
        &emsp;e.printStackTrace();<br>
        }
    </div>
    <p>Stack Trace: What are the actions that have lead to the corresponding exception? Clearly tells you how the program proceeded into that exception.</p>
    <h3>Nested Try Statements</h3>
    <p>Each time a try statement is entered, the context of that exception is pushed on the stack.</p>
    <p>If the outer try/catch passes it moves inward and if that fails it moves back out If an inner try statement does not have a catch handler for a particular exception, the stack is unwound and the next try statement’s catch handlers are inspected for a match.</p>
    <div class="code">
        try { <mark>// last</mark><br>
        &emsp;try { <mark>// second</mark><br>
        &emsp;&emsp;try { <mark>// check here first</mark><br>
        &emsp;&emsp;&emsp;<mark>//...</mark><br>
        &emsp;&emsp;} catch () {<br>
        &emsp;} catch () {<br>
        } catch () {<br>
        &emsp;<mark>//...</mark><br>
        }
    </div>
    <h3>Throw</h3>
    <p>Used to throw an exception explicitly</p>
    <p>General Form: throw new ThrowableInstance();</p>
    <h3>Throws</h3>
    <p>A throws clause lists the types of exceptions that a method might throw.</p>
    <p>This is necessary for all exceptions, except those of type Error or RuntimeException, or any of their subclasses.</p>
    <p>General Form:</p>
    <div class="code">
        type method-name(parameter-list) throws exception-list {<br>
        &emsp;<mark>// body of method</mark><br>
        }
    </div>
    <h3>Finally</h3>
    <p>Creates a block of code that will execute after a try/catch block has completed and before the code following the try/catch block.</p>
    <p>Will execute whether or not an exception is thrown.</p>
    <h3>Creating your own exception subclasses</h3>
    <p>To handle situations specific to your application.</p>
    <p>Define a subclass of Exception which is a subclass of Throwable.</p>
    <p>Your subclasses don’t need to actually implement anything, it is their existence in the type system that allows you to use them as exceptions.</p>
    <p>Exception defines four public constructors: The other two are defined in the next section "Chained Exceptions"</p>
    <table>
        <tr>
            <td>Exception()</td>
            <td>Creates an exception that has no description</td>
        </tr>
        <tr>
            <td>Exception(String msg)</td>
            <td>Specify a description of the exception</td>
        </tr>
    </table>
    <h3>toString()</h3>
    <p>Defined by Throwable and inherited by Exception, displays the name of the exception followed by a colon and the description.</p>
    <p>By overriding toString( ), you can prevent the exception name and colon from being displayed.</p>
    <h3>Chained Exceptions</h3>
    <p>Allows you to associate another exception with an exception, this second exception describes the cause of the first exception.</p>
    <table>
        <tr>
            <td>Throwable(Throwable causeExc)</td>
            <td>causeExc is the underlying reason that an exception occurred</td>
        </tr>
        <tr>
            <td>Throwable(String msg, Throwable causeExc)</td>
            <td>Allows you to specify a description at the same time that you specify a cause exception.</td>
        </tr>
        <tr>
            <td>Throwable getCause()</td>
            <td>Returns the exception that underlies the current exception.</td>
        </tr>
        <tr>
            <td>Throwable initCause(Throwable causeExc)</td>
            <td>Associates causeExc with the invoking exception and returns a reference to the exception, causeExc can only be set once / called once per exception object.</td>
        </tr>
    </table>
    <h3>Creating Custom Exceptions</h3>
    <div class="code">
        public class InvalidUserException extends Exception {<br>
        &emsp;public InvalidUserException(String errorMessage) {<br>
        &emsp;&emsp;super(errorMessage);<br>
        &emsp;}<br>
        }<br><br>
        <mark>// Throw the error somewhere else in the code</mark><br>
        throw new InvalidUserException("The supplied user was not valid.");
    </div>
</div>
&nbsp;
<button class="collapsible">Multi-threaded Programming (Add thread creation information)</button>
<div class="content">
<h2>Multi-threaded Programming</h2>
    <h3>Java Memory Model</h3>
    <p>Stack:</p>
    <ul>
        <li>Every thread running in the JVM has its own stack.</li>
        <li>Contains all the methods it has executed up to the current point of execution.</li>
        <li>Local variables of primitive data types are stored inside the stack.</li>
        <li>Object references are stored on the stack.</li>
    </ul>
    <p>Heap:</p>
    <ul>
        <li>Contains all objects created by your java application.</li>
        <li>Object member variables are stored on the heap along with the object itself.</li>
        <li>Instance variables are on the heap.</li>
        <li>Static/class variables are stored on the heap along with the class definition (stored in a different region) and can be referenced by all other threads that have a reference the the object</li>
    </ul>
    <h3>Race Condition</h3>
    <p>Race Condition: When two or more threads are trying to access the same resource. Gives inconsistent output.</p>
    <h3>Thread Safety</h3>
    <p>Objects created locally and not shared with other threads are thread safe. Local primitive variables are thread safe.</p>
    <p>A resource that never escapes the control of the thread is safe.</p>
    <h3>Immutability</h3>
    <p>Immutable object: An object whose state cannot be modified after it's created.</p>
    <p>&emsp;Can also be used to achieve thread safety.</p>
    <p>Objects shared between threads are never updated by any of the threads by making the shared objects immutable, and thereby thread safe.</p>
    <p>The reference to the immutable object may not be thread safe so we use synchronization.</p>
    <h3>Synchronization</h3>
    <p>Used when two threads need to interact with a shared resource.</p>
    <h3>Thread Local</h3>
    <p>Allows you to create variables that can only be read and written to by that class.</p>
    <p>&emsp;private static final ThreadLocal&lt;&gt;</p>
    <p>If you want to access a thread local set by the parent class, then you need to use InheritableThreadLocal class.</p>
    <h3>Volatile Keyword</h3>
    <p>Used to ensure we are reading from and getting the data from the main memory and not the cache memory.</p>
    <p>Gets the data from the cache memory and updates the main memory.</p>
    <p>This is an expensive process, since cache memory is used for efficiency this should only be used with shared resources.</p>
    <p>&emsp;private volatile String spaces;</p>
    <h3>Daemon Thread</h3>
    <p>Low priority thread that keeps running in the background to perform background tasks like (garbage collection).</p>
    <table>
        <tr>
            <td>setDaemon()</td>
            <td>Set to true on a thread to make it a daemon thread.</td>
        </tr>
        <tr>
            <td>isDaemon()</td>
            <td>Check if a thread is a daemon thread.</td>
        </tr>
    </table>
    <h3>Thread Priority</h3>
    <p>Thread priority gives a thread more cpu preference. The default value is 5.</p>
</div>
&nbsp;
<button class="collapsible">Concurrency</button>
<div class="content">
    <h2 style="border-bottom: 2px solid black;">The Concurrency Utilities</h2>
    <table>
        <tr>
            <td>Semaphore</td>
            <td>Controls access to a shared resource through the use of a counter.</td>
        </tr>
        <tr>
            <td rowspan="3">CountDownLatch</td>
            <td>Waits until a specified number of events have occurred.</td>
        </tr>
        <tr>
            <td>To wait on the latch, a thread calls await().</td>
        </tr>
        <tr>
            <td>Each call to countDown() decrements the count associated with the invoking object.</td>
        </tr>
        <tr>
            <td rowspan="2">CyclicBarrier</td>
            <td>Enables a group of threads to wait at a predefined execution point.</td>
        </tr>
        <tr>
            <td>When each thread reaches the barrier, have it call await() on that object pausing execution of the thread until all of the other threads also call await()..</td>
        </tr>
        <tr>
            <td>Exchanger</td>
            <td>Exchanges data between two threads.</td>
        </tr>
        <tr>
            <td>Phaser</td>
            <td>Synchronizes threads that advance through multiple phases of an operation.</td>
        </tr>
        <tr>
            <td>Executor</td>
            <td>Controls the execution of threads.</td>
        </tr>
        <tr>
            <td>ExecutorService</td>
            <td>The ExecutorService interface extends Executor by adding methods that help manage and control the execution of threads.</td>
        </tr>
        <tr>
            <td>Runnable</td>
            <td>The Runnable interface is implemented in order to execute threads. The threads created will not return a value. Preferable to Callable, because it avoids inheritance.</td>
        </tr>
        <tr>
            <td>Callable</td>
            <td>The Callable interface represents a thread that returns a value.</td>
        </tr>
        <tr>
            <td>Future</td>
            <td>A generic interface that represents the value that will be returned by a Callable object.</td>
        </tr>
        <tr>
            <td>TimeUnit Enumeration</td>
            <td>TimeUnit is an enumeration that is used to specify the granularity (or resolution) of the timing.</td>
        </tr>
        <tr>
            <td rowspan="2">Locks</td>
            <td>Objects that offer an alternative to using synchronized to control access to a shared resource.</td>
        </tr>
        <tr>
            <td>Before accessing a shared resource, the lock that protects that resource is acquired. When access to the resource is complete, the lock is released.</td>
        </tr>
        <tr>
            <td>Atomic Operations</td>
            <td>Methods that get, set, or compare the value of a variable in one uninterruptible (that is, atomic) operation.</td>
        </tr>
    </table>
    &nbsp;
    <button class="collapsible"> Concurrency Overview </button>
    <div class="content">
    <h2>"Concurrent Program"</h2>
    <p>Refers to a program that makes extensive, integral use of concurrently executing threads.</p>
    <p>For Example: A program that uses separate threads to simultaneously compute the partial results of a larger computation.</p>
    <p>New threads can be created by implementing Runnable or by extending Thread.</p>
    <p>Inter-thread communication is supported by the wait() and notify() methods that are defined by Object.</p>
    <h2>Concurrent API Packages</h2>
    <p>The concurrency utilities are contained in the java.util.concurrent package and in its two subpackages: java.util.concurrent.atomic and java.util.concurrent.locks.</p>
    <h2>java.util.concurrent</h2>
    <p>Defines the core features that support alternatives to the built-in approaches to synchronization and interthread communication.</p>
    <ul>
        <li>Synchronizers</li>
        <li>Executors</li>
        <li>Concurrent collections</li>
        <li>The Fork/Join Framework</li>
    </ul>
    <h2>Synchronizers</h2>
    <table>
        <tr>
            <td>Semaphore</td>
            <td>Controls access to a shared resource through the use of a counter.</td>
        </tr>
        <tr>
            <td rowspan="3">CountDownLatch</td>
            <td>Waits until a specified number of events have occurred.</td>
        </tr>
        <tr>
            <td>To wait on the latch, a thread calls await().</td>
        </tr>
        <tr>
            <td>Each call to countDown() decrements the count associated with the invoking object.</td>
        </tr>
        <tr>
            <td rowspan="2">CyclicBarrier</td>
            <td>Enables a group of threads to wait at a predefined execution point.</td>
        </tr>
        <tr>
            <td>When each thread reaches the barrier, have it call await() on that object pausing execution of the thread until all of the other threads also call await()..</td>
        </tr>
        <tr>
            <td>Exchanger</td>
            <td>Exchanges data between two threads.</td>
        </tr>
        <tr>
            <td>Phaser</td>
            <td>Synchronizes threads that advance through multiple phases of an operation.</td>
        </tr>
    </table>
    <h2>Executors</h2>
    <p>Manage thread execution.</p>
    <p>At the top of the executor hierarchy is the Executor interface, which is used to initiate a thread.</p>
    <h2>ExecutorService</h2>
    <p>Extends Executor and provides methods that manage execution.</p>
    <table>
        <tr>
            <td>ThreadPoolExecutor</td>
        </tr>
        <tr>
            <td>ScheduledThreadPoolExecutor</td>
        </tr>
        <tr>
            <td>ForkJoinPool</td>
        </tr>
    </table>
    <h2>The Future and Callable Interfaces</h2>
    <p>Future contains a value that is returned by a thread after it executes. "its value gets defined in the future", when the thread terminates.</p>
    <p>Callable defines a thread that returns a value.</p>
    <h2>Concurrent Collection Classes</h2>
    <table>
        <tr>
            <td>ArrayBlockingQueue</td>
        </tr>
        <tr>
            <td>ConcurrentHashMap</td>
        </tr>
        <tr>
            <td>ConcurrentLinkedDeque</td>
        </tr>
        <tr>
            <td>ConcurrentLinkedQueue</td>
        </tr>
        <tr>
            <td>ConcurrentSkipListMap</td>
        </tr>
        <tr>
            <td>ConcurrentSkipListSet</td>
        </tr>
        <tr>
            <td>CopyOnWriteArrayList</td>
        </tr>
        <tr>
            <td>CopyOnWriteArraySet</td>
        </tr>
        <tr>
            <td>DelayQueue</td>
        </tr>
        <tr>
            <td>LinkedBlockingDeque</td>
        </tr>
        <tr>
            <td>LinkedBlockingQueue</td>
        </tr>
        <tr>
            <td>LinkedTransferQueue</td>
        </tr>
        <tr>
            <td>PriorityBlockingQueue</td>
        </tr>
        <tr>
            <td>SynchronousQueue</td>
        </tr>
    </table>
    <p>These collections work much like the other collections except that they provide concurrency support.</p>
    <h2>TimeUnit Enumeration</h2>
    <p>To better handle thread timing, java.util.concurrent define the TimeUnit enumeration.</p>
    <h2>java.util.concurrent.atomic</h2>
    <p>Facilitates the use of variables in a concurrent environment.</p>
    <p>It provides a means of efficiently updating the value of a variable without the use of locks. Through the use of classes, such as AtomicInteger and AtomicLong, and methods, such as compareAndSet(), decrementAndGet(), and getAndSet().</p>
    <h2>java.util.concurrent.locks</h2>
    <p>Provides an alternative to the use of synchronized methods.</p>
    <p>At the core of this alternative is the Lock interface, which defines the basic mechanism used to acquire and relinquish access to an object.</p>
    <table>
        <tr>
            <td>lock()</td>
        </tr>
        <tr>
            <td>tryLock()</td>
        </tr>
        <tr>
            <td>unlock()</td>
        </tr>
    </table>
    <p>The advantage to using these methods is greater control over synchronization.</p>
        <h2>ThreadLocal</h2>
        <p>Every thread has its own ThreadLocal variable and they can use it's get() and set() methods to get the default value or change it's value local to the Thread.</p>
        <p>ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread.</p>
    </div>
    <h2 style="border-bottom: 2px solid black;">Synchronization Objects</h2>
    <p>Synchronization objects are supported by the Semaphore, CountDownLatch, CyclicBarrier, Exchanger, and Phaser classes.</p>
    <button class="collapsible"> Semaphore </button>
    <div class="content">
    <h2>Semaphore</h2>
    <p>Controls access to a shared resource through the use of a counter.</p>
    <ul>
        <li>If the counter is > 0 then access is allowed.</li>
        <li>If the counter = 0 then access is denied.</li>
    </ul>
    <p>The counter is counting permits that allow access to the shared resource.</p>
    <p>Thus, to access the resource, a thread must be granted a permit from the semaphore.</p>
    <h3>Constructors:</h3>
    <ol>
        <li>Semaphore(int num)</li>
        <li>Semaphore(int num, boolean how)</li>
    </ol>
    <p>num specifies the number of permits or threads that can have access to the resource at a given time.</p>
    <p>By setting how to true, you can ensure that waiting threads are granted a permit in the order in which they requested access.</p>
    <h3>To acquire a permit, call the acquire() method</h3>
    <ol>
        <li>void acquire() throws InterruptedException</li>
        <li>void acquire(int num) throws InterruptedException</li>
    </ol>
    <h3>To release a permit, call the release() method</h3>
    <ol>
        <li>void release()</li>
        <li>void release(int num)</li>
    </ol>
    </div>
    <button class="collapsible"> CountDownLatch </button>
    <div class="content">
    <h2>CountDownLatch</h2>
    <p>A CountDownLatch is initially created with a count of the number of events that must occur before the latch is released.</p>
        <p>CountDownLatch(int num) <mark>// num specifies the number of events that must occur in order for the latch to open.</mark></p>
    <h3>To wait on the latch, a thread calls await()</h3>
    <ol>
        <li>void await() throws InterruptedException</li>
        <li>boolean await(long wait, TimeUnit tu) throws InterruptedException</li>
    </ol>
    <p>The second form waits only for the period of time specified by wait in the unit of time specified by tu.</p>
    <h3>To signal an event, call the countDown() method</h3>
    <ol>
        <li>void countDown() <mark>// Each call to countDown() decrements the count associated with the invoking object.</mark></li>
    </ol>
        <div class="code">
            import java.util.concurrent.CountDownLatch;<br>
            public class CDLDemo {<br>
            public static void main(String[] args) {<br><br>
            &emsp;&emsp;CountDownLatch cdl = new CountDownLatch(5);<br>
            &emsp;&emsp;System.out.println("Starting");<br>
            &emsp;&emsp;new MyThread(cdl);<br><br>
            &emsp;&emsp;try {<br>
            &emsp;&emsp;&emsp;cdl.await();<br>
            &emsp;&emsp;} catch (InterruptedException e) {<br>
            &emsp;&emsp;&emsp;System.out.println(e);<br>
            &emsp;&emsp;}<br><br>
            &emsp;&emsp;System.out.println("Done");<br>
            &emsp;}<br>
            }<br><br>
            class MyThread implements Runnable {<br>
            &emsp;CountDownLatch latch;<br><br>
            &emsp;MyThread(CountDownLatch c) {<br>
            &emsp;&emsp;latch = c;<br>
            &emsp;&emsp;new Thread(this).start();<br>
            &emsp;}<br><br>
            &emsp;@Override<br>
            &emsp;public void run() {<br>
            &emsp;&emsp;for (int i = 0; i < 5; i++) {<br>
            &emsp;&emsp;&emsp;System.out.println(i);<br>
            &emsp;&emsp;&emsp;latch.countDown(); <mark>// decrement count</mark><br>
            &emsp;&emsp;}<br>
            &emsp; }<br>
            }
        </div>
    </div>
    <button class="collapsible"> CyclicBarrier </button>
    <div class="content">
    <h2>CyclicBarrier</h2>
    <p>Used when a set of two or more threads must wait at a predetermined execution point until all threads in the set have reached that point.</p>
    <p>It enables you to define a synchronization object that suspends until the specified number of threads has reached the barrier point.</p>
    <h3>Constructors:</h3>
    <ol>
        <li>CyclicBarrier(int numThreads)</li>
        <li>CyclicBarrier(int numThreads, Runnable action)</li>
    </ol>
    <p>numThreads specifies the number of threads that must reach the barrier before execution continues.</p>
    <p>In the second form, action specifies a thread that will be executed when the barrier is reached.</p>
    <h3>Creating a CyclicBarrier</h3>
    <ol>
        <li>First, create a CyclicBarrier object, specifying the number of threads that you will be waiting for.</li>
        <li>Next, when each thread reaches the barrier, have it call await() on that object. This will pause execution of the thread until all of the other threads also call await().</li>
        <li>Once the specified number of threads has reached the barrier, await() will return and execution will resume.</li>
    </ol>
    <h3>The await() method</h3>
    <ol>
        <li>int await() throws InterruptedException, BrokenBarrierException</li>
        <li>int await(long wait, TimeUnit tu) throws InterruptedException, BrokenBarrierException, TimeoutException</li>
    </ol>
    <p>First form waits until all the threads have reached the barrier point.</p>
    <p>Second form waits only for the period of time specified by wait.</p>
    <p>A CyclicBarrier can be reused because it will release waiting threads each time the specified number of threads calls await().</p>
    <p>For Example: This will create a new CyclicBarrier and perform the first 3 thread executions, reach the barrier, and then perform the next 3, and reach the barrier again.</p>
    <div class="code">
        CyclicBarrier cb = new CyclicBarrier(3, new BarAction());<br>
        &emsp;new MyThread(cb, "A");<br>
        &emsp;new MyThread(cb, "B");<br>
        &emsp;new MyThread(cb, "C");<br>
        &emsp;new MyThread(cb, "X");<br>
        &emsp;new MyThread(cb, "Y");<br>
        &emsp;new MyThread(cb, "Z");
    </div>
    </div>
    <button class="collapsible"> Exchanger </button>
    <div class="content">
        <h2>Exchanger</h2>
        <p>Designed the simplify the exchange of data between two threads.</p>
        <p>It simply waits until two separate threads call its exchange() method. When that occurs, it exchanges the data supplied by the threads.</p>
        <p>For Example: One thread might prepare a buffer for receiving information over a network connection. Another thread might fill that buffer with the information from the connection. Each time a new buffer is needed, an exchange is made.</p>
        <p>Exchanger &lt;V&gt; <mark>// Here, V specifies the type of the data being exchanged.</mark></p>
        <h3>Constructors</h3>
        <ol>
            <li>V exchange(V objRef) throws InterruptedException</li>
            <li>V exchange(V objRef, long wait, TimeUnit tu) throws InterruptedException, TimeoutException</li>
        </ol>
        <p>objRef is a reference to the data to exchange. The data received from the other thread is returned.</p>
        <p>The second form allows a time-out period to be specified.</p>
    </div>
    <button class="collapsible"> Phaser </button>
    <div class="content">
        <h2>Phaser</h2>
        <p>Primary purpose is to enable the synchronization of threads that represent one or more phases of activity.</p>
        <p>For Example: You might have a set of threads that implement three phases of an order-processing application.</p>
        <ol>
            <li>First phase, separate threads are used to validate customer information, check inventory, and confirm pricing.</li>
            <li>Second phase, two threads that compute shipping costs and all applicable tax.</li>
            <li>Final phase, confirms payment and determines estimated shipping time.</li>
        </ol>
        <p>A Phaser works a bit like a CyclicBarrier, described earlier, except that it supports multiple phases. As a result, Phaser lets you define a synchronization object that waits until a specific phase has completed.</p>
        <table>
            <tr>
                <td>Phaser()</td>
                <td></td>
            </tr>
            <tr>
                <td>Phaser(int numParties)</td>
                <td></td>
            </tr>
            <tr>
                <td>register()</td>
                <td>To register parties after a Phaser has been constructed.</td>
            </tr>
            <tr>
                <td>int arrive()</td>
                <td>To signal that a party has completed a phase.</td>
            </tr>
            <tr>
                <td>arriveAndAwaitAdvance()</td>
                <td>If you want to indicate the completion of a phase and then wait until all other registrants have also completed that phase.</td>
            </tr>
            <tr>
                <td>arriveAndDeregister()</td>
                <td>A thread can arrive and then deregister itself, it returns the current phase number or a negative value if the phaser has been terminated.</td>
            </tr>
            <tr>
                <td>final int getPhase()</td>
                <td>To obtain the current phase number</td>
            </tr>
            <tr>
                <td>protected boolean onAdvance(int phase, int numParties)</td>
                <td>It is possible to take control of precisely what happens when a phase advance occurs. To terminate the phaser, onAdvance() must return true. To keep the phaser alive, onAdvance() must return false.</td>
            </tr>
        </table>
        <ol>
            <li>First, create a new instance of Phaser.</li>
            <li>Next, register one or more parties with the phaser, either by calling register() or by specifying the number of parties in the constructor.</li>
            <li>For each registered party, have the phaser wait until all registered parties complete a phase.</li>
            <li>A party signals this by calling one of a variety of methods supplied by Phaser, such as arrive() or arriveAndAwaitAdvance().</li>
            <li>After all parties have arrived, the phase is complete, and the phaser can move on to the next phase (if there is one), or terminate.</li>
        </ol>
    </div>
    <h2 style="border-bottom: 2px solid black;">Executor Services and more...</h2>
    <button class="collapsible"> Executors (ExecutorService, Runnable, Callable, Future) </button>
    <div class="content">
    <h2>Executor</h2>
        <p>Controls the execution of threads.</p>
        <p>void execute(Runnable thread) <mark>// execute() starts the specified thread.</mark></p>
    <h3>ExecutorService</h3>
        <p>The ExecutorService interface extends Executor by adding methods that help manage and control the execution of threads.</p>
        <p>Represents an asynchronous execution mechanism which is capable of executing tasks concurrently in the background.</p>
        <table>
            <tr>
                <td>ThreadPoolExecutor</td>
                <td>Implements the Executor and ExecutorService interfaces and provides support for a managed pool of threads.</td>
            </tr>
            <tr>
                <td>ScheduledThreadPoolExecutor</td>
                <td>Also implements the ScheduledExecutorService interface to allow a pool of threads to be scheduled.</td>
            </tr>
            <tr>
                <td>ForkJoinPool</td>
                <td>Implements the Executor and ExecutorService interfaces and is used by the Fork/Join Framework.</td>
            </tr>
        </table>
        <h3>Task Delegation</h3>
        <p>Once the thread has delegated the task to the ExecutorService, the thread continues its own execution independent of the execution of that task.</p>
        <p>The ExecutorService then executes the task concurrently, independently of the thread that submitted the task.</p>
        <h3>Example:</h3>
        <div class="code">
            <mark>// First an ExecutorService is created using the Executors newFixedThreadPool() factory method. This creates a thread pool with 10 threads executing tasks.</mark><br>
            ExecutorService executorService = Executors.newFixedThreadPool(10);<br><br>
            <mark>// Second, an anonymous implementation of the Runnable interface is passed to the execute() method. This causes the Runnable to be executed by one of the threads in the ExecutorService.</mark><br>
            executorService.execute(new Runnable() {<br>
            &emsp;public void run() {<br>
            &emsp;&emsp;System.out.println("Asynchronous task");<br>
            &emsp;}<br>
            });<br><br>
            <mark>// Shut down executor service</mark><br>
            executorService.shutdown();
        </div>
    <h3>Java ExecutorService Implementations</h3>
        <p>The Java ExecutorService is very similar to a thread pool. In fact, the implementation of the ExecutorService interface present in the java.util.concurrent package is a thread pool implementation.</p>
        <p>Since ExecutorService is an interface, you need to use its implementations in order to make any use of it.</p>
        <ol>
            <li>ThreadPoolExecutor</li>
            <li>ScheduledThreadPoolExecutor</li>
        </ol>
        <h3>Thread Pool</h3>
        <p>Provides a set of threads that is used to execute various tasks. Instead of each task using its own thread, the threads in the pool are used.</p>
        <p>This reduces the overhead associated with creating many separate threads.</p>
        <p>Most often you will want to obtain an executor by calling one of the following static factory methods defined by the Executors utility class.</p>
        <table>
            <tr>
                <td>static ExecutorService newCachedThreadPool()</td>
                <td>Creates a thread pool that adds threads as needed but reuses threads if possible.</td>
            </tr>
            <tr>
                <td>static ExecutorService newFixedThreadPool(int numThreads)</td>
                <td>Creates a thread pool that consists of a specified number of threads.</td>
            </tr>
            <tr>
                <td>static ScheduledExecutorService newScheduledThreadPool(int numThreads)</td>
                <td>Creates a thread pool that supports thread scheduling.</td>
            </tr>
        </table>
        <p>Each returns a reference to an ExecutorService that can be used to manage the pool.</p>
        <h3>Creating an ExecutorService</h3>
        <table>
            <tr>
                <td>ExecutorService executorService1 = Executors.newSingleThreadExecutor();</td>
            </tr>
            <tr>
                <td>ExecutorService executorService2 = Executors.newFixedThreadPool(10);</td>
            </tr>
            <tr>
                <td>ExecutorService executorService3 = Executors.newScheduledThreadPool(10);</td>
            </tr>
        </table>
        <h3>ExecutorService Usage</h3>
        <p>There are a few different ways to delegate tasks for execution to an ExecutorService.</p>
        <table>
            <tr>
                <td>execute(Runnable)</td>
                <td>Takes a java.lang.Runnable object and executes it asynchronously.</td>
            </tr>
            <tr>
                <td>submit(Runnable)</td>
                <td>Also takes a Runnable implementation, but returns a Future object. This Future object can be used to check if the Runnable has finished executing.</td>
            </tr>
            <tr>
                <td>submit(Callable)</td>
                <td>Takes a Java Callable instead of a Runnable. The Callable's result can be obtained via the Java Future object returned by the submit(Callable) method.</td>
            </tr>
            <tr>
                <td>invokeAny(...)</td>
                <td>Takes a collection of Callable objects, or subinterfaces of Callable. returns the result of one of the Callable objects. no guarantee which one though. If one of the tasks complete (or throws an exception), the rest of the Callable's are cancelled.</td>
            </tr>
            <tr>
                <td>invokeAll(...)</td>
                <td>Invokes all of the Callable objects you pass to it in the collection passed as a parameter. Returns a list of Future objects via which you can obtain the results of the executions of each Callable.</td>
            </tr>
        </table>
        <h3>Runnable vs. Callable</h3>
        <p>Both interfaces represents a task that can be executed concurrently by a thread or an ExecutorService. Both interfaces only have a single method.</p>
        <p>Runnable Interface Declaration</p>
        <div class="code">
            public interface Runnable {<br>
            &emsp;public void run();<br>
            }
        </div>
        <p>Callable Interface Declaration</p>
        <div class="code">
            public interface Callable{<br>
            &emsp;public Object call() throws Exception;<br>
            }
        </div>
        <p>The main difference is that the call() method can return an Object from the method call.</p>
        <p>Another difference between call() and run() is that call() can throw an exception.</p>
        <p>If you need to submit a task to a Java ExecutorService and you need a result from the task, then you need to make your task implement the Callable interface. Otherwise your task can just implement the Runnable interface.</p>
        <p>A Java Callable is different from a Runnable in that the Runnable interface's run() method does not return a value, and it cannot throw checked exceptions (only RuntimeExceptions).</p>
        <p>Additionally, a Runnable was originally designed for long running concurrent execution, e.g. running a network server concurrently, or watching a directory for new files. The Callable interface is more designed for one-off tasks that return a single result.</p>
        <h3>shutdown()</h3>
        <p>A call to shutdown() is important. If it were not present in the program, then the program would not terminate because the executor would remain active.</p>
    <button class="collapsible"> Callable </button>
    <div class="content">
    <h2>Callable</h2>
        <p>The Callable interface represents a thread that returns a value.</p>
        <p>An application can use Callable objects to compute results that are then returned to the invoking thread.</p>
        <p>It can also be used to run a thread that returns a status code that indicates the successful completion of the thread.</p>
    <h3>Callable is a generic interface that is defined like this:</h3>
        <p>interface Callable &lt;V&gt; <mark>// V indicates the type of data returned by the task.</mark></p>
    <h3>Callable defines only one method</h3>
        <p>V call() throws Exception</p>
        <p>Inside call() you define the task that you want performed. After that task completes, you return the result. If the result cannot be computer, call() must throw an exception.</p>
    <p>A Callable task is executed by an ExecutorService, by calling its submit() method.</p>
        <p>&lt;T&gt;Future&lt;T&gt;submit(Callable&lt;T&gt; task)</p>
        <p>Task is the Callable object that will be executed in its own thread. The result is returned through an object of type Future</p>
        <h3>Java Callable</h3>
        <p>The Java Callable interface, java.util.concurrent.Callable, represents an asynchronous task which can be executed by a separate thread. For instance, it is possible to submit a Callable object to a Java ExecutorService which will then execute it asynchronously.</p>
        <h3>Java Callable Interface Definition</h3>
        <p>The Java Callable interface is quite simple, it contains a single method named call().</p>
        <p>The call() method is called in order to execute the asynchronous task. The call() method can return a result. If the task is executed asynchronously, the result is typically propagated back to the creator of the task via a Java Future.</p>
        <div class="code">
            public interface Callable&lt;V&gt; {<br>
            &emsp;V call() throws Exception;<br>
            }
        </div>
    </div>
    <button class="collapsible"> Future </button>
    <div class="content">
    <h2>Future</h2>
        <p>A generic interface that represents the value that will be returned by a Callable object.</p>
        <p>Because this value is obtained at some future time, the name Future is appropriate.</p>
        <p>interface Future&lt;V&gt; <mark>// V specifies the type of the result.</mark></p>
        <p>A Java Future, java.util.concurrent.Future, represents the result of an asynchronous computation.</p>
        <p>When the asynchronous task is created, a Java Future object is returned.</p>
        <p>Once the asynchronous task completes, the result can be accessed via the Future object returned when the task was started.</p>
    <h3>To obtain the returned value, you will call Future's get() method.</h3>
    <ol>
        <li>V get() throws InterruptedException, ExecutionException</li>
        <li>V get(long wait, TimeUnit tu) throws InterruptedException, ExecutionException, TimeoutException</li>
    </ol>
        <p>The first form waits for the result indefinitely. The second form allows you to specify a timeout period in wait. The units of wait are passed in tu, which is an object of the TimeUnit enumeration.</p>
    <ol>
        <li>boolean cancel(boolean mayInterruptIfRunning)</li>
        <li>boolean isCancelled();</li>
        <li>boolean isDone();</li>
    </ol>
        <h3>Cancel Task</h3>
        <p>You can cancel a task (Runnable or Callable) submitted to a Java ExecutorService by calling the cancel() method on the Future returned when the task is submitted.</p>
        <p>Cancelling the task is only possible if the task has not yet started executing.</p>
        <p>future.cancel();</p>
        <h3>Check if task is done.</h3>
        <p>You can check if the asynchronous task is done (and a result available) by calling the Future isDone() method.</p>
        <div class="code">
            if(future.isDone()) {<br>
            &emsp;Object result = future.get();<br>
            } else {<br>
            &emsp;<mark>// do something else</mark><br>
            }
        </div>
        <h3>Check if task is cancelled</h3>
        <p>It is also possible to check if the asynchronous task represented by a Java Future is cancelled.</p>
        <div class="code">
            if(future.isCancelled()) {<br><br>
            } else {<br><br>
            }
        </div>
    </div>
        <button class="collapsible">ThreadPoolExecutor</button>
        <div class="content">
            <h2>ThreadPoolExecutor</h2>
            <p>The java.util.concurrent.ThreadPoolExecutor is an implementation of the ExecutorService interface.</p>
            <p>The ThreadPoolExecutor executes the given task (Callable or Runnable) using one of its internally pooled threads.</p>
            <p>The thread pool contained inside the ThreadPoolExecutor can contain a varying amount of threads.</p>
            <ul>
                <li>corePoolSize</li>
                <li>maximumPoolSize</li>
            </ul>
            <p>If less than corePoolSize threads are created in the the thread pool when a task is delegated to the thread pool, then a new thread is created, even if idle threads exist in the pool.</p>
            <p>If the internal queue of tasks is full, and corePoolSize threads or more are running, but less than maximumPoolSize threads are running, then a new thread is created to execute the task.</p>
        <h3>Creating a ThreadPoolExecutor</h3>
        <p>The ThreadPoolExecutor has several constructors available</p>
            <div class="code">
                int corePoolSize = 5;<br>
                int maxPoolSize = 10;<br>
                long keepAliveTime = 5000;<br>
                ExecutorService threadPoolExecutor =<br>
                new ThreadPoolExecutor(corePoolSize, maxPoolSize, keepAliveTime, TimeUnit.MILLISECONDS,<br>
                new LinkedBlockingQueue&lt;Runnable&gt;());<br>
            </div>
            <p>However, unless you need to specify all these parameters explicitly for your ThreadPoolExecutor, it is often easier to use one of the factory methods in the java.util.concurrent.Executors class.</p>
        </div>
        <button class="collapsible">ScheduledExecutorService</button>
        <div class="content">
            <h2>ScheduledExecutorService</h2>
            <p>The java.util.concurrent.ScheduledExecutorService is an ExecutorService which can schedule tasks to run after a delay, or to execute repeatedly with a fixed interval of time in between each execution.</p>
            <p>Tasks are executed asynchronously by a worker thread, and not by the thread handing the task to the ScheduledExecutorService.</p>
        <h3>ScheduledExecutorService Implementations</h3>
        <p>Since ScheduledExecutorService is an interface, you will have to use its implementation in the java.util.concurrent package, in order to use it.</p>
        <p>ScheduledThreadPoolExecutor</p>
            <h3>Creating a ScheduledExecutorService</h3>
            <p>How you create an ScheduledExecutorService depends on the implementation you use. However, you can use the Executors factory class to create ScheduledExecutorService instances too.</p>
            <div class="code">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);</div>
        <h3>ScheduledExecutorService Usage</h3>
        <p>Once you have created a ScheduledExecutorService you use it by calling one of its methods:</p>
        <table>
            <tr>
                <td>schedule (Callable task, long delay, TimeUnit timeunit)</td>
                <td>This method schedules the given Callable for execution after the given delay. The method returns a ScheduledFuture which you can use to either cancel the task before it has started executing, or obtain the result once it is executed.</td>
            </tr>
            <tr>
                <td> schedule (Runnable task, long delay, TimeUnit timeunit)</td>
                <td>This method works like the method version taking a Callable as parameter, except a Runnable cannot return a value, so the ScheduledFuture.get() method returns null when the task is finished.</td>
            </tr>
            <tr>
                <td>scheduleAtFixedRate (Runnable, long initialDelay, long period, TimeUnit timeunit)</td>
                <td>This method schedules a task to be executed periodically. The task is executed the first time after the initialDelay, and then recurringly every time the period expires.
                    If any execution of the given task throws an exception, the task is no longer executed. If no exceptions are thrown, the task will continue to be executed until the ScheduledExecutorService is shut down.
                    If a task takes longer to execute than the period between its scheduled executions, the next execution will start after the current execution finishes. The scheduled task will not be executed by more than one thread at a time.</td>
            </tr>
            <tr>
                <td>scheduleWithFixedDelay (Runnable, long initialDelay, long period, TimeUnit timeunit)</td>
                <td>This method works very much like scheduleAtFixedRate() except that the period is interpreted differently.
                    In the scheduleAtFixedRate() method the period is interpreted as a delay between the start of the previous execution, until the start of the next execution.
                    In this method, however, the period is interpreted as the delay between the end of the previous execution, until the start of the next. The delay is thus between finished executions, not between the beginning of executions.</td>
            </tr>
        </table>
        </div>
        <button class="collapsible">ExecutorService Shutdown</button>
        <div class="content">
        <h2>ExecutorService Shutdown</h2>
            <p>When you are done using the ExecutorService you should shut it down, so the threads do not keep running.</p>
            <p>If your application is started via a main() method and your main thread exits your application, the application will keep running if you have an active ExexutorService in your application.</p>
            <p>The active threads inside this ExecutorService prevents the JVM from shutting down.</p>
        <h3>ScheduledExecutorService Shutdown</h3>
        <p>Just like an ExecutorService, the ScheduledExecutorService needs to be shut down when you are finished using it. If not, it will keep the JVM running, even when all other threads have been shut down.</p>
       <h3>"shutdown()</h3>
            <p>To terminate the threads inside the ExecutorService you call its shutdown() method.</p>
            <p>The ExecutorService will not shut down immediately, but it will no longer accept new tasks, and once all threads have finished current tasks, the ExecutorService shuts down.</p>
            <div class="code">
                executorService.shutdown();
            </div>
            <h3>"shutdownNow()</h3>
            <p>If you want to shut down the ExecutorService immediately, you can call the shutdownNow() method.</p>
            <p>This will attempt to stop all executing tasks right away, and skips all submitted but non-processed tasks.</p>
            <div class="code">
                executorService.shutdownNow();
            </div>
            <h3>"awaitTermination()</h3>
            <p>The ExecutorService awaitTermination() method will block the thread calling it until either the ExecutorService has shutdown completely, or until a given time out occurs.</p>
            <p>The awaitTermination() method is typically called after calling shutdown() or shutdownNow().</p>
            <div class="code">
                executorService.shutdown();<br>
                executorService.awaitTermination();
            </div>
        </div>
    </div>
    <button class="collapsible"> TimeUnit Enumeration </button>
    <div class="content">
    <h2>TimeUnit Enumeration</h2>
        <p>TimeUnit is an enumeration that is used to specify the granularity (or resolution) of the timing.</p>
        <p>TimeUnit is defined within java.util.concurrent.</p>
        <table>
            <tr>
                <td>DAYS</td>
            </tr>
            <tr>
                <td>HOURS</td>
            </tr>
            <tr>
                <td>Minutes</td>
            </tr>
            <tr>
                <td>SECONDS</td>
            </tr>
            <tr>
                <td>MICROSECONDS</td>
            </tr>
            <tr>
                <td>MILLISECONDS</td>
            </tr>
            <tr>
                <td>NANOSECONDS</td>
            </tr>
        </table>
        <h3>TimeUnit enumeration defines various methods that convert between units.</h3>
        <table>
            <tr>
                <td>long convert(long tval, TimeUnit tu)</td>
            </tr>
            <tr>
                <td>long toMicros(long tval)</td>
            </tr>
            <tr>
                <td>long toMillis(long tval)</td>
            </tr>
            <tr>
                <td>long toNanos(long tval)</td>
            </tr>
            <tr>
                <td>long toSeconds(long tval)</td>
            </tr>
            <tr>
                <td>long toDays(long tval)</td>
            </tr>
            <tr>
                <td>long toHours(long tval)</td>
            </tr>
            <tr>
                <td>long toMinutes(long tval)</td>
            </tr>
        </table>
        <p>The convert() method converts tval into the specified unit and returns the result.</p>
        <h3>TimeUnit also defines the following time methods:</h3>
        <table>
            <tr>
                <td>void sleep(long delay) throws InterruptedExecution</td>
                <td>Pauses execution</td>
            </tr>
            <tr>
                <td>void timedJoin(Thread thrd, long delay) throws InterruptedExecution</td>
                <td></td>
            </tr>
            <tr>
                <td>void timedWait(Object obj, long delay) throws InterruptedExecution</td>
                <td></td>
            </tr>
        </table>
    </div>
    <button class="collapsible"> Locks </button>
    <div class="content">
    <h2>Locks</h2>
        <h3>java.util.concurrent.locks</h3>
        <p>This package provides support for locks, which are objects that offer an alternative to using synchronized to control access to a shared resource.</p>
        <p>Before accessing a shared resource, the lock that protects that resource is acquired.</p>
        <p>When access to the resource is complete, the lock is released.</p>
        <p>If a second thread attempts to acquire the lock when it is in use by another thread, the second thread will suspend until the lock is released.</p>
        <table>
            <tr>
                <td>lock()</td>
                <td>To acquire a lock. If the lock is unavailable, lock() will wait.</td>
            </tr>
            <tr>
                <td>unlock()</td>
                <td>To release a lock</td>
            </tr>
            <tr>
                <td>tryLock()</td>
                <td>To see if a lock is available, and to acquire it if it is.</td>
            </tr>
        </table>
        <p>The newCondition() method returns a Condition object associated with the lock.</p>
        <p>Using a Condition, you gain detailed control of the lock through methods such as await() and signal(), which provide functionality similar to Object.wait() and Object.notify().</p>
        <h3>ReentrantLock</h3>
        <p>java.util.concurrent.locks supplies an implementation of Lock called ReentrantLock.</p>
        <p>ReentrantLock implements a reentrant lock, which is a lock that can be repeatedly entered by the thread that currently holds the lock.</p>
        <h3>ReentrantReadWriteLock</h3>
        <p>java.util.concurrent.locks also defines the ReadWriteLock interface. This interface specifies a lock that maintains separate locks for read and write access.</p>
        <ul>
            <li>Read Lock – if no thread acquired the write lock or requested for it then multiple threads can acquire the read lock.</li>
            <li>Write Lock – if no threads are reading or writing then only one thread can acquire the write lock.</li>
        </ul>
        <h3>StampedLock</h3>
        <p>Lock acquisition methods return a stamp that is used to release a lock or to check if the lock is still valid.</p>
        <table>
            <tr>
                <td>void lock()</td>
                <td>Waits until the invoking lock can be acquired.</td>
            </tr>
            <tr>
                <td>void lockInterruptibly() throws InterruptedException</td>
                <td>Waits until the invoking lock can be acquired, unless interrupted.</td>
            </tr>
            <tr>
                <td>Condition newCondition()</td>
                <td>Returns a Condition object that is associated with the invoking lock.</td>
            </tr>
            <tr>
                <td>boolean tryLock()</td>
                <td>Attempts to acquire the lock. This method will not wait if the lock is unavailable. Instead, it returns true if the lock has been acquired and false if the lock is currently in use by another thread.</td>
            </tr>
            <tr>
                <td>boolean tryLock(long wait, TimeUnit tu) throws InterruptedException</td>
                <td>Attempts to acquire the lock. If the lock is unavailable, this method will wait no longer than the period specified by wait, which is in tu units. It returns true if the lock has been acquired and false if the lock cannot be acquired within the specified period.</td>
            </tr>
            <tr>
                <td>void unlock()</td>
                <td>Releases the lock.</td>
            </tr>
        </table>
    </div>
    <button class="collapsible"> Atomic Operations </button>
    <div class="content">
        <h2>Atomic Operations</h2>
        <h3>java.util.concurrent.atomic</h3>
        <p>This package offers methods that get, set, or compare the value of a variable in one uninterruptible (that is, atomic) operation.</p>
        <p>This means that no lock or other synchronization mechanism is required.</p>
        <p>Atomic operations are accomplished through the use of classes, such as AtomicInteger and AtomicLong, and methods such as get(), set(), compareAndSet(), decrementAndGet(), and getAndSet(), which perform the action indicated by their names.</p>
        <p>java.util.concurrent.atomic also provides four classes that support lock-free cumulative operations. These are DoubleAccumulator, DoubleAdder, LongAccumulator, and LongAdder.</p>
        <p>The accumulator classes support a series of user-specified operations. The adder classes maintain a cumulative sum.</p>
    </div>
</div>
&nbsp;
<button class="collapsible">Collections</button>
<div class="content">

</div>
&nbsp;
<button class="collapsible">Generics</button>
<div class="content">
<h3>Generics</h3>
    <p>Through the use of generics, it is possible to create classes, interfaces, and methods that will work in a type-safe manner with various kinds of data.</p>
    <p>With generics, you can define an algorithm once, independently of any specific type of data, and then apply that algorithm to a wide variety of data types without any additional effort.</p>
    <h3>What are Generics?</h3>
    <p>At its core, the term generics means parameterized types.</p>
    <p>Parameterized types are important because they enable you to create classes, interfaces, and methods in which the type of data upon which they operate is specified as a parameter.</p>
    <p>A class, interface, or method that operates on a parameterized type is called generic, as in generic class or generic method.</p>
    <p>In pre-generics code, generalized classes, interfaces, and methods used Object references to operate on various types of objects. The problem was that they could not do so with type safety. Generics added the type safety that was lacking.</p>
    <p>With generics, all casts are automatic and implicit. Thus, generics expanded your ability to reuse code and let you do so safely and easily.</p>
    <div class="code">
        <mark>// Here, T is the name of a type parameter. This name is used as a placeholder for the actual type that will be passed to Gen when an object is created.</mark><br>
        class Gen&lt;T&gt; {
    </div>
    <p>Type safety: means that a program cannot perform an operation on an object unless that operation is valid for that object.</p>
    <h3>Erasure</h3>
    <p>The compiler removes all generic type information, substituting the necessary casts, to make your code behave as if a specific version of Gen were created.</p>
    <h3>Generics works only with Reference Types</h3>
    <p>When declaring an instance of a generic type, the type argument passed to the type parameter must be a reference type. You cannot use a primitive type, such as int or char.</p>
    <h3>Generic Types differ based on their Type Arguments</h3>
    <p>A key point to understand about generic types is that a reference of one specific version of a generic type is not type compatible with another version of the same generic type.</p>
    <h3>How Generics Improves Type Safety</h3>
    <p>Generics automatically ensure the type safety of all operations involving Gen. In the process, they eliminate the need for you to enter casts and to type-check code by hand.</p>
    <h3>Generic Class</h3>
    <div class="code">
        <mark>// General Form</mark><br>
        class class-name&lt;type-param-list&gt; { <mark>// ...</mark><br>
        <mark>// Full Syntax</mark><br>
        class-name&lt;type-arg-list&gt; var-name = new class-name&lt;type-arg-list&gt;(cons-arg-list);
    </div>
    <h3>Bounded Types</h3>
    <p>Sometimes it is useful to limit the types that can be passed to a type parameter.</p>
    <p>When specifying a type parameter, you can create an upper bound that declares the superclass from which all type arguments must be derived.</p>
    <p>This is accomplished through the use of an extends clause when specifying the type parameter.</p>
    <div class="code">
        <mark>// This specifies that T can only be replaced by superclass, or subclasses of superclass.</mark><br>
        &lt;T extends superclass&gt;<br>
        <mark>// Here, the type argument for T must be either Number, or a class derived from Number.</mark><br>
        class Stats&lt;T extends Number&gt; {
    </div>
    <p>When a bound includes an interface type, only type arguments that implement that interface are legal.</p>
    <p>When specifying a bound that has a class and an interface, or multiple interfaces, use the & operator to connect them.</p>
    <div class="code">
        <mark>// Here, T is bounded by a class called MyClass and an interface called MyInterface.</mark><br>
        class Gen&lt;T extends MyClass & MyInterface> { <mark>// ...</mark>
    </div>
    <p>Any type argument passed to T must be a subclass of MyClass and implement MyInterface.</p>
    <h3>Using Wildcard Arguments</h3>
    <p>The wildcard argument is specified by the ?, and it represents an unknown type.</p>
    <p>Assume that you want to add a method called sameAvg() that determines if two Stats objects contain arrays that yield the same average, no matter what type of numeric data each object holds.</p>
    <div class="code">
        <mark>// Determine if two averages are the same.</mark><br>
        <mark>// Here, Stats&lt;?&gt; matches any Stats object, allowing any two Stats objects to have their averages compared.</mark><br>
        boolean sameAvg(Stats&lt;?&gt; ob) {<br>
		&emsp;if(average() == ob.average())<br>
        &emsp;&emsp;return true;<br>
        &emsp;return false;<br>
	    }
    </div>
    <h3>Bounded Wildcards</h3>
    <p>A bounded wildcard is especially important when you are creating a generic type that will operate on a class hierarchy.</p>
    <p>In general, to establish an upper bound for a wildcard, use the following type of wildcard expression:</p>
    <div class="code">
		&lt;? extends superclass&gt;
    </div>
    <p>You can also specify a lower bound for a wildcard by adding a super clause to a wildcard declaration. Here is its general form:</p>
	<div class="code">
        &lt;? super subclass&gt;
    </div>
    <h3>Creating a Generic Method</h3>
    <p>Methods inside a generic class can make use of a class’ type parameter and are, therefore, automatically generic relative to the type parameter.</p>
    <p>However, it is possible to declare a generic method that uses one or more type parameters of its own.</p>
    <p>Furthermore, it is possible to create a generic method that is enclosed within a non-generic class.</p>
    <p>Here is the syntax for a generic method:</p>
    <div class="code">
        &lt;type-param-list&gt; ret-type meth-name (param-list) { <mark>// ...</mark>
    </div>
    <p>In all cases, type-param-list is a comma-separated list of type parameters.</p>
    <p>For a generic method, the type parameter list precedes the return type.</p>
    <h3>Generic Constructors</h3>
    <p>It is possible for constructors to be generic, even if their class is not.</p>
    <div class="code">
        class GenCons { <mark>// non-generic class</mark><br>
        &emsp;private double val;<br>
        &emsp;&lt;T extends Number&gt; GenCons(T arg) { <mark>// generic constructor</mark><br>
        &emsp;&emsp;val = arg.doubleValue();<br>
        &emsp;}<br>
        }<br><br>
        <div class="mainMethod">
            <br>GenCons test = new GenCons(100);<br>
            GenCons test2 = new GenCons(123.5F);
        </div>
    </div>
    <p>Because GenCons() specifies a parameter of a generic type, which must be a subclass of Number, GenCons() can be called with any numeric type, including Integer, Float, or Double.</p>
    <p>Therefore, even though GenCons is not a generic class, its constructor is generic.</p>
    <h3>Generic Interfaces</h3>
    <p>In addition to generic classes and methods, you can also have generic interfaces.</p>
    <div class="code">
        <mark>// A Min/Max interface.</mark><br>
        interface MinMax&lt;T extends Comparable&lt;T&gt;&gt; {<br>
        &emsp;T min();<br>
        &emsp;T max();<br>
        }
    </div>
    <p>In general, if a class implements a generic interface, then that class must also be generic, at least to the extent that it takes a type parameter that is passed to the interface.</p>
    <div class="code">
        <mark>// Generalized Syntax for a Generic Interface</mark><br>
        interface interface-name&lt;type-param-list&gt; { // …<br>
        <mark>// Here, type-param-list is a comma-separated list of type parameters.</mark>
    </div>
    <p>When a generic interface is implemented, you must specify the type arguments.</p>
    <div class="code">
        class class-name&lt;type-param-list&gt; implements interface-name&lt;type-arg-list&gt;
    </div>
    <h3>Raw Types and Legacy Code</h3>
    <p>To handle the transition to generics, Java allows a generic class to be used without any type arguments. This creates a raw type for the class.</p>
    <p>The main drawback to using the raw type is that the type safety of generics is lost.</p>
    <div class="code">
        <mark>// Create a raw-type Gen object and give it a Double value.</mark><br>
    Gen raw = new Gen(new Double(98.6));
    </div>
    <p>You should limit the use of raw types to those cases in which you must mix legacy code with newer, generic code.</p>
    <p>Raw types are simply a transitional feature and not something that should be used for new code.</p>
    <h3>Generic Class Hierarchies</h3>
    <p>Generic classes can be part of a class hierarchy in just the same way as a non-generic class.</p>
    <p>Thus, a generic class can act as a superclass or be a subclass.</p>
    <p>The key difference between generic and non-generic hierarchies is that in a generic hierarchy, any type arguments needed by a generic superclass must be passed up the hierarchy by all subclasses.</p>
    <div class="code">
        <mark>// A simple generic class hierarchy.</mark><br>
        class Gen&lt;T&gt; {<br>
        &emsp;T ob;<br>
        &emsp;Gen(T o) { ob = o; }<br>
        &emsp;<mark>// Return ob.</mark><br>
        &emsp;T getob() { return ob; }<br>
        }<br><br>

        <mark>// A subclass of Gen.</mark><br>
        class Gen2&lt;T&gt; extends Gen&lt;T&gt; {<br>
        &emsp;Gen2(T o) { super(o); }<br>
        }<br><br>

        <mark>// A subclass of Gen that defines a second type parameter, called V.</mark><br>
        class Gen2&lt;T, V&gt; extends Gen&lt;T&gt; {<br>
        &emsp;V ob2;<br>
        &emsp;Gen2(T o, V o2) { super(o); ob2 = o2; }<br>
        &emsp;<mark>// Return the second ob</mark><br>
        &emsp;V getob2() { return ob2; }<br>
        }<br><br>
        <div class="mainMethod">
            <br><mark>// Create a Gen2 object for String and Integer.</mark><br>
            Gen2&lt;String, Integer&gt; x = new Gen2&lt;String, Integer&gt;("Value is: ", 99);
        </div>
    </div>
    <h3>A Generic Subclass</h3>
    <p>It is perfectly acceptable for a non-generic class to be the superclass of a generic subclass.</p>
    <h3>Run-Time Type Comparisons Within a Generic Hierarchy</h3>
    <p>instanceof determines if an object is an instance of a class.</p>
    <p>The instanceof operator can be applied to objects of generic classes.</p>
    <p>It returns true if an object is of the specified type or can be cast to the specified type.</p>
    <h3>Casting</h3>
    <p>You can cast one instance of a generic class into another only if the two are otherwise compatible and their type arguments are the same.</p>
    <h3>Overriding Methods in a Generic Class</h3>
    <p>A method in a generic class can be overridden just like any other method.</p>
    <div class="code">
        class Gen2&lt;T&gt; extends Gen&lt;T&gt; {<br>
        &emsp;<mark>// Override getob() which exists in the parent class</mark><br>
        &emsp;T getob() {<br>
        &emsp;&emsp;System.out.print("Gen2's getob(): ");<br>
        &emsp;&emsp;return ob;<br>
        &emsp;}
        }
    </div>
    <h3>Type Inference with Generics</h3>
    <p>Beginning with JDK 7, it is possible to shorten the syntax used to create an instance of a generic type.</p>
    <div class="code">
        MyClass&lt;Integer, String&gt; mcOb = new MyClass&lt;Integer, String&gt;(98, "A String");<br>
        <mark>// Can be re-written as:</mark><br>
        MyClass&lt;Integer, String&gt; mcOb = new MyClass&lt;&gt;(98, "A String");
    </div>
    <p>Diamond Operator: <> is an empty type argument list.</p>
    <p>The principal advantage of this type-inference syntax is that it shortens what are sometimes quite long declaration statements.</p>
    <h3>Erasure</h3>
    <p>Any changes to the syntax of the Java language, or to the JVM, had to avoid breaking older code.</p>
    <p>The way Java implements generics while satisfying this constraint is through the use of erasure.</p>
    <p>When your Java code is compiled, all generic type information is removed (erased).</p>
    <p>This means replacing type parameters with their bound type, which is Object if no explicit bound is specified, and then applying the appropriate casts (as determined by the type arguments) to maintain type compatibility with the types specified by the type arguments.</p>
    <p>The compiler also enforces this type compatibility.</p>
    <p>This approach to generics means that no type parameters exist at run time.</p>
    <p>They are simply a source-code mechanism.</p>
    <h3>Bridge Methods</h3>
    <p>Occasionally, the compiler will need to add a bridge method to a class to handle situations in which the type erasure of an overriding method in a subclass does not produce the same erasure as the method in the superclass.</p>
    <p>In this case, a method is generated that uses the type erasure of the superclass, and this method calls the method that has the type erasure specified by the subclass.</p>
    <p>Bridge methods only occur at the bytecode level, are not seen by you, and are not available for your use.</p>
    <h3>Ambiguity Errors</h3>
    <p>The inclusion of generics gives rise to a new type of error that you must guard against: ambiguity.</p>
    <p>Ambiguity errors occur when erasure causes two seemingly distinct generic declarations to resolve to the same erased type, causing a conflict.</p>
    <div class="code">
        <mark>// These two overloaded methods are ambiguous and will not compile.</mark><br>
        void set(T o) {<br>
        &emsp;ob1 = o;<br>
        }<br><br>
        void set(V o) {<br>
        &emsp;ob2 = o;<br>
        }
    </div>
    <p>It is perfectly correct (in principle) to construct a MyGenClass object as shown here:</p>
    <div class="code">
        MyGenClass&lt;String, String&gt; obj = new MyGenClass&lt;String, String&gt;()
    </div>
    <p>In this case, both T and V will be replaced by String. This makes both versions of set() identical, which is, of course, an error.</p>
    <p>Often, the solution to ambiguity involves the restructuring of the code, because ambiguity frequently means that you have a conceptual error in your design.</p>
    <h3>Generic Restrictions</h3>
    <p>There are a few restrictions that you need to keep in mind when using generics.</p>
    <table>
        <tr>
            <th>Creating objects of a type parameter</th>
            <td>It is not possible to create an instance of a type parameter.</td>
        </tr>
        <tr>
            <th>Static members</th>
            <td>No static member can use a type parameter declared by the enclosing class.</td>
        </tr>
        <tr>
            <th>Exceptions</th>
            <td></td>
        </tr>
        <tr>
            <th>Arrays</th>
            <td></td>
        </tr>
    </table>
    <h3>Type Parameters Can’t Be Instantiated</h3>
    <p>It is not possible to create an instance of a type parameter.</p>
    <div class="code">
        <mark>// Can't create an instance of T.</mark><br>
        class Gen&lt;T&gt; {<br>
        &emsp;T ob;<br>
        &emsp;Gen() {<br>
        &emsp;&emsp;ob = new T(); <mark>// Illegal!!!</mark><br>
        &emsp;}<br>
        }
    </div>
    <p>The compiler does not know what type of object to create. T is simply a placeholder.</p>
    <h3>Restrictions on Static Members</h3>
    <p>No static member can use a type parameter declared by the enclosing class.</p>
    <h3>Generic Array Restrictions</h3>
    <p>There are two important generics restrictions that apply to arrays.</p>
    <p>First, you cannot instantiate an array whose element type is a type parameter.</p>
    <p>Second, you cannot create an array of type-specific generic references.</p>
    <div class="code">
        T vals[]; <mark>// OK</mark><br>
        vals = new T[10]; <mark>// can't create an array of T</mark>
    </div>
    <p>The reason you can’t create an array of T is that there is no way for the compiler to know what type of array to actually create.</p>
    <p>You can create an array of references to a generic type if you use a wildcard, however, as shown here:</p>
    <div class="code">
        Gen&lt;?&gt; gens[] = new Gen&lt;?&gt;[10]; <mark>// OK</mark>
    </div>
    <h3>Generic Exception Restriction</h3>
    <p>A generic class cannot extend Throwable. This means that you cannot create generic exception classes.</p>
</div>
&nbsp;
<button class="collapsible">Lambda Expressions</button>
<div class="content">
    <h2>Lambda Expressions</h2>
    <p>Added in JDK 8, Lambda Expressions significantly enhanced Java because of two primary reasons.</p>
    <ol>
        <li>They add new syntax elements that increase the expressive power of the language. In the process, they streamline the way that certain common constructs are implemented.</li>
        <li>The addition of lambda expressions resulted in new capabilities being incorporated into the API library.</li>
    </ol>
    <h3>Introducing Lambda Expressions</h3>
    <p>The key to understanding Java’s implementation of lambda expressions are two constructs.</p>
    <ol>
        <li>The first is the lambda expression itself.</li>
        <li>The second is the functional interface.</li>
    </ol>
    <p>A lambda expression is, essentially, an anonymous (that is, unnamed) method. However, this method is not executed on its own. Instead, it is used to implement a method defined by a functional interface. Thus, a lambda expression results in a form of anonymous class.</p>
    <p>Lambda expressions are also commonly referred to as closures.</p>
    <h3>Functional Interface</h3>
    <p>A functional interface is an interface that contains one and only one abstract method.</p>
    <p>Normally, this method specifies the intended purpose of the interface. Thus, a functional interface typically represents a single action.</p>
    <p>For example, the standard interface Runnable is a functional interface because it defines only one method: run().</p>
    <h3>Lambda Expression Fundamentals</h3>
    <p>"->" is known as the lambda operator or the arrow operator. This operator can be verbalized as "becomes" or "goes to".</p>
    <p>It divides a lambda expression into two parts.</p>
    <ul>
        <li>The left side specifies any parameters required by the lambda expression. (If no parameters are needed, an empty parameter list is used.)</li>
        <li>The right side is the lambda body, which specifies the actions of the lambda expression.</li>
    </ul>
    <button class="collapsible">Single Expression Lambdas</button>
    <div class="content">
        <h3>Lambdas that define a single expression</h3>
        <div class="code">
            <mark>// This lambda expression takes no parameter, thus the parameter list is empty.</mark><br>
            () -> 123.45 <mark>// Returns the constant value 123.45</mark><br>
            (n) -> (n % 2) == 0 <mark>// Returns true if the value of parameter n is even.</mark>
        </div>
        <p>The body of the lambdas shown in the preceding examples consist of a single expression. These types of lambda bodies are referred to as expression bodies or expression lambdas. In an expression body, the code on the right side of the lambda operator must consist of a single expression.</p>
        <p>When a lambda expression has only one parameter, it is not necessary to surround the parameter name with parentheses when it is specified on the left side of the lambda operator.</p>
        <div class="code">
            n -> (n % 2) == 0
        </div>
        <p>If you need to explicitly declare the type of a parameter, then all of the parameters must have declared types. For example, this is legal:</p>
        <div class="code">
            (int n, int d) -> (n % d) == 0
        </div>
    </div>
    &nbsp;
    <button class="collapsible">Block Lambda Expressions</button>
    <div class="content">
        <h3>Block Lambda Expressions</h3>
        <p>Lambdas that have block bodies are sometimes referred to as block lambdas.</p>
        <p>A block lambda is easy to create. Simply enclose the body within braces as you would any other block of statements.</p>
        <p>One key difference between single and block lambdas, however, is that you must explicitly use a return statement to return a value. This is necessary because a block lambda body does not represent a single expression.</p>
        <p>When a return statement occurs within a lambda expression, it simply causes a return from the lambda. It does not cause an enclosing method to return.</p>
        <div class="code">
            interface NumericFunc {<br>
            &emsp;int func(int n);<br>
            }<br><br>
            <div class="mainMethod">
                <br>
                <mark>// This block lambda computes the factorial of an int value.</mark><br>
            NumericFunc factorial = (n) -> {<br>
            &emsp;int result = 1;<br>
            &emsp;for(int i=1; i <= n; i++)<br>
            &emsp;&emsp;result = i * result;<br>
            &emsp;&emsp;return result;<br>
            };<br><br>
            System.out.println("The factorial of 3 is " + factorial.func(3));
            </div>
        </div>
    </div>
    &nbsp;
    <button class="collapsible">Functional Interfaces</button>
    <div class="content">
        <h3>Functional Interfaces</h3>
        <p>A functional interface is an interface that specifies only one abstract method.</p>
        <p>An interface method is abstract only if it does not specify a default implementation.</p>
        <p>Using Default Methods however, it is possible to specify the behaviour for a method declared in an interface.</p>
        <p>Non-default interface methods are implicitly abstract, so there is no need to use the abstract modifier (although you can specify it, if you like).</p>
        <div class="code">
        &emsp;interface MyNumber { <br>
        &emsp;&emsp;double getValue();<br>
        &emsp;}
        </div>
    </div>
    <p>A lambda expression forms the implementation of the abstract method defined by the functional interface that specifies its target type.</p>
    <p>As a result, a lambda expression can be specified only in a context in which a target type is defined.</p>
    <p>Target type contexts include variable initialization, return statements, and method arguments, to name a few.</p>
    <div class="code">
        <mark>// Create a reference to a MyNumber instance.</mark><br>
        MyNumber myNum;<br>
        <mark>// Use a lambda in an assignment context.</mark><br>
        myNum = () -> 123.45;<br>
    </div>
    <p>In general, the type and number of the lambda expression’s parameters must be compatible with the method’s parameters; the return types must be compatible; and any exceptions thrown by the lambda expression must be acceptable to the method.</p>
    <h3>Generic Functional Interfaces</h3>
    <p>A lambda expression, itself, cannot specify type parameters. Thus, a lambda expression cannot be generic. However, the functional interface associated with a lambda expression can be generic.</p>
    <p>Create a Generic Functional Interface:</p>
    <div class="code">
        &emsp;interface GenInt&lt;T&gt; {<br>
        &emsp;&emsp;T meth(T t);<br>
        &emsp;}
    </div>
    <p>Using your Generic Functional Interface:</p>
    <div class="code">
        GenInt&lt;Integer&gt; numGenInt = (i) -> {<br>
            &emsp;return i;<br>
        };<br><br>
        System.out.println("Number = " + numGenInt.meth(1234));
    </div>
    <h3>Passing Lambda Expressions as Arguments:</h3>
    <p>To pass a lambda expression as an argument, the type of the parameter receiving the lambda expression argument must be of a functional interface type compatible with the lambda.</p>
    <h3>Lambda Expressions and Exceptions</h3>
    <p>A lambda expression can throw an exception. However, if it throws a checked exception, then that exception must be compatible with the exception(s) listed in the throws clause of the abstract method in the functional interface.</p>
    <h3>Lambda Expressions and Variable Capture</h3>
    <p>Variables defined by the enclosing scope of a lambda expression are accessible within the lambda expression.</p>
    <p>Thus, a lambda expression can obtain or set the value of an instance or static variable and call a method defined by its enclosing class.</p>
    <p>When a lambda expression uses a local variable from its enclosing scope, a special situation is created that is referred to as a variable capture.</p>
    <p>A lambda expression may only use local variables that are effectively final. An effectively final variable is one whose value does not change after it is first assigned.</p>
    <p>It is important to understand that a local variable of the enclosing scope cannot be modified by the lambda expression. Doing so would remove its effectively final status, thus rendering it illegal for capture.</p>
    <p>It is important to emphasize that a lambda expression can use and modify an instance variable from its invoking class. It just can’t use a local variable of its enclosing scope unless that variable is effectively final.</p>
    <div class="code">
        interface MyFunc {<br>
        &emsp;int func(int n);<br>
        }<br><br>
        <div class="mainMethod">
        <br>
        <mark>// A final local variable that can be captured.</mark><br>
        final int num = 10;<br><br>
        <mark>// Block Lambda Expression</mark><br>
        MyFunc myLambda = (n) -> {<br>
        &emsp;int v = num + n; <mark>// This use of num is OK. It does not modify num.</mark><br>
        &emsp;num++; <mark>// Illegal, this attempts to change the value of num</mark><br>
        &emsp;return v;<br>
        }<br><br>
        num = 9; <mark>// Also Illegal, Removes the effectively final status of the variable</mark><br><br>
        <mark>// Print the results</mark><br>
        System.out.println(myLambda.func(num));
        </div>
    </div>
    <h3>Method References</h3>
    <p>A method reference provides a way to refer to a method without executing it.</p>
    <p>When evaluated, a method reference also creates an instance of the functional interface.</p>
    <p>Method References to Static Methods</p>
    <p>&emsp;ClassName::methodName</p>
    <p>The "::" is a new separator that has been added to Java by JDK 8.</p>
    <p>:: can be used for Static Methods, Non-static Methods and Constructors.</p>
    <p>This method reference can be used anywhere in which it is compatible with its target type.</p>
    <h3>Method References to Instance Methods</h3>
    <p>To pass a reference to an instance method on a specific object.</p>
    <div class="code">
        objRef::methodName
    </div>
    <p>It is also possible to handle a situation in which you want to specify an instance method that can be used with any object of a given class, not just a specified object. In this case, you will create a method reference as shown here:</p>
    <div class="code">
        ClassName::instanceMethodName
    </div>
    <p>Here, the name of the class is used instead of a specific object, even though an instance method is specified. With this form, the first parameter of the functional interface matches the invoking object and the second parameter matches the parameter specified by the method.</p>
    <h3>Method References with Generics</h3>
    <p>You can use method references with generic classes and/or generic methods.</p>
    <h3>Constructor References</h3>
    <p>Similar to the way that you can create references to methods, you can create references to constructors.</p>
    <div class="code">
        classname::new
    </div>
    <p>To create a constructor reference for an array, use this construct:</p>
    <div class="code">
        type[]::new
    </div>
    <h3>Predefined Functional Interfaces</h3>
    <p>java.util.function contains several predefined ones such as the Runnable Interface.</p>
</div>
&nbsp;
<button class="collapsible">Servlets</button>
<div class="content">
    <h3>Servlets</h3>
    <p>Servlets are the Java programs that runs on the Java-enabled web server or application server. They are used to handle the request obtained from the web server, process the request, produce the response, then send response back to the web server.</p>
    <h3>Execution of Servlets:</h3>
    <ol>
        <li>The clients send the request to the web server.</li>
        <li>The web server receives the request.</li>
        <li>The web server passes the request to the corresponding servlet.</li>
        <li>The servlet processes the request and generate the response in the form of output.</li>
        <li>The servlet sends the response back to the web server.</li>
        <li>The web server sends the response back to the client and the client browser displays it on the screen.</li>
    </ol>
    <h3>Servlet Architecture</h3>
    <div class="center"><img src="images/servlet-architecture.jpg" alt="Servlet Architecture Image"></div>
    <h3>Need For Server-Side Extensions</h3>
    <p>The server-side extensions are nothing but the technologies that are used to create dynamic Web pages. Web pages need a container or Web server to facilitate dynamic Web pages.</p>
    <h3>Servlet API's</h3>
    <p>Servlets are built from two packages:</p>
    <ul>
        <li>javax.servlet(Basic)</li>
        <li>javax.servlet.http(Advance)</li>
    </ul>
    <table>
        <tr>
            <th>Component</th>
            <th>Type</th>
            <th>Package</th>
        </tr>
        <tr>
            <td>Servlet</td>
            <td>Interface</td>
            <td>java.servlet.*</td>
        </tr>
        <tr>
            <td>ServletRequest</td>
            <td>Interface</td>
            <td>java.servlet.*</td>
        </tr>
        <tr>
            <td>ServletResponse</td>
            <td>Interface</td>
            <td>java.servlet.*</td>
        </tr>
        <tr>
            <td>GenericServlet</td>
            <td>Class</td>
            <td>java.servlet.*</td>
        </tr>
        <tr>
            <td>HttpServlet</td>
            <td>Class</td>
            <td>javax.servlet.http.*</td>
        </tr>
        <tr>
            <td>HttpServletRequest</td>
            <td>Interface</td>
            <td>javax.servlet.http.*</td>
        </tr>
        <tr>
            <td>HttpServletResponse</td>
            <td>Interface</td>
            <td>javax.servlet.http.*</td>
        </tr>
        <tr>
            <td>Filter</td>
            <td>Interface</td>
            <td>javax.servlet.*</td>
        </tr>
        <tr>
            <td>ServletConfig</td>
            <td>Interface</td>
            <td>javax.servlet.*</td>
        </tr>
    </table>
    <h3>Advantages of a Java Servlet</h3>
    <ul>
        <li>Servlet is faster than CGI as it does not involve the creation of a new process for every new request received.</li>
        <li>Servlets as written in Java are platform independent.</li>
        <li>Removes the overhead of creating a new process for each request as Servlet doesn’t run in a separate process. There is only a single instance which handles all requests concurrently. This also saves the memory and allows a Servlet to easily manage client state.</li>
        <li>It is a server-side component, so Servlet inherits the security provided by the Web server.</li>
        <li>The API designed for Java Servlet automatically acquires the advantages of Java platform such as platform independent and portability. In addition, it obviously can use the wide range of APIs created on Java platform such as JDBC to access the database.</li>
    </ul>
    <h3>The Servlet Container</h3>
    <p>Servlet container, also known as Servlet engine is an integrated set of objects that provide run time environment for Java Servlet components.</p>
    <p>In simple words, it is a system that manages Java Servlet components on top of the Web server to handle the Web client requests.</p>
    <p><b>Services provided by the Servlet container:</b></p>
    <ul>
        <li><b>Network Services:</b> Loads a Servlet class. The loading may be from a local file system, a remote file system or other network services. The Servlet container provides the network services over which the request and response are sent.</li>
        <li><b>Decode and Encode MIME based messages:</b> Provides the service of decoding and encoding MIME-based messages.</li>
        <li><b>Manage Servlet container:</b> Manages the lifecycle of a Servlet.</li>
        <li><b>Resource management:</b> Manages the static and dynamic resource, such as HTML files, Servlets and JSP pages.</li>
        <li><b>Security Service:</b> Handles authorization and authentication of resource access.</li>
        <li><b>Session Management:</b> Maintains a session by appending a session ID to the URL path.</li>
    </ul>
    <h3>Servlet Life Cycle</h3>
    <p>A servlet life cycle can be defined as the entire process from its creation till the destruction.</p>
    <ul>
        <li>The servlet is initialized by calling the init() method.</li>
        <li>The servlet calls service() method to process a client's request.</li>
        <li>The servlet is terminated by calling the destroy() method.</li>
        <li>Finally, servlet is garbage collected by the garbage collector of the JVM.</li>
    </ul>
    <h3>The init() Method</h3>
    <p>The init method is called only once. It is called only when the servlet is created, and not called for any user requests afterwards. So, it is used for one-time initializations, just as with the init method of applets.</p>
    <p>The servlet is normally created when a user first invokes a URL corresponding to the servlet, but you can also specify that the servlet be loaded when the server is first started.</p>
    <p>When a user invokes a servlet, a single instance of each servlet gets created, with each user request resulting in a new thread that is handed off to doGet or doPost as appropriate. The init() method simply creates or loads some data that will be used throughout the life of the servlet.</p>
    <div class="code">
        public void init() throws ServletException {<br>
        &emsp;<mark>// Initialization code...</mark><br>
        }
    </div>
    <h3>The service() Method</h3>
    <p>The service() method is the main method to perform the actual task. The servlet container (i.e. web server) calls the service() method to handle requests coming from the client( browsers) and to write the formatted response back to the client.</p>
    <p>Each time the server receives a request for a servlet, the server spawns a new thread and calls service. The service() method checks the HTTP request type (GET, POST, PUT, DELETE, etc.) and calls doGet, doPost, doPut, doDelete, etc. methods as appropriate.</p>
    <p>The service () method is called by the container and service method invokes doGet, doPost, doPut, doDelete, etc. methods as appropriate. So you have nothing to do with service() method but you override either doGet() or doPost() depending on what type of request you receive from the client.</p>
    <p>The doGet() and doPost() are most frequently used methods with in each service request. Here is the signature of these two methods.</p>
    <div class="code">
        public void service(ServletRequest request, ServletResponse response)<br>
        &emsp;throws ServletException, IOException {<br>
        }
    </div>
    <h3>GET Method</h3>
    <p>The GET method sends the encoded user information appended to the page request. The page and the encoded information are separated by the ? (question mark) symbol.</p>
    <div class="code">
        http://www.test.com/hello?key1 = value1&key2 = value2
    </div>
    <p>The GET method is the default method to pass information from browser to web server and it produces a long string that appears in your browser's Location:box. Never use the GET method if you have password or other sensitive information to pass to the server. The GET method has size limitation: only 1024 characters can be used in a request string.</p>
    <p>This information is passed using QUERY_STRING header and will be accessible through QUERY_STRING environment variable and Servlet handles this type of requests using doGet() method.</p>
    <h3>The doGet() Method</h3>
    <p>A GET request results from a normal request for a URL or from an HTML form that has no METHOD specified and it should be handled by doGet() method.</p>
    <div class="code">
        public void doGet(HttpServletRequest request, HttpServletResponse response)<br>
        &emsp;throws ServletException, IOException {<br>
        &emsp;<mark>// Servlet code</mark><br>
        }
    </div>
    <h3>POST Method</h3>
    <p>This packages the information in exactly the same way as GET method, but instead of sending it as a text string after a ? (question mark) in the URL it sends it as a separate message.</p>
    <p>his message comes to the backend program in the form of the standard input which you can parse and use for your processing. Servlet handles this type of requests using doPost() method.</p>
    <h3>The doPost() Method</h3>
    <p>A POST request results from an HTML form that specifically lists POST as the METHOD and it should be handled by doPost() method.</p>
    <div class="code">
        public void doPost(HttpServletRequest request, HttpServletResponse response)<br>
        &emsp;throws ServletException, IOException {<br>
        &emsp;<mark>// Servlet code</mark><br>
        }
    </div>
    <h3>The destroy() Method</h3>
    <p>The destroy() method is called only once at the end of the life cycle of a servlet. This method gives your servlet a chance to close database connections, halt background threads, write cookie lists or hit counts to disk, and perform other such cleanup activities.</p>
    <p>After the destroy() method is called, the servlet object is marked for garbage collection.</p>
    <div class="code">
        public void destroy() {<br>
        &emsp;<mark>// Finalization code...</mark><br>
        }
    </div>
    &nbsp;
    <button class="collapsible">HelloWorld Application</button>
    <div class="content">
        <h3>HelloWorld Application</h3>
        <p>Creating the HelloWorld Servlet</p>
        <ul>
            <li>Create a new Servlet</li>
            <li>Give it a class name of HelloWorld</li>
            <li>Next we can add URL mappings: The default that appears should be /HelloWorld (Same as Class Name)</li>
            <li>Next we select what methods we want to be generated by Eclipse</li>
            <li>Check: init, service and destroy (doGet and doPost are not necessary for this application)</li>
        </ul>
        <div class="code">
            @WebServlet(description = "Print Hello World in your Browser", urlPatterns = { "/HelloWorld" })<br>
            public class HelloWorld extends HttpServlet {<br>
            &emsp;private static final long serialVersionUID = 1L;<br><br>
            &emsp;public HelloWorld() {<br>
            &emsp;&emsp;super();<br>
            &emsp;}<br><br>
            &emsp;@Override<br>
            &emsp;public void destroy() {<br>
            &emsp;&emsp;System.out.println("this is the destroy method.");<br>
            &emsp;}<br><br>
            &emsp;@Override<br>
            &emsp;public void init(ServletConfig config) throws ServletException {<br>
            &emsp;&emsp;System.out.println("this is the init method.");<br>
            &emsp;}<br><br>
            &emsp;@Override<br>
            &emsp;protected void service(HttpServletRequest request, HttpServletResponse response)<br>
            &emsp;&emsp;&emsp;throws ServletException, IOException {<br>
            &emsp;&emsp;System.out.println("this is the service method.");<br><br>
            &emsp;&emsp;response.setContentType("text/html");<br>
            &emsp;&emsp;PrintWriter out = response.getWriter();<br>
            &emsp;&emsp;out.println("&lt;b&gt;Hello World!&lt;/b&gt;");<br>
            &emsp;}<br>
            }
        </div>
        <p>Example web.xml file with a welcome-file-list</p>
        <div class="code">
            &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>
            &lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" id="WebApp_ID" version="4.0"&gt;<br>
            &emsp;&lt;display-name>HelloWorld&lt;/display-name&gt;<br>
            &emsp;&lt;welcome-file-list&gt;<br>
            &emsp;&emsp;&lt;welcome-file&gt;index.html&lt;/welcome-file&gt;<br>
            &emsp;&emsp;&lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;<br>
            &emsp;&emsp;&lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;<br>
            &emsp;&emsp;&lt;welcome-file&gt;default.html&lt;/welcome-file&gt;<br>
            &emsp;&emsp;&lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;<br>
            &emsp;&emsp;&lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;<br>
            &emsp;&lt;/welcome-file-list&gt;<br>
            &lt;/web-app&gt;
        </div>
        <p>We can also provide the mapping inside our web.xml file instead of the annotation we have in our HelloWorld Servlet.</p>
        <div class="code">
            &lt;servlet&gt;<br>
            &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt;<br>
            &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt;<br>
            &lt;/servlet&gt;<br><br>
            &lt;servlet-mapping&gt;<br>
            &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt;<br>
            &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt;<br>
            &lt;/servlet-mapping&gt;
        </div>
        <p>After adding the project to our server and starting it up, we can go to localhost:8080/HelloWorld/HelloWorld</p>
        <p>We should now see "Hello World!" printed in the browser.</p>
    </div>
    <h3>Architecture Diagram</h3>
    <p>Example of a typical servlet life-cycle scenario.</p>
    <ul>
        <li>First the HTTP requests coming to the server are delegated to the servlet container.</li>
        <li>The servlet container loads the servlet before invoking the service() method.</li>
        <li>Then the servlet container handles multiple requests by spawning multiple threads, each thread executing the service() method of a single instance of the servlet.</li>
    </ul>
    <div class="center"><img src="images/servlet-lifecycle.jpg" alt="Servlet Lifecycle Image"></div>
    <br>
    <h3>Reading Form Data using Servlet</h3>
    <p>Servlets handles form data parsing automatically using the following methods depending on the situation.</p>
    <ul>
        <li><b>getParameter():</b> You call request.getParameter() method to get the value of a form parameter.</li>
        <li><b>getParameterValues():</b> Call this method if the parameter appears more than once and returns multiple values, for example checkbox.</li>
        <li><b>getParameterNames():</b> Call this method if you want a complete list of all parameters in the current request.</li>
    </ul>
    <p>note: http://www.phpform.org/ is a good resource for generating html forms with css and javascript.</p>
    <button class="collapsible">GET Method Example using URL</button>
    <div class="content">
        <p>Here is a simple URL which will pass two values to HelloForm program using GET method.</p>
        <b>http://localhost:8080/HelloForm?first_name = Austin&last_name = Krieger</b>
        <div class="code">
            public class HelloForm extends HttpServlet {<br><br>
            &emsp;public void doGet(HttpServletRequest request, HttpServletResponse response)<br>
            &emsp;&emsp;throws ServletException, IOException {<br><br>
            &emsp;&emsp;// Set response content type<br>
            &emsp;&emsp;response.setContentType("text/html");<br><br>
            &emsp;&emsp;PrintWriter out = response.getWriter();<br>
            &emsp;&emsp;String title = <mark>"Using GET Method to Read Form Data";</mark><br>
            &emsp;&emsp;String docType =<br>
            &emsp;&emsp;&emsp;<mark>"&lt;!doctype html public \"-//w3c//dtd html 4.0 " + "transitional//en\"&gt;\n";</mark><br><br>
            &emsp;&emsp;out.println(docType +<br>
            &emsp;&emsp;&emsp;<mark>"&lt;html&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;"&lt;head&gt;&lt;title&gt;" + title + "&lt;/title&gt;&lt;/head&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;"&lt;body bgcolor = \"#f0f0f0\"&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;"&lt;h1 align = \"center\"&gt;" + title + "&lt;/h1&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;"&lt;ul&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"  &lt;li&gt;&lt;b&gt;First Name&lt;/b&gt;: "<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;+ request.getParameter("first_name") + "\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"  &lt;li&gt;&lt;b&gt;Last Name&lt;/b&gt;: "<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;+ request.getParameter("last_name") + "\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;"&lt;/ul&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;"&lt;/body&gt;" +<br>
            &emsp;&emsp;&emsp;"&lt;/html&gt;"</mark><br>
            &emsp;&emsp;);<br>
            &emsp;}<br>
            }
        </div>
        <p>Add the mapping to your web.xml file</p>
        <div class="code">
            &lt;servlet&gt;<br>
            &lt;servlet-name&gt;HelloForm&lt;/servlet-name&gt;<br>
            &lt;servlet-class&gt;HelloForm&lt;/servlet-class&gt;<br>
            &lt;/servlet&gt;<br><br>
            &lt;servlet-mapping&gt;<br>
            &lt;servlet-name&gt;HelloForm&lt;/servlet-name&gt;<br>
            &lt;url-pattern&gt;/HelloForm&lt;/url-pattern&gt;<br>
            &lt;/servlet-mapping&gt;
        </div>
        <p>Lastly, add the application to your tomcat server and type in the url shown above.</p>
        <button class="collapsible">Applying an HTML Form</button>
        <div class="content">
            <p>Inside your WebContent folder, add a new html document. "Hello.htm"</p>
            <div class="code">
                &lt;html&gt;<br>
                &emsp;&lt;body&gt;<br>
                &emsp;&emsp;&lt;form action = "HelloForm" method = "GET"&gt;<br>
                &emsp;&emsp;&emsp;First Name: &lt;input type = "text" name = "first_name"&gt;<br>
                &emsp;&emsp;&emsp;&lt;br /&gt;<br>
                &emsp;&emsp;&emsp;Last Name: &lt;input type = "text" name = "last_name" /&gt;<br>
                &emsp;&emsp;&emsp;&lt;input type = "submit" value = "Submit" /&gt;<br>
                &emsp;&emsp;&lt;/form&gt;<br>
                &emsp;&lt;/body&gt;<br>
                &lt;/html&gt;
            </div>
        </div>
    </div>
    &nbsp;
    <button class="collapsible">POST Method Example using Form</button>
    <div class="content">
        <p>For this example we need only change the form action to POST and call doGet() from the doPost Method.</p>
        <div class="code">
            <mark>// Method to handle POST method request.</mark><br>
            public void doPost(HttpServletRequest request, HttpServletResponse response)<br>
            &emsp;throws ServletException, IOException {<br><br>
            &emsp;doGet(request, response);<br>
            }
        </div>
        <div class="code">
            &lt;html&gt;<br>
            &emsp;&lt;body&gt;<br>
            &emsp;&emsp;&lt;form action = "HelloForm" method = "POST"&gt;<br>
            &emsp;&emsp;&emsp;First Name: &lt;input type = "text" name = "first_name"&gt;<br>
            &emsp;&emsp;&emsp;&lt;br /&gt;<br>
            &emsp;&emsp;&emsp;Last Name: &lt;input type = "text" name = "last_name" /&gt;<br>
            &emsp;&emsp;&emsp;&lt;input type = "submit" value = "Submit" /&gt;<br>
            &emsp;&emsp;&lt;/form&gt;<br>
            &emsp;&lt;/body&gt;<br>
            &lt;/html&gt;
        </div>
    </div>
    &nbsp;
    <button class="collapsible">Passing Checkbox Data to Servlet</button>
    <div class="content">
        <div class="code">
            &lt;html&gt;<br>
            &emsp;&lt;body&gt;<br>
            &emsp;&emsp;&lt;form action = "CheckBox" method = "POST" target = "_blank"&gt;<br>
            &emsp;&emsp;&emsp;&lt;input type = "checkbox" name = "maths" checked = "checked" /&gt; Maths<br>
            &emsp;&emsp;&emsp;&lt;input type = "checkbox" name = "physics"  /&gt; Physics<br>
            &emsp;&emsp;&emsp;&lt;input type = "checkbox" name = "chemistry" checked = "checked" /&gt; Chemistry<br>
            &emsp;&emsp;&emsp;&lt;input type = "submit" value = "Select Subject" /&gt;<br>
            &emsp;&emsp;&lt;/form&gt;<br>
            &emsp;&lt;/body&gt;<br>
            &lt;/html&gt;
        </div>
        <div class="code">
            public class CheckBox extends HttpServlet {<br><br>
            &emsp;public void doGet(HttpServletRequest request, HttpServletResponse response)<br>
            &emsp;&emsp;throws ServletException, IOException {<br><br>
            &emsp;&emsp;// Set response content type<br>
            &emsp;&emsp;response.setContentType("text/html");<br><br>
            &emsp;&emsp;PrintWriter out = response.getWriter();<br>
            &emsp;&emsp;String title = <mark>"Reading Checkbox Data";</mark><br>
            &emsp;&emsp;String docType =<br>
            &emsp;&emsp;&emsp;<mark>"&lt;!doctype html public \"-//w3c//dtd html 4.0 " + "transitional//en\"&gt;\n";</mark><br><br>
            &emsp;&emsp;out.println(docType +<br>
            &emsp;&emsp;&emsp;<mark>"&lt;html&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;"&lt;head&gt;&lt;title&gt;" + title + "&lt;/title&gt;&lt;/head&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;"&lt;body bgcolor = \"#f0f0f0\"&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;"&lt;h1 align = \"center\"&gt;" + title + "&lt;/h1&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;"&lt;ul&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"  &lt;li&gt;&lt;b&gt;Maths Flag&lt;/b&gt;: "<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;+ request.getParameter("maths") + "\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"  &lt;li&gt;&lt;b&gt;Physics Flag&lt;/b&gt;: "<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;+ request.getParameter("physics") + "\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"  &lt;li&gt;&lt;b&gt;Chemistry Flag&lt;/b&gt;: "<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;+ request.getParameter("chemistry") + "\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;"&lt;/ul&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;"&lt;/body&gt;" +<br>
            &emsp;&emsp;&emsp;"&lt;/html&gt;"</mark><br>
            &emsp;&emsp;);<br>
            &emsp;}<br>
            }<br><br>
            <mark>// Method to handle POST method request.</mark><br>
            public void doPost(HttpServletRequest request, HttpServletResponse response)<br>
            &emsp;throws ServletException, IOException {<br><br>
            &emsp;doGet(request, response);<br>
            }
        </div>
    </div>
    &nbsp;
    <button class="collapsible">Reading All Form Parameters</button>
    <div class="content">
        <p>Following is the generic example which uses getParameterNames() method of HttpServletRequest to read all the available form parameters. This method returns an Enumeration that contains the parameter names in an unspecified order</p>
        <p>Once we have an Enumeration, we can loop down the Enumeration in standard way by, using hasMoreElements() method to determine when to stop and using nextElement() method to get each parameter name.</p>
        <div class="code">
            public class ReadParams extends HttpServlet {<br><br>
            &emsp;public void doGet(HttpServletRequest request, HttpServletResponse response)<br>
            &emsp;&emsp;throws ServletException, IOException {<br><br>
            &emsp;&emsp;// Set response content type<br>
            &emsp;&emsp;response.setContentType("text/html");<br><br>
            &emsp;&emsp;PrintWriter out = response.getWriter();<br>
            &emsp;&emsp;String title = <mark>"Reading All Form Parameters";</mark><br>
            &emsp;&emsp;String docType =<br>
            &emsp;&emsp;&emsp;<mark>"&lt;!doctype html public \"-//w3c//dtd html 4.0 " + "transitional//en\"&gt;\n";</mark><br><br>
            &emsp;&emsp;out.println(docType +<br>
            &emsp;&emsp;&emsp;<mark>"&lt;html&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;"&lt;head&gt;&lt;title&gt;" + title + "&lt;/title&gt;&lt;/head&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;"&lt;body bgcolor = \"#f0f0f0\"&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;"&lt;h1 align = \"center\"&gt;" + title + "&lt;/h1&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;"&lt;table width = \"100%\" border = \"1\" align = \"center\"&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;"&lt;tr bgcolor = \"#949494\"&gt;\n" +<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"&lt;th&gt;Param Name&lt;/th&gt;"<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"&lt;th&gt;Param Value(s)&lt;/th&gt;\n"+<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;"&lt;/tr&gt;\n"<br></mark>
            &emsp;&emsp;);<br><br>
            &emsp;&emsp;Enumeration paramNames = request.getParameterNames();<br><br>
            &emsp;&emsp;While(paramNames.hasMoreElements()) {<br>
            &emsp;&emsp;&emsp;String paramName = (String)paramNames.nextElement();<br>
            &emsp;&emsp;&emsp;out.print("&lt;tr&gt;&lt;td&gt;" + paramName + "&lt;/td&gt;\n&lt;td&gt;");<br>
            &emsp;&emsp;&emsp;String[] paramValues = request.getParameterValues(paramName);<br><br>
            &emsp;&emsp;&emsp;&emsp;<mark>// Read single valued data</mark><br>
            &emsp;&emsp;&emsp;&emsp;if (paramValues.length == 1) {<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;String paramValue = paramValues[0];<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;if (paramValue.length() == 0)<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;out.println("&lt;i&gt;No Value&lt;/i&gt;");<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;else<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;out.println(paramValue);<br>
            &emsp;&emsp;&emsp;&emsp;} else {<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;<mark>// Read multiple valued data</mark><br>
            &emsp;&emsp;&emsp;&emsp;&emsp;out.println("&lt;ul&gt;");<br><br>
            &emsp;&emsp;&emsp;&emsp;&emsp;for(int i = 0; i < paramValues.length; i++) {<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;out.println("&lt;li&gt;" + paramValues[i]);<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;}<br>
            &emsp;&emsp;&emsp;&emsp;&emsp;out.println("&lt;/ul&gt;");<br>
            &emsp;&emsp;&emsp;&emsp;}<br>
            &emsp;&emsp;&emsp;}<br>
            &emsp;&emsp;&emsp;out.println("&lt;/tr&gt;\n&lt;/table&gt;\n&lt;/body&gt;&lt;/html&gt;");<br>
            &emsp;&emsp;}<br><br>
            <mark>// Method to handle POST method request.</mark><br>
            public void doPost(HttpServletRequest request, HttpServletResponse response)<br>
            &emsp;throws ServletException, IOException {<br><br>
            &emsp;doGet(request, response);<br>
            }
        </div>
        <p>Now apply the form from the previous example:</p>
        <div class="code">
            &lt;html&gt;<br>
            &emsp;&lt;body&gt;<br>
            &emsp;&emsp;&lt;form action = "CheckBox" method = "POST" target = "_blank"&gt;<br>
            &emsp;&emsp;&emsp;&lt;input type = "checkbox" name = "maths" checked = "checked" /&gt; Maths<br>
            &emsp;&emsp;&emsp;&lt;input type = "checkbox" name = "physics"  /&gt; Physics<br>
            &emsp;&emsp;&emsp;&lt;input type = "checkbox" name = "chemistry" checked = "checked" /&gt; Chemistry<br>
            &emsp;&emsp;&emsp;&lt;input type = "submit" value = "Select Subject" /&gt;<br>
            &emsp;&emsp;&lt;/form&gt;<br>
            &emsp;&lt;/body&gt;<br>
            &lt;/html&gt;
        </div>
    </div>
</div>
&nbsp;
<button class="collapsible">JDBC (API), Hibernate and ORM Frameworks</button>
<div class="content">
    <button class="collapsible">Hibernate</button>
    <div class="content">
    <button class="collapsible">About</button>
    <div class="content">
    <h3>What is Hibernate?</h3>
    <p>Hibernate is an open-source and lightweight <b>ORM</b> tool that is used to store, manipulate, and retrieve data from a database.</p>
    <h3>What is ORM?</h3>
    <p>ORM is an acronym for Object/Relational mapping. It is a programming strategy to map objects with the data stored in the database. It simplifies data creation, manipulation and access.</p>
    <h3>What is JPA?</h3>
    <p>Java Persistence API (JPA) is a java specification that provides certain functionality and standards to ORM tools. The javax.persistence package contains the JPA classes and interfaces.</p>
    <h3>Hibernate Architecture</h3>
    <div class="center"><img src="images/hibernate-architecture.jpg" alt="Hibernate Architecture"></div>
    <p>Hibernate architecture comprises of many interfaces.</p>
    <ul>
        <li>Configuration</li>
        <li>SessionFactory</li>
        <li>Session</li>
        <li>Query</li>
        <li>Criteria</li>
        <li>Transaction</li>
    </ul>
    <h3>SessionFactory</h3>
    <p>The SessionFactory is a factory of sessions and clients of the ConnectionProvider. The org.hibernate.SessionFactory interface provides factory method to get the Session object.</p>
    <h3>Session</h3>
    <ul>
        <li>The Session object provides an interface between the application and the data stored in the database.</li>
        <li>It is a short-lived object and wraps the JDBC connection.</li>
        <li>It is a factory of Transaction, Query and Criteria.</li>
        <li>It holds a first-level cache of data.</li>
        <li>The org.hibernate.Session interface provides methods to insert, update and delete the object. It also provides factory methods for Transaction, Query and Criteria.</li>
    </ul>
    <h3>Transaction</h3>
    <p>The transaction object specifies the atomic unit of work. It is optional. The org.hibernate.Transaction interface provides methods for transaction management.</p>
    <h3>ConnectionProvider</h3>
    <p>It is a factory of JDBC connections. It abstracts the application from DriverManager or DataSource. It is optional.</p>
    <h3>TransactionFactory</h3>
    <p>It is a factory of Transaction. It is optional.</p>
    </div>
    &nbsp;
    <button class="collapsible">Hibernate Example</button>
    <div class="content">
        <ol>
            <li>Load the Dependencies (jar files).</li>
            <li>Create the Persistent class.</li>
            <li>Create the mapping file for Persistent class.</li>
            <li>Create the Configuration file.</li>
            <li>Create the class that retrieves or stores the persistent object.</li>
            <li>Run the application.</li>
        </ol>
        <h3>Create a new Maven Project "Hibernate Example"</h3>
        <p>Once the project is created open the pom.xml file and add the necessary dependencies.</p>
        <button class="collapsible">POM File</button>
        <div class="content">
        <div class="code">
            &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br>
            &emsp;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br>
            &emsp;&lt;groupId&gt;com.training.maven&lt;/groupId&gt;<br>
            &emsp;&lt;artifactId&gt;HibernateExample&lt;/artifactId&gt;<br>
            &emsp;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br><br>
            &emsp;&lt;dependencies&gt;<br>
            &emsp;&emsp;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;<br>
            &emsp;&emsp;&lt;dependency&gt;<br>
            &emsp;&emsp;&emsp;&lt;groupId&gt;mysql&lt;/groupId&gt;<br>
            &emsp;&emsp;&emsp;&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>
            &emsp;&emsp;&emsp;&lt;version&gt;8.0.16&lt;/version&gt;<br>
            &emsp;&emsp;&lt;/dependency&gt;<br><br>
            &emsp;&emsp;&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt;<br>
            &emsp;&emsp;&lt;dependency&gt;<br>
            &emsp;&emsp;&emsp;&lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br>
            &emsp;&emsp;&emsp;&lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;<br>
            &emsp;&emsp;&emsp;&lt;version&gt;5.4.3.Final&lt;/version&gt;<br>
            &emsp;&emsp;&lt;/dependency&gt;<br>
            &emsp;&lt;/dependencies&gt;<br>
            &lt;/project&gt;
        </div>
        </div>
        <h3>Create the Persistent class</h3>
        <p>A simple Persistent class should follow some rules:</p>
        <ul>
            <li>A no-arg constructor: It is recommended that you have a default constructor with at least package visibility so that hibernate can create the instance of the Persistent class by newInstance() method.</li>
            <li>Provide an identifier property: It is better to assign an attribute as id. This attribute behaves as a primary key in database.</li>
            <li>Declare getter and setter methods: Hibernate recognizes the method by getter and setter method names by default.</li>
            <li>Prefer non-final class: Hibernate uses the concept of proxies, that depends on the persistent class. The application programmer will not be able to use proxies for lazy association fetching.</li>
        </ul>
        <button class="collapsible">User Class</button>
        <div class="content">
        <div class="code">
            public class User {<br><br>
            &emsp;private int userID;<br>
            &emsp;private String firstName;<br>
            &emsp;private String lastName;<br><br>
            &emsp;public int getId() {<br>
            &emsp;&emsp;return id;<br>
            &emsp;}<br><br>
            &emsp;public void setId(int id) {<br>
            &emsp;&emsp;this.id = id;<br>
            &emsp;}<br><br>
            &emsp;public String getFirstName() {<br>
            &emsp;&emsp;return firstName;<br>
            &emsp;}<br><br>
            &emsp;public void setFirstName(String firstName) {<br>
            &emsp;&emsp;this.firstName = firstName;<br>
            &emsp;}<br><br>
            &emsp;public String getLastName() {<br>
            &emsp;&emsp;return lastName;<br>
            &emsp;}<br><br>
            &emsp;public void setLastName(String lastName) {<br>
            &emsp;&emsp;this.lastName = lastName;<br>
            &emsp;}<br>
            }
        </div>
        </div>
        <h3>Create the mapping file for Persistent class</h3>
        <p>The mapping file name conventionally, should be class_name.hbm.xml. There are many elements of the mapping file.</p>
        <ul>
            <li>hibernate-mapping: It is the root element in the mapping file that contains all the mapping elements.</li>
            <li>class: It is the sub-element of the hibernate-mapping element. It specifies the Persistent class.</li>
            <li>id: It is the sub-element of class. It specifies the primary key attribute in the class.</li>
            <li>generator: It is the sub-element of id. It is used to generate the primary key. There are many generator classes such as assigned, increment, hilo, sequence, native etc. We will learn all the generator classes later.</li>
            <li>property: It is the sub-element of class that specifies the property name of the Persistent class.</li>
        </ul>
        <button class="collapsible">XML Based</button>
        <div class="content">
        <div class="code">
            &lt;?xml version="1.0"?&gt;<br>
            &lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"<br>
            "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;<br>
            &lt;hibernate-mapping&gt;<br>
            &emsp;&lt;class name="com.training.hibernate.model.User" table="users"&gt;<br>
            &emsp;&emsp;<mark>&lt;!-- userID is getting mapped to the database column name UserID --&gt;</mark><br>
            &emsp;&emsp;&lt;id name="userID" type="int"&gt;<br>
            &emsp;&emsp;&emsp;&lt;column name="UserID" /&gt;<br>
            &emsp;&emsp;&emsp;&lt;generator class="assigned" /&gt;<br>
            &emsp;&emsp;&lt;/id&gt;<br><br>
            &emsp;&emsp;&lt;property name="firstName" type="java.lang.String"&gt;<br>
            &emsp;&emsp;&emsp;&lt;column name="FirstName" /&gt;<br>
            &emsp;&emsp;&lt;/property&gt;<br><br>
            &emsp;&emsp;&lt;property name="lastName" type="java.lang.String"&gt;<br>
            &emsp;&emsp;&emsp;&lt;column name="LastName" /&gt;<br>
            &emsp;&emsp;&lt;/property&gt;<br><br>
            &emsp;&lt;/class&gt;<br>
            &lt;/hibernate-mapping&gt;
        </div>
        </div>
        &nbsp;
        <button class="collapsible">Annotation Based</button>
        <div class="content">
            <div class="code">
                @Entity <mark>// Defines that this Class can be mapped to a table</mark><br>
                @Table(name = "users") <mark>// User class should connect to the users table in the database</mark><br>
                public class User {<br><br>
                &emsp;@Id <mark>// maps the primary key</mark><br>
                &emsp;@GeneratedValue(strategy = GenerationType.IDENTITY)<mark>// auto_increment the user id</mark><br>
                &emsp;@Column(name = "UserID") <mark>// name should match the column name in the database</mark><br>
                &emsp;private int userID;<br>
                &emsp;@Column(name = "FirstName")<br>
                &emsp;private String firstName;<br>
                &emsp;@Column(name = "UserID")<br>
                &emsp;private String LastName;<br><br>
                &emsp;public int getId() {<br>
                &emsp;&emsp;return id;<br>
                &emsp;}<br><br>
                &emsp;public void setId(int id) {<br>
                &emsp;&emsp;this.id = id;<br>
                &emsp;}<br><br>
                &emsp;public String getFirstName() {<br>
                &emsp;&emsp;return firstName;<br>
                &emsp;}<br><br>
                &emsp;public void setFirstName(String firstName) {<br>
                &emsp;&emsp;this.firstName = firstName;<br>
                &emsp;}<br><br>
                &emsp;public String getLastName() {<br>
                &emsp;&emsp;return lastName;<br>
                &emsp;}<br><br>
                &emsp;public void setLastName(String lastName) {<br>
                &emsp;&emsp;this.lastName = lastName;<br>
                &emsp;}<br><br>
                &emsp;<mark>// You need a no-argument constructor because Hibernate creates proxy objects</mark><br>
                &emsp;public User() {<br>
                &emsp;}<br>
                }
            </div>
        </div>
        <h3>Create the Configuration file</h3>
        <p>The configuration file contains information about the database and mapping file. Conventionally, its name should be hibernate.cfg.xml</p>
        <button class="collapsible">Configuration File</button>
        <div class="content">
            <div class="code">
            &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>
            &lt;!DOCTYPE hibernate-configuration PUBLIC<br>
            "-//Hibernate/Hibernate Configuration DTD 3.0//EN"<br>
            "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;<br><br>
            &lt;hibernate-configuration&gt;<br>
            &emsp;&lt;session-factory&gt;<br>
                &emsp;&emsp;<mark>&lt;!-- Database connection settings --&gt;</mark><br>
                &emsp;&emsp;&lt;property name = "connection.driver_class"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;<br>
                &emsp;&emsp;&lt;property name = "connection.url"&gt;jdbc:mysql://localhost:3306/interview?serverTimezone=UTC&lt;/property&gt;<br>
                &emsp;&emsp;&lt;property name = "connection.username"&gt;root&lt;/property&gt;<br>
                &emsp;&emsp;&lt;property name = "connection.password"&gt;root&lt;/property&gt;<br><br>
                &emsp;&emsp;<mark>&lt;!-- JDBC connection pool (use the built-in) --&gt;</mark><br>
                &emsp;&emsp;&lt;property name="connection.pool_size"&gt;10&lt;/property&gt;<br><br>
                &emsp;&emsp;<mark>&lt;!-- SQL dialect --&gt;</mark><br>
                &emsp;&emsp;&lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;<br><br>
                &emsp;&emsp;<mark>&lt;!-- Enable Hibernate's automatic session context management --&gt;</mark><br>
                &emsp;&emsp;&lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;<br><br>
                &emsp;&emsp;<mark>&lt;!-- Disable the second-level cache --&gt;</mark><br>
                &emsp;&emsp;&lt;property name="cache.provider_class"&gt;org.hibernate.cache.internal.NoCacheProvider&lt;/property&gt;<br><br>
                &emsp;&emsp;<mark>&lt;!-- Echo all executed SQL to stdout make false in production --&gt;</mark><br>
                &emsp;&emsp;&lt;property name="show_sql"&gt;true&lt;/property&gt;<br><br>
                &emsp;&emsp;&lt;mapping resource="User.hbm.xml" /&gt;<br>
                &emsp;&lt;/session-factory&gt;<br>
            &lt;/hibernate-configuration&gt;
            </div>
        </div>
        <h3>Create the utility class that opens sessions</h3>
        <p>For code reuse purposes we can separate our session factory from the main class.</p>
        <button class="collapsible">XML Based</button>
        <div class="content">
        <div class="code">
            public class HibernateUtility {<br>
            &emsp;<mark>// Get service registry</mark><br>
            &emsp;<mark>// Get meta data</mark><br>
            &emsp;<mark>// Get session factory</mark><br>
            &emsp;<mark>// Open the session</mark><br><br>
            &emsp;public SessionFactory sessionFactory;<br><br>
            &emsp;private Metadata getMetadata() {<br>
            &emsp;&emsp;return new MetadataSources(getServiceRegistry()).buildMetadata();<br>
            &emsp;}<br><br>
            &emsp;private ServiceRegistry getServiceRegistry() {<br>
            &emsp;&emsp;<mark>// Specify the file name:</mark><br>
            &emsp;&emsp;<mark>// return new StandardServiceRegistryBuilder().configure("hibernate.cfg.xml").build();</mark><br>
            &emsp;&emsp;<mark>// Search for the file:</mark><br>
            &emsp;&emsp;return new StandardServiceRegistryBuilder().configure().build();<br>
            &emsp;}<br><br>
            &emsp;public Session getSession() {<br>
            &emsp;&emsp;if (this.sessionFactory == null) {<br>
            &emsp;&emsp;&emsp;getSessionFactory();<br>
            &emsp;&emsp;}<br><br>
            &emsp;&emsp;return this.sessionFactory.openSession();<br>
            &emsp;}<br><br>
            &emsp;private void getSessionFactory() {<br>
            &emsp;&emsp;this.sessionFactory = getMetadata().buildSessionFactory();<br>
            &emsp;}<br>
            }
        </div>
        </div>
        &nbsp;
        <button class="collapsible">Annotation Based</button>
        <div class="content">
            <div class="code">
                public class HibernateUtility {<br>
                &emsp;<mark>// Get service registry</mark><br>
                &emsp;<mark>// Get meta data</mark><br>
                &emsp;<mark>// Get session factory</mark><br>
                &emsp;<mark>// Open the session</mark><br><br>
                &emsp;public SessionFactory sessionFactory;<br><br>
                &emsp;private Metadata getMetadata() {<br>
                &emsp;&emsp;<mark>// Specify the mapping class</mark><br>
                &emsp;&emsp;return new MetadataSources(getServiceRegistry()).addAnnotatedClass(User.class).buildMetadata();<br>
                &emsp;}<br><br>
                &emsp;private ServiceRegistry getServiceRegistry() {<br>
                &emsp;&emsp;<mark>// With this we no longer need hibernate.cfg.xml file</mark><br>
                &emsp;&emsp;StandardServiceRegistryBuilder serviceRegistryBuilder = new StandardServiceRegistryBuilder();<br>
                &emsp;&emsp;Map&lt;String, String&gt; settings = new HashMap();<br>
                &emsp;&emsp;settings.put("hibernate.connection.driver_class", "com.mysql.cj.jdbc.Driver");<br>
                &emsp;&emsp;settings.put("hibernate.connection.url", "jdbc:mysql://localhost:3306/interview?serverTimezone=UTC");<br>
                &emsp;&emsp;settings.put("hibernate.connection.username", "root");<br>
                &emsp;&emsp;settings.put("hibernate.connection.password", "root");<br>
                &emsp;&emsp;settings.put("hibernate.connection.show_sql", "true");<br>
                &emsp;&emsp;settings.put("hibernate.connection.hbm2ddl.auto", "update");<br>
                &emsp;&emsp;serviceRegistryBuilder.applySettings(settings);<br><br>
                &emsp;&emsp;return serviceRegistryBuilder.build();
                &emsp;}<br><br>
                &emsp;public Session getSession() {<br>
                &emsp;&emsp;if (this.sessionFactory == null) {<br>
                &emsp;&emsp;&emsp;getSessionFactory();<br>
                &emsp;&emsp;}<br><br>
                &emsp;&emsp;return this.sessionFactory.openSession();<br>
                &emsp;}<br><br>
                &emsp;private void getSessionFactory() {<br>
                &emsp;&emsp;this.sessionFactory = getMetadata().buildSessionFactory();<br>
                &emsp;}<br>
                }
            </div>
        </div>
        &nbsp;
        <button class="collapsible">Annotation Based (With Log Interceptor)</button>
        <div class="content">
            <div class="code">
                public class HibernateUtility {<br>
                &emsp;<mark>// Get service registry</mark><br>
                &emsp;<mark>// Get meta data</mark><br>
                &emsp;<mark>// Get session factory</mark><br>
                &emsp;<mark>// Open the session</mark><br><br>
                &emsp;public SessionFactory sessionFactory;<br><br>
                &emsp;private Metadata getMetadata() {<br>
                &emsp;&emsp;<mark>// Specify the mapping class</mark><br>
                &emsp;&emsp;return new MetadataSources(getServiceRegistry()).addAnnotatedClass(User.class).buildMetadata();<br>
                &emsp;}<br><br>
                &emsp;private ServiceRegistry getServiceRegistry() {<br>
                &emsp;&emsp;<mark>// With this we no longer need hibernate.cfg.xml file</mark><br>
                &emsp;&emsp;StandardServiceRegistryBuilder serviceRegistryBuilder = new StandardServiceRegistryBuilder();<br>
                &emsp;&emsp;Map&lt;String, String&gt; settings = new HashMap();<br>
                &emsp;&emsp;settings.put("hibernate.connection.driver_class", "com.mysql.cj.jdbc.Driver");<br>
                &emsp;&emsp;settings.put("hibernate.connection.url", "jdbc:mysql://localhost:3306/interview?serverTimezone=UTC");<br>
                &emsp;&emsp;settings.put("hibernate.connection.username", "root");<br>
                &emsp;&emsp;settings.put("hibernate.connection.password", "root");<br>
                &emsp;&emsp;settings.put("hibernate.connection.show_sql", "true");<br>
                &emsp;&emsp;settings.put("hibernate.connection.hbm2ddl.auto", "update");<br>
                &emsp;&emsp;serviceRegistryBuilder.applySettings(settings);<br><br>
                &emsp;&emsp;return serviceRegistryBuilder.build();
                &emsp;}<br><br>
                &emsp;public Session getSession() {<br>
                &emsp;&emsp;if (this.sessionFactory == null) {<br>
                &emsp;&emsp;&emsp;getSessionFactory();<br>
                &emsp;&emsp;}<br><br>
                &emsp;&emsp;<mark>// Apply interceptor to a particular session</mark><br>
                &emsp;&emsp;return this.sessionFactory.withOptions().interceptor(new LogInterceptor()).openSession();<br>
                &emsp;}<br><br>
                &emsp;private void getSessionFactory() {<br>
                &emsp;&emsp;<mark>// Apply interceptor to all sessions</mark><br>
                &emsp;&emsp;this.sessionFactory = getMetadata().getSessionFactoryBuilder().applyInterceptor(new LogInterceptor()).build();<br>
                &emsp;}<br>
                }
            </div>
        </div>
        <h3>Create the class that retrieves or stores the object</h3>
        <p>In this class, we are simply storing the user object to the database</p>
        <button class="collapsible">MainProgram Class</button>
        <div class="content">
            <div class="code">
            public class MainProgram {<br>
            &emsp;public static void main(String[] args) {<br><br>
            &emsp;&emsp;<mark>// Access our SessionFactory methods</mark><br>
            &emsp;&emsp;HibernateUtility util = new HibernateUtility();<br>
            &emsp;&emsp;<mark>// Open a new Session</mark><br>
            &emsp;&emsp;Session session = util.getSession();<br>
            &emsp;&emsp;<mark>// Begin a transaction that can rollback our changes if something goes wrong</mark><br>
            &emsp;&emsp;Transaction tx = session.beginTransaction();<br><br>
            &emsp;&emsp;<mark>// Create new User object, enter the transient state</mark><br>
            &emsp;&emsp;User user = new User(1, "first", "last");<br><br>
            &emsp;&emsp;try {<br>
            &emsp;&emsp;&emsp;<mark>// Check Session Connection</mark><br>
            &emsp;&emsp;&emsp;System.out.println(session.isConnected());<br>
            &emsp;&emsp;&emsp;<mark>// Insert our user into the database, enter the persistent state</mark><br>
            &emsp;&emsp;&emsp;session.save(user);<br>
            &emsp;&emsp;} catch (Exception e) {<br>
            &emsp;&emsp;&emsp;tx.rollback(); <mark>// rollback changes to the database</mark><br>
            &emsp;&emsp;}<br><br>
            &emsp;&emsp;<mark>// Commit changes to the database</mark><br>
            &emsp;&emsp;tx.commit();<br>
            &emsp;&emsp;<mark>// Close the connection, enter the detached state</mark><br>
            &emsp;&emsp;session.close();<br><br>
            &emsp;&emsp;<mark>// Update the user while in a detached state</mark><br>
            &emsp;&emsp;user.setFirstName("Ravie");<br>
            &emsp;&emsp;user.setLastName("Krieslslk");<br><br>
            &emsp;&emsp;<mark>// Open a new Session</mark>><br>
            &emsp;&emsp;Session session2 = util.getSession();<br>
            &emsp;&emsp;Transaction tx2 = session2.beginTransaction();<br><br>
            &emsp;&emsp;try {<br>
            &emsp;&emsp;&emsp;<mark>// We need to use saveOrUpdate() here to avoid a duplicate entry</mark><br>
            &emsp;&emsp;&emsp;<mark>// Update the user, enter the persistent state</mark><br>
            &emsp;&emsp;&emsp;<mark>// session2.saveOrUpdate(user);</mark><br><br>
            &emsp;&emsp;&emsp;<mark>// We can use merge if we know the user exists and needs to update</mark><br>
            &emsp;&emsp;&emsp;<mark>// session2.merge(user);</mark><br><br>
            &emsp;&emsp;&emsp;<mark>// If we use refresh, we can get a fresh copy of the object from the</mark><br>
            &emsp;&emsp;&emsp;<mark>// database and forget about the changes made while in the detached state.</mark><br>
            &emsp;&emsp;&emsp;session2.refresh(user);<br><br>
            &emsp;&emsp;&emsp;<mark>// Print the user (User class should override toString() for desired results)</mark><br>
            &emsp;&emsp;&emsp;System.out.println(user);<br><br>
            &emsp;&emsp;} catch (Exception e) {<br>
            &emsp;&emsp;&emsp;tx2.rollback(); <mark>// Undo changes to the database</mark><br>
            &emsp;&emsp;}<br><br>
            &emsp;&emsp;<mark>// Commit changes to the database</mark><br>
            &emsp;&emsp;tx2.commit();<br>
            &emsp;&emsp;<mark>// Close the Session</mark><br>
            &emsp;&emsp;session2.close();<br>
            &emsp;}<br>
            }
        </div>
    </div>
    </div>
    &nbsp;
    <button class="collapsible">Hibernate Queries</button>
    <div class="content">
        <button class="collapsible">HQL</button>
        <div class="content">
            <button class="collapsible">Get All Users</button>
            <div class="content">
            <div class="code">
                public class HQLExample {<br>
                &emsp;public static void main(String[] args) {<br>
                &emsp;HQLExample example = new HQLExample();<br>
                &emsp;example.getAllUsers();<br>
                }<br><br>
                private HibernateUtility utility = new HibernateUtility();<br><br>
                public void getAllUsers() {<br>
                &emsp;Session session = null;<br>
                &emsp;Transaction tx = null;<br><br>
                &emsp;try {<br>
                &emsp;&emsp;session = utility.getSession(); <mark>// Get a session from the session factory</mark><br>
                &emsp;&emsp;tx = session.beginTransaction(); <mark>// Begin a transaction</mark><br><br>
                &emsp;&emsp;String hql = "FROM User"; <mark>// FROM User objects, this is case sensitive</mark><br>
                &emsp;&emsp;<mark>// FROM com.training.hibernate.model.User (also works)</mark><br><br>
                &emsp;&emsp;<mark>// Create a Query object and add the users to a List collection</mark><br>
                &emsp;&emsp;Query query = session.createQuery(hql);<br>
                &emsp;&emsp;List&lt;User&gt; users = query.getResultList();<br><br>
                &emsp;&emsp;<mark>// Print the users</mark><br>
                &emsp;&emsp;for (User user : users) {<br>
                &emsp;&emsp;&emsp;System.out.println(user);<br>
                &emsp;&emsp;}<br><br>
                &emsp;&emsp;tx.commit(); <mark>// Commit changes to the database</mark><br>
                &emsp;} catch (Exception e) {<br>
                &emsp;&emsp;tx.rollback(); <mark>// Rollback the changes made to the database</mark><br>
                &emsp;&emsp;e.printStackTrace(); <mark>// Print the stack trace</mark><br>
                &emsp;} finally {<br>
                &emsp;&emsp;session.close(); <mark>// Close the session</mark><br>
                &emsp;}<br>
                }
            </div>
            </div>
        </div>
        &nbsp;
        <button class="collapsible">Criteria Queries</button>
        <div class="content">
            <button class="collapsible">Get All Users</button>
            <div class="content">
            <div class="code">
                public class HQLExample {<br>
                &emsp;public static void main(String[] args) {<br>
                &emsp;HQLExample example = new HQLExample();<br>
                &emsp;example.getAllUsersUsingCriteriaQuery();<br>
                }<br><br>
                private HibernateUtility utility = new HibernateUtility();<br><br>
                public void getAllUsersUsingCriteriaQuery() {<br>
                &emsp;Session session = null;<br>
                &emsp;Transaction tx = null;<br><br>
                &emsp;try {<br>
                &emsp;&emsp;session = utility.getSession(); <mark>// Get a session from the session factory</mark><br>
                &emsp;&emsp;tx = session.beginTransaction(); <mark>// Begin a transaction</mark><br><br>
                &emsp;&emsp;<mark>// Get criteria builder, Prepare criteria query</mark><br>
                &emsp;&emsp;CriteriaBuilder builder = session.getCriteriaBuilder();<br>
                &emsp;&emsp;<mark>// Expecting a type of User.class (user objects)</mark><br>
                &emsp;&emsp;CriteriaQuery&lt;User&gt; query = builder.createQuery(User.class);<br><br>
                &emsp;&emsp;<mark>// Specifying firstName or age will require changing this to string or int</mark><br>
                &emsp;&emsp;Root&lt;User&gt; root = query.from(User.class);<br>
                &emsp;&emsp;<mark>// Add a where clause</mark><br>
                &emsp;&emsp;query.select(root).where(builder.equal(root.get("userID"), 1));<br><br>
                &emsp;&emsp;Query q = session.createQuery(query);<br>
                &emsp;&emsp;List&lt;User&gt; users = q.getResultList();<br><br>
                &emsp;&emsp;<mark>// Print the users</mark><br>
                &emsp;&emsp;for (User user : users) {<br>
                &emsp;&emsp;&emsp;System.out.println(user);<br>
                &emsp;&emsp;}<br><br>
                &emsp;&emsp;tx.commit(); <mark>// Commit changes to the database</mark><br>
                &emsp;} catch (Exception e) {<br>
                &emsp;&emsp;tx.rollback(); <mark>// Rollback the changes made to the database</mark><br>
                &emsp;&emsp;e.printStackTrace(); <mark>// Print the stack trace</mark><br>
                &emsp;} finally {<br>
                &emsp;&emsp;session.close(); <mark>// Close the session</mark><br>
                &emsp;}<br>
                }
            </div>
            </div>
            &nbsp;
            <button class="collapsible">Select First and Last Names</button>
            <div class="content">
            <div class="code">
                public class HQLExample {<br>
                &emsp;public static void main(String[] args) {<br>
                &emsp;HQLExample example = new HQLExample();<br>
                &emsp;example.getAllUsersUsingCriteriaQuery();<br>
                }<br><br>
                private HibernateUtility utility = new HibernateUtility();<br><br>
                public void getAllUsersUsingCriteriaQuery() {<br>
                &emsp;Session session = null;<br>
                &emsp;Transaction tx = null;<br><br>
                &emsp;try {<br>
                &emsp;&emsp;session = utility.getSession(); <mark>// Get a session from the session factory</mark><br>
                &emsp;&emsp;tx = session.beginTransaction(); <mark>// Begin a transaction</mark><br><br>
                &emsp;&emsp;<mark>// Get criteria builder, Prepare criteria query</mark><br>
                &emsp;&emsp;CriteriaBuilder builder = session.getCriteriaBuilder();<br>
                &emsp;&emsp;CriteriaQuery&lt;Object[]&gt; query = builder.createQuery(Object[].class);<br><br>
                &emsp;&emsp;Root&lt;User&gt; root = query.from(User.class);<br>
                &emsp;&emsp;query.multiselect(root.get("firstName"), root.get("lastName"));<br><br>
                &emsp;&emsp;Query q = session.createQuery(query);<br>
                &emsp;&emsp;List<&lt;Object[]&gt; fullname = q.getResultList();<br><br>
                &emsp;&emsp;<mark>// Print the users</mark><br>
                &emsp;&emsp;for (User user : users) {<br>
                &emsp;&emsp;&emsp;System.out.println(user);<br>
                &emsp;&emsp;}<br><br>
                &emsp;&emsp;tx.commit(); <mark>// Commit changes to the database</mark><br>
                &emsp;} catch (Exception e) {<br>
                &emsp;&emsp;tx.rollback(); <mark>// Rollback the changes made to the database</mark><br>
                &emsp;&emsp;e.printStackTrace(); <mark>// Print the stack trace</mark><br>
                &emsp;} finally {<br>
                &emsp;&emsp;session.close(); <mark>// Close the session</mark><br>
                &emsp;}<br>
                }
            </div>
            </div>
        </div>
        &nbsp;
        <button class="collapsible">Named Queries</button>
        <div class="content">
            <p>First we will need to add a Named Query to our User class:</p>
            <div class="code">
                @Entity // Defines that this Class can be mapped to a table<br>
                @Table(name = "users") // User class should connect to the users Table in the Database<br>
                @NamedQuery(name = "get_All_Users", query = "From User") // A Named Query for printing all users<br>
                public class User {
            </div>
            <button class="collapsible">Get all Users</button>
            <div class="content">
            <div class="code">
                public class HQLExample {<br>
                &emsp;public static void main(String[] args) {<br>
                &emsp;HQLExample example = new HQLExample();<br>
                &emsp;example.getAllUsersWithNamedQuery();<br>
                }<br><br>
                private HibernateUtility utility = new HibernateUtility();<br><br>
                public void getAllUsersWithNamedQuery() {<br>
                &emsp;Session session = null;<br>
                &emsp;Transaction tx = null;<br><br>
                &emsp;try {<br>
                &emsp;&emsp;session = utility.getSession(); <mark>// Get a session from the session factory</mark><br>
                &emsp;&emsp;tx = session.beginTransaction(); <mark>// Begin a transaction</mark><br><br>
                &emsp;&emsp;List&lt;User&gt; users = session.getNamedQuery("get_All_Users").getResultList();<br><br>
                &emsp;&emsp;<mark>// Print the users</mark><br>
                &emsp;&emsp;for (User user : users) {<br>
                &emsp;&emsp;&emsp;System.out.println(user);<br>
                &emsp;&emsp;}<br><br>
                &emsp;&emsp;tx.commit(); <mark>// Commit changes to the database</mark><br>
                &emsp;} catch (Exception e) {<br>
                &emsp;&emsp;tx.rollback(); <mark>// Rollback the changes made to the database</mark><br>
                &emsp;&emsp;e.printStackTrace(); <mark>// Print the stack trace</mark><br>
                &emsp;} finally {<br>
                &emsp;&emsp;session.close();<mark>// Close the session</mark><br>
                &emsp;}<br>
                }
            </div>
            </div>
        </div>
    </div>
    &nbsp;
    <button class="collapsible">Log Interceptor</button>
    <div class="content">
        <p>To add a Log Interceptor to our program we first need to create a class that extends EmptyInterceptor.</p>
        <p>We can then use Eclipse's Source -> Override/Implement methods to add the methods we want.</p>
        <div class="code">
            public class LogInterceptor extends EmptyInterceptor {<br><br>
            &emsp;@Override<br>
            &emsp;public void afterTransactionBegin(Transaction tx) {<br>
            &emsp;&emsp;super.afterTransactionBegin(tx);<br>
            &emsp;}<br><br>
            .....
        </div>
        <p>We can then Add on to our Utility class and have a working log interceptor.</p>
        <p>We need only add on to our getSession() and getSessionFactory() methods. Example shown in the Hibernate Example section above.</p>
    </div>
    &nbsp;
    <button class="collapsible">Hibernate Lifecycle</button>
    <div class="content">
        <h3>Hibernate Lifecycle</h3>
            <div class="center"><img src="images/hibernate-lifecycle.png" alt="Hibernate Lifecycle"></div>
            <p>The Hibernate lifecycle contains the following states:</p>
            <ul>
                <li>Transient</li>
                <li>Persistent</li>
                <li>Detached</li>
            </ul>
            <h3>Transient State</h3>
            <ul>
                <li>The transient state is the initial state of an object.</li>
                <li>Here, an object is not associated with the Session. So, the transient state is not related to any database.</li>
                <li>Hence, modifications in the data don't affect any changes in the database.</li>
                <li>The transient objects exist in the heap memory.</li>
            </ul>
            <div class="code">
                <mark>// Here, object enters the transient state.</mark><br>
                Employee e = new Employee();
            </div>
            <h3>Persistent State</h3>
            <ul>
                <li>As soon as the object is associated with the Session, it enters the persistent state.</li>
                <li>We can say that an object is in the persistence state when we save or persist it.</li>
                <li>Each Object represents the row of the database table so, modifications to the data make changes in the database.</li>
            </ul>
            <p>The following methods are used to put an object in the persistent state:</p>
            <div class="code">
                session.save(e);<br>
                session.persist(e);<br>
                session.update(e);<br>
                session.saveOrUpdate(e);<br>
                session.lock(e);<br>
                session.merge(e);
            </div>
            <h3>Detached State</h3>
            <ul>
                <li>Once we either close the session or clear its cache, then the object enters into the detached state.</li>
                <li>An object is no longer associated with the Session, modification in the data don't affect the database.</li>
                <li>Detached objects still have a representation in the database. If we want to persist changes made to a detached object, it is required to re-open the Session.</li>
                <li>To associate the detached object with the new Hibernate Session, we can use methods such as: load(), merge(), refresh(), update() or save() on a new session with the reference of the detached object.</li>
            </ul>
            <p>The following methods are used to put an object in the detached state:</p>
            <div class="code">
                session.close();<br>
                session.clear();<br>
                session.detach(e);<br>
                session.evict(e);
            </div>
        </div>
    </div>
</div>
    &nbsp;
<button class="collapsible">Design Patterns</button>
<div class="content">
    <h3>Design Pattern of Singleton classes</h3>
    <p>The constructor of singleton class would be private so there must be another way to get the instance of that class. This problem is resolved using a class member instance and a factory method to return the class member.</p>
    <div class="code">
        class MySingleton {<br>
        &emsp;static MySingleton instance = null;<br>
        &emsp;public int x = 10;<br><br>
        &emsp;<mark>// private constructor can't be accessed outside the class</mark><br>
        &emsp;private MySingleton() { }<br><br>
        &emsp;<mark>// Factory method to provide the users with instances</mark><br>
        &emsp;static public MySingleton getInstance() {<br>
        &emsp;&emsp;if (instance == null) {<br>
        &emsp;&emsp;instance = new MySingleton();<br>
        &emsp;&emsp;}<br><br>
        &emsp;&emsp;return instance;<br>
        &emsp;}<br>
        }<br><br>
        <mark>// Driver Class</mark><br>
        class Main {<br>
        &emsp;public static void main(String args[]) {<br>
        &emsp;&emsp;MySingleton a = MySingleton.getInstance();<br>
        &emsp;&emsp;MySingleton b = MySingleton.getInstance();<br>
        &emsp;&emsp;a.x += 10;<br>
        &emsp;&emsp;System.out.println("Value of a.x = " + a.x);<br>
        &emsp;&emsp;System.out.println("Value of b.x = " + b.x);<br>
        &emsp;}<br>
        }
    </div>
    <p>Output:</p>
    <div class="code">
        Value of a.x = 20<br>
        Value of b.x = 20
    </div>
</div>
&nbsp;
<button class="collapsible">Interview Questions</button>
<div class="content">
    &nbsp;
    <button class="collapsible">Core Java 100</button>
    <div class="content">
        <h2>Core Java Questions</h2>
        <h3>Explain JDK, JRE and JVM?</h3>
        <p>JDK (Java Development Kit): The tool necessary to compile, document and package Java programs.</p>
        <p>JRE (Java Runtime Environment): Refers to the runtime environment in which Java bytecode can be executed.</p>
        <p>JVM (Java Virtual Machine): Provides a runtime environment in which Java bytecode can be executed.</p>
        <table>
            <tr>
                <td>JRE (Java Runtime Environment)</td>
                <td>Used to run Java applications/programs</td>
            </tr>
            <tr>
                <td>JDK (Java Development Kit)</td>
                <td>Used to develop Java applications/programs</td>
            </tr>
            <tr>
                <td>JVM (Java Virtual Machine)</td>
                <td>Interpret the byte codes and performs the execution on it</td>
            </tr>
        </table>
        <h3>Explain public static void main(String args[]) in Java</h3>
        <p>main() in Java is the entry point for any Java program.</p>
        <ul>
            <li>public: Public is an access modifier, which is used to specify who can access this method. Public means that this Method will be accessible by any Class.</li>
            <li>static: It is a keyword in java which identifies it is class-based. main() is made static in Java so that it can be accessed without creating the instance of a Class. In case, main is not made static then the compiler will throw an error as main() is called by the JVM before any objects are made and only static methods can be directly invoked via the class. </li>
            <li>void: It is the return type of the method. Void defines the method which will not return any value.</li>
            <li>main: It is the name of the method which is searched by JVM as a starting point for an application with a particular signature only. It is the method where the main execution occurs.</li>
            <li>String args[]: It is the parameter passed to the main method.</li>
        </ul>
        <h3>Why Java is platform independent?</h3>
        <p>Java is called platform independent because of its byte codes which can run on any system irrespective of its underlying operating system.</p>
        <h3>Why Java is not 100% Object-oriented?</h3>
        <p>Java is not 100% Object-oriented because it makes use of eight primitive data types such as boolean, byte, char, int, float, double, long, short which are not objects.</p>
        <h3>What are wrapper classes in Java?</h3>
        <p>Wrapper classes convert the Java primitives into the reference types (objects). Every primitive data type has a class dedicated to it. These are known as wrapper classes because they “wrap” the primitive data type into an object of that class.</p>
        <h3>What are constructors in Java?</h3>
        <p>In Java, constructor refers to a block of code which is used to initialize an object. It must have the same name as that of the class. Also, it has no return type and it is automatically called when an object is created.</p>
        <h3>What is singleton class in Java and how can we make a class singleton?</h3>
        <p>Singleton class is a class whose only one instance can be created at any given time, in one JVM. A class can be made singleton by making its constructor private.</p>
        <h3>What is the difference between equals() and == in Java?</h3>
        <p>Equals() method is defined in Object class in Java and used for checking equality of two objects defined by business logic.</p>
        <p>“==” or equality operator in Java is a binary operator provided by Java programming language and used to compare primitives and objects. When comparing objects it only compare the memory locations of each.</p>
        <h3>What are the differences between Heap and Stack Memory in Java?</h3>
        <table>
            <tr>
                <th>Features</th>
                <th>Stack</th>
                <th>Heap</th>
            </tr>
            <tr>
                <td>Memory</td>
                <td>Stack memory is used only by one thread of execution.</td>
                <td>Heap memory is used by all the parts of the application.</td>
            </tr>
            <tr>
                <td>Access</td>
                <td>Stack memory can’t be accessed by other threads.</td>
                <td>Objects stored in the heap are globally accessible.</td>
            </tr>
            <tr>
                <td>Memory Management</td>
                <td>Follows LIFO manner to free memory.</td>
                <td>Memory management is based on the generation associated with each object.</td>
            </tr>
            <tr>
                <td>Lifetime</td>
                <td>Exists until the end of execution of the thread.</td>
                <td>Heap memory lives from the start till the end of application execution.</td>
            </tr>
            <tr>
                <td>Usage</td>
                <td>Stack memory only contains local primitive and reference variables to objects in heap space.</td>
                <td>Whenever an object is created, it’s always stored in the Heap space.</td>
            </tr>
        </table>
        <h3>What is a package in Java? List down various advantages of packages.</h3>
        <p>Packages in Java, are the collection of related classes and interfaces which are bundled together. By using packages, developers can easily modularize the code and optimize its reuse. Also, the code within the packages can be imported by other classes and reused.</p>
        <ul>
            <li>Packages help in avoiding name clashes</li>
            <li>They provide easier access control on the code</li>
            <li>Packages can also contain hidden classes which are not visible to the outer classes and only used within the package</li>
            <li>Creates a proper hierarchical structure which makes it easier to locate the related classes</li>
        </ul>
        <h3>Why pointers are not used in Java?</h3>
        <p>Java doesn’t use pointers because they are unsafe and increases the complexity of the program. JVM is responsible for implicit memory allocation, thus in order to avoid direct access to memory by the user,  pointers are discouraged in Java.</p>
        <h3>What is JIT compiler in Java?</h3>
        <p>The JIT compiler compiles the bytecode of the invoked method into native machine code, compiling it “just in time” to execute.</p>
        <p>JIT stands for Just-In-Time compiler in Java. It is a program that helps in converting the Java bytecode into instructions that are sent directly to the processor. By default, the JIT compiler is enabled in Java and is activated whenever a Java method is invoked. The JIT compiler then compiles the bytecode of the invoked method into native machine code, compiling it “just in time” to execute. Once the method has been compiled, the JVM summons the compiled code of that method directly rather than interpreting it. This is why it is often responsible for the performance optimization of Java applications at the run time.</p>
        <h3>What are access modifiers in Java?</h3>
        <p>In Java, access modifiers are special keywords which are used to restrict the access of a class, constructor, data member and method in another class.</p>
        <table>
            <tr>
                <th>Modifier</th>
                <th>Default</th>
                <th>Private</th>
                <th>Protected</th>
                <th>Public</th>
            </tr>
            <tr>
                <td>Same Class</td>
                <td>YES</td>
                <td>YES</td>
                <td>YES</td>
                <td>YES</td>
            </tr>
            <tr>
                <td>Same Package Subclass</td>
                <td>YES</td>
                <td>NO</td>
                <td>YES</td>
                <td>YES</td>
            </tr>
            <tr>
                <td>Same Package Non-Subclass</td>
                <td>YES</td>
                <td>NO</td>
                <td>YES</td>
                <td>YES</td>
            </tr>
            <tr>
                <td>Different Package Subclass</td>
                <td>NO</td>
                <td>NO</td>
                <td>YES</td>
                <td>YES</td>
            </tr>
            <tr>
                <td>Different Package Non-Subclass</td>
                <td>NO</td>
                <td>NO</td>
                <td>NO</td>
                <td>YES</td>
            </tr>
        </table>
        <h3>Define a Java Class.</h3>
        <p>The Blueprint for an Object.</p>
        <p>A class in Java is a blueprint which includes all your data.  A class contains fields (variables) and methods to describe the behavior of an object.</p>
        <h3>What is an object in Java and how is it created?</h3>
        <p>An object is a real-world entity that has a state and behavior. An object has three characteristics:</p>
        <ol>
            <li>State</li>
            <li>Beahvior</li>
            <li>Identity</li>
        </ol>
        <p>An object is created using the ‘new’ keyword.</p>
        <div class="code">
            ClassName obj = new ClassName();
        </div>
        <h3>What is Object Oriented Programming?</h3>
        <p>(OOPs) is a programming model or approach where the programs are organized around objects rather than logic and functions. In other words, OOP mainly focuses on the objects that are required to be manipulated instead of logic. This approach is ideal for the programs large and complex codes and needs to be actively updated or maintained.</p>
        <h3>What are the main concepts of OOPs in Java?</h3>
        <ol>
            <li>Inheritance: Inheritance is a process where one class acquires the properties of another.</li>
            <li>Encapsulation: Encapsulation in Java is a mechanism of wrapping up the data and code together as a single unit.</li>
            <li>Abstraction: Abstraction is the methodology of hiding the implementation details from the user and only providing the functionality to the users.</li>
            <li>Polymorphism: Polymorphism is the ability of a variable, function or object to take multiple forms.</li>
        </ol>
        <h2>Two Types of Polymorphism:</h2>
        <ul>
            <p>Static/Compile-Time Polymorphism:</p>
            <ul>
                <p>Specifying different forms during compile time.</p>
                <p>Method Overloading</p>
            </ul>
            <p>Dynamic/Runtime Polymorphism:</p>
            <ul>
                <p>Method Overriding</p>
            </ul>
        </ul>
        <h3>What is the difference between a local variable and an instance variable?</h3>
        <p>In Java, a local variable is typically used inside a method, constructor, or a block and has only local scope. Thus, this variable can be used only within the scope of a block. The best benefit of having a local variable is that other methods in the class won’t be even aware of that variable.</p>
        <p>instance variable in Java, is a variable which is bounded to its object itself. These variables are declared within a class, but outside a method. Every object of that class will create it’s own copy of the variable while using it. Thus, any changes made to the variable won’t reflect in any other instances of that class and will be bound to that particular instance only.</p>
        <h3>Differentiate between the constructors and methods in Java?</h3>
        <table>
            <tr>
                <th>Methods</th>
                <th>Constructors</th>
            </tr>
            <tr>
                <td>Used to represent the behavior of an object</td>
                <td>Used to initialize the state of an object</td>
            </tr>
            <tr>
                <td>Must have a return type</td>
                <td>Do not have any return type</td>
            </tr>
            <tr>
                <td>Needs to be invoked explicitly</td>
                <td>Is invoked implicitly</td>
            </tr>
            <tr>
                <td>No default method is provided by the compiler</td>
                <td>A default constructor is provided by the compiler if the class has none</td>
            </tr>
            <tr>
                <td>Method name may or may not be same as class name</td>
                <td>Constructor name must always be the same as the class name</td>
            </tr>
        </table>
        <h3>What is final keyword in Java?</h3>
        <ul>
            <li>final variable: When the final keyword is used with a variable then its value can’t be changed once assigned. In case the no value has been assigned to the final variable then using only the class constructor a value can be assigned to it.</li>
            <li>final method: When a method is declared final then it can’t be overridden by the inheriting class.</li>
            <li>final class: When a class is declared as final in Java, it can’t be extended by any subclass class but it can extend other class.</li>
        </ul>
        <h3>What is the difference between break and continue statements?</h3>
        <table>
            <tr>
                <th>Break</th>
                <th>Continue</th>
            </tr>
            <tr>
                <td>Can be used in switch and loop (for, while, do while) statements</td>
                <td>Can be only used with loop statements</td>
            </tr>
            <tr>
                <td>It causes the switch or loop statements to terminate the moment it is executed</td>
                <td>It doesn’t terminate the loop but causes the loop to jump to the next iteration</td>
            </tr>
            <tr>
                <td>It terminates the innermost enclosing loop or switch immediately</td>
                <td>A continue within a loop nested with a switch will cause the next loop iteration to execute</td>
            </tr>
        </table>
        <h3>What is an infinite loop in Java? Explain with an example.</h3>
        <p>An infinite loop is an instruction sequence in Java that loops endlessly when a functional exit isn’t met. This type of loop can be the result of a programming error or may also be a deliberate action based on the application behavior. An infinite loop will terminate automatically once the application exits.</p>
        <p>Infinite loops can occur in loop statements where you forgot to add on to the variable that keeps track of iterations.</p>
        <p>If you have two methods that call each other, you can get a deadlock situation.</p>
        <h3>What is the difference between this() and super() in Java?</h3>
        <p>In Java, super() and this(), both are special keywords that are used to call the constructor.</p>
        <table>
            <tr>
                <th>this()</th>
                <th>super()</th>
            </tr>
            <tr>
                <td>this() represents the current instance of a class</td>
                <td>super() represents the current instance of a parent/base class</td>
            </tr>
            <tr>
                <td>Used to call the default constructor of the same class</td>
                <td>Used to call the default constructor of the parent/base class</td>
            </tr>
            <tr>
                <td>Used to access methods of the current class</td>
                <td>Used to access methods of the base class</td>
            </tr>
            <tr>
                <td>Used for pointing the current class instance</td>
                <td>Used for pointing the superclass instance</td>
            </tr>
            <tr>
                <td>Must be the first line of a block</td>
                <td>Must be the first line of a block</td>
            </tr>
        </table>
        <h3>What is Java String Pool?</h3>
        <p>Java String pool refers to a collection of Strings which are stored in heap memory. In this, whenever a new object is created, String pool first checks whether the object is already present in the pool or not. If it is present, then the same reference is returned to the variable else new object will be created in the String pool and the respective reference will be returned.</p>
        <h3>Differentiate between static and non-static methods in Java.`</h3>
        <table>
            <tr>
                <th>Static Method</th>
                <th>Non-Static Method</th>
            </tr>
            <tr>
                <td>he static keyword must be used before the method name</td>
                <td>No need to use the static keyword before the method name</td>
            </tr>
            <tr>
                <td>It is called using the class (className.methodName) </td>
                <td>It is can be called like any general method</td>
            </tr>
            <tr>
                <td>They can’t access any non-static instance variables or methods</td>
                <td>It can access any static method and any static variable without creating an instance of the class</td>
            </tr>
        </table>
        <h3>What is constructor chaining in Java?</h3>
        <p>In Java, constructor chaining is the process of calling one constructor from another with respect to the current object. Constructor chaining is possible only through legacy where a subclass constructor is responsible for invoking the superclass’ constructor first. There could be any number of classes in the constructor chain. Constructor chaining can be achieved in two ways:</p>
        <ol>
            <li>Within the same class using this()</li>
            <li>From base class using super()</li>
        </ol>
        <h3>Difference between String, String Builder, and String Buffer.</h3>
        <table>
            <tr>
                <th>Factor</th>
                <th>String</th>
                <th>String Builder</th>
                <th>String Buffer</th>
            </tr>
            <tr>
                <td>Storage Area</td>
                <td>Constant String Pool</td>
                <td>Heap Area</td>
                <td>Heap Area</td>
            </tr>
            <tr>
                <td>Mutability</td>
                <td>Immutable</td>
                <td>Mutable</td>
                <td>Mutable</td>
            </tr>
            <tr>
                <td>ThreadSafety</td>
                <td>Yes</td>
                <td>Yes</td>
                <td>No</td>
            </tr>
            <tr>
                <td>Performance</td>
                <td>Fast</td>
                <td>Slow</td>
                <td>Fast</td>
            </tr>
        </table>
        <h3>What is a classloader in Java?</h3>
        <p>The Java ClassLoader is a subset of JVM (Java Virtual Machine) that is responsible for loading the class files. Whenever a Java program is executed it is first loaded by the classloader. Java provides three built-in classloaders:</p>
        <ol>
            <li>Bootstrap ClassLoader</li>
            <li>Extension ClassLoader</li>
            <li>System/Application ClassLoader</li>
        </ol>
        <h3>Why Java Strings are immutable in nature?</h3>
        <p>In Java, string objects are immutable in nature which simply means once the String object is created its state cannot be modified. Whenever you try to update the value of that object instead of updating the values of that particular object, Java creates a new string object. Java String objects are immutable as String objects are generally cached in the String pool. Since String literals are usually shared between multiple clients, action from one client might affect the rest. It enhances security, caching, synchronization, and performance of the application.</p>
        <h3>What is the difference between an array and an array list?</h3>
        <table>
            <tr>
                <th>Array</th>
                <th>ArrayList</th>
            </tr>
            <tr>
                <td>Cannot contain values of different data types</td>
                <td>Can contain values of different data types.</td>
            </tr>
            <tr>
                <td>Size must be defined at the time of declaration</td>
                <td>Size can be dynamically changed</td>
            </tr>
            <tr>
                <td>Need to specify the index in order to add data</td>
                <td>No need to specify the index</td>
            </tr>
            <tr>
                <td>Arrays are not type parameterized</td>
                <td>Arraylists are type parameterized</td>
            </tr>
            <tr>
                <td>Arrays can contain primitive data types as well as objects</td>
                <td>Arraylists can contain only objects, no primitive data types are allowed</td>
            </tr>
        </table>
        <h3>What is a Map in Java?</h3>
        <p>In Java, Map is an interface of Util package which maps unique keys to values. The Map interface is not a subset of the main Collection interface and thus it behaves little different from the other collection types.</p>
        <ol>
            <li>Map doesn’t contain duplicate keys.</li>
            <li>Each key can map at max one value.</li>
        </ol>
        <h3>What is collection class in Java? List down its methods and interfaces.</h3>
        <p>In Java, the collection is a framework that acts as an architecture for storing and manipulating a group of objects. Using Collections you can perform various tasks like searching, sorting, insertion, manipulation, deletion, etc. Java collection framework includes the following:</p>
        <ul>
            <li>Interfaces</li>
            <li>Classes</li>
            <li>Methods</li>
        </ul>
        <div class="center"><img src="images/Collection-framework-hierarchy.png" alt="Collection Framework Hierarchy Image"></div>
        <h2>OOPS Java Interview Questions</h2>
        <h3>What is Polymorphism?</h3>
        <p>Polymorphism is briefly described as “one interface, many implementations”. Polymorphism is a characteristic of being able to assign a different meaning or usage to something in different contexts – specifically, to allow an entity such as a variable, a function, or an object to have more than one form. There are two types of polymorphism:</p>
        <ol>
            <li>Compile time polymorphism: method overloading</li>
            <li>Run time polymorphism: method overriding, inheritance and interface</li>
        </ol>
        <h3>What is runtime polymorphism or dynamic method dispatch?</h3>
        <p>In Java, runtime polymorphism or dynamic method dispatch is a process in which a call to an overridden method is resolved at runtime rather than at compile-time. In this process, an overridden method is called through the reference variable of a superclass.</p>
        <h3>What is abstraction in Java?</h3>
        <p>It basically deals with hiding the details and showing the essential things to the user. Thus you can say that abstraction in Java is the process of hiding the implementation details from the user and revealing only the functionality to them. Abstraction can be achieved in two ways:</p>
        <ol>
            <li>Abstract Classes (0-100% of abstraction can be achieved)</li>
            <li>Interfaces (100% of abstraction can be achieved)</li>
        </ol>
        <h3>What do you mean by an interface in Java?</h3>
        <p>An interface in Java is a blueprint of a class or you can say it is a collection of abstract methods and static constants. In an interface, each method is public and abstract but it does not contain any constructor. Thus, interface basically is a group of related methods with empty bodies.</p>
        <h3>What is the difference between abstract classes and interfaces?</h3>
        <p>As of Java 8, Interfaces can have Abstract, Static and Default methods.</p>
        <p>Default methods provide a default implementation for a method in the interface and the if class that implements the interface has a method of the same name, the class definition will take precedence.</p>
        <p>With Default methods also comes the Diamond Problem (Which method do I use when both interfaces I'm implementing define one of the same name?). This is resolved by explicitly telling the program interface1.method or interface2.method.</p>
        <p>Abstract Class: </p>
        <ul>
            <li>An abstract class must be declared with an abstract keyword.</li>
            <li>It can have abstract and non-abstract methods.</li>
            <li>It cannot be instantiated.</li>
            <li>It can have constructors and static methods also.</li>
            <li>It can have final methods which will force the subclass not to change the body of the method.</li>
        </ul>
        <table>
            <tr>
                <th>Abstract Class</th>
                <th>Interfaces</th>
            </tr>
            <tr>
                <td>An abstract class can provide complete, default code and/or just the details that have to be overridden</td>
                <td>An interface cannot provide any code at all, just the signature</td>
            </tr>
            <tr>
                <td>In the case of an abstract class, a class may extend only one abstract class</td>
                <td>A Class may implement several interfaces</td>
            </tr>
            <tr>
                <td>An abstract class can have non-abstract methods</td>
                <td>All methods of an Interface are abstract</td>
            </tr>
            <tr>
                <td>An abstract class can have instance variables</td>
                <td>An Interface cannot have instance variables</td>
            </tr>
            <tr>
                <td>An abstract class can have any visibility: public, private, protected</td>
                <td>An Interface visibility must be public (or) none</td>
            </tr>
            <tr>
                <td>If we add a new method to an abstract class then we have the option of providing default implementation and therefore all the existing code might work properly</td>
                <td>If we add a new method to an Interface then we have to track down all the implementations of the interface and define implementation for the new method</td>
            </tr>
            <tr>
                <td>An abstract class can contain constructors</td>
                <td>An Interface cannot contain constructors</td>
            </tr>
            <tr>
                <td>Abstract classes are fast</td>
                <td>Interfaces are slow as it requires extra indirection to find the corresponding method in the actual class</td>
            </tr>
        </table>
        <h3>What is inheritance in Java?</h3>
        <p>Inheritance in Java is the concept where the properties of one class can be inherited by the other. It helps to reuse the code and establish a relationship between different classes. Inheritance is performed between two types of classes:</p>
        <ol>
            <li>Parent class (Super or Base class)</li>
            <li>Child class (Subclass or Derived class)</li>
        </ol>
        <p>A class which inherits the properties is known as Child Class whereas a class whose properties are inherited is known as Parent class.</p>
        <h3>What are the different types of inheritance in Java?</h3>
        <ol>
            <li>Single Inheritance: In single inheritance, one class inherits the properties of another i.e there will be only one parent as well as one child class.</li>
            <li>Multilevel Inheritance: When a class is derived from a class which is also derived from another class, i.e. a class having more than one parent class but at different levels, such type of inheritance is called Multilevel Inheritance.</li>
            <li>Hierarchical Inheritance: When a class has more than one child classes (subclasses) or in other words, more than one child classes have the same parent class, then such kind of inheritance is known as hierarchical.</li>
            <li>Hybrid Inheritance: Hybrid inheritance is a combination of two or more types of inheritance.</li>
        </ol>
        <h3>What is method overloading and method overriding?</h3>
        <p>Method Overloading:</p>
        <ul>
            <li>In Method Overloading, Methods of the same class shares the same name but each method must have a different number of parameters or parameters having different types and order.</li>
            <li>Method Overloading is to “add” or “extend” more to the method’s behavior.</li>
            <li>It is a compile-time polymorphism.</li>
            <li>The methods must have a different signature.</li>
            <li>It may or may not need inheritance in Method Overloading.</li>
        </ul>
        <p>Method Overriding:</p>
        <ul>
            <li>In Method Overriding, the subclass has the same method with the same name and exactly the same number and type of parameters and same return type as a superclass.</li>
            <li>Method Overriding is to “Change” existing behavior of the method.</li>
            <li>It is a run time polymorphism.</li>
            <li>The methods must have the same signature.</li>
            <li>It always requires inheritance in Method Overriding.</li>
        </ul>
        <h3>Can you override a private or static method in Java?</h3>
        <p>You cannot override a private or static method in Java. If you create a similar method with the same return type and same method arguments in child class then it will hide the superclass method; this is known as method hiding. Similarly, you cannot override a private method in subclass because it’s not accessible there. What you can do is create another private method with the same name in the child class.</p>
        <h3>What is multiple inheritance? Is it supported by Java?</h3>
        <p>If a child class inherits the property from multiple classes is known as multiple inheritance. Java does not allow to extend multiple classes.</p>
        <p>The problem with multiple inheritance is that if multiple parent classes have the same method name, then at runtime it becomes difficult for the compiler to decide which method to execute from the child class. Therefore, Java doesn’t support multiple inheritance. The problem is commonly referred to as Diamond Problem.</p>
        <h3>What is encapsulation in Java?</h3>
        <p>Encapsulation is a mechanism where you bind your data(variables) and code(methods) together as a single unit. Here, the data is hidden from the outer world and can be accessed only via current class methods. This helps in protecting the data from any unnecessary modification. We can achieve encapsulation in Java by:</p>
        <ul>
            <li>Declaring the variables of a class as private.</li>
            <li>Providing public setter and getter methods to modify and view the values of the variables.</li>
        </ul>
        <h3>What is an association?</h3>
        <p>Association is a relationship where all object have their own lifecycle and there is no owner. Let’s take the example of Teacher and Student. Multiple students can associate with a single teacher and a single student can associate with multiple teachers but there is no ownership between the objects and both have their own lifecycle. These relationships can be one to one, one to many, many to one and many to many.</p>
        <h3>What do you mean by aggregation?</h3>
        <p>An aggregation is a specialized form of Association where all object has their own lifecycle but there is ownership and child object can not belong to another parent object. Let’s take an example of Department and teacher. A single teacher can not belong to multiple departments, but if we delete the department teacher object will not destroy.</p>
        <h3>What is composition in Java?</h3>
        <p>Composition is again a specialized form of Aggregation and we can call this as a “death” relationship. It is a strong type of Aggregation. Child object does not have their lifecycle and if parent object deletes all child object will also be deleted. Let’s take again an example of a relationship between House and rooms. House can contain multiple rooms there is no independent life of room and any room can not belongs to two different houses if we delete the house room will automatically delete.</p>
        <h3>What is a marker interface?</h3>
        <p>A Marker interface can be defined as the interface having no data member and member functions. In simpler terms, an empty interface is called the Marker interface. The most common examples of Marker interface in Java are Serializable, Cloneable etc. The marker interface can be declared as follows.</p>
        <h3>What is object cloning in Java?</h3>
        <p>Object cloning in Java is the process of creating an exact copy of an object. It basically means the ability to create an object with a similar state as the original object. To achieve this, Java provides a method clone() to make use of this functionality. This method creates a new instance of the class of the current object and then initializes all its fields with the exact same contents of corresponding fields. To object clone(), the marker interface java.lang.Cloneable must be implemented to avoid any runtime exceptions. One thing you must note is Object clone() is a protected method, thus you need to override it.</p>
        <h3>What is a copy constructor in Java?</h3>
        <p>Copy constructor is a member function that is used to initialize an object using another object of the same class. Though there is no need for copy constructor in Java since all objects are passed by reference. Moreover, Java does not even support automatic pass-by-value.</p>
        <h3>What is a constructor overloading in Java?</h3>
        <p>In Java, constructor overloading is a technique of adding any number of constructors to a class each having a different parameter list. The compiler uses the number of parameters and their types in the list to differentiate the overloaded constructors.</p>
        <h2>Servlets Interview Questions</h2>
        <h3>What is a servlet?</h3>
        <ul>
            <li>Java Servlet is server-side technologies to extend the capability of web servers by providing support for dynamic response and data persistence.</li>
            <li>The javax.servlet and javax.servlet.http packages provide interfaces and classes for writing our own servlets.</li>
            <li>All servlets must implement the javax.servlet.Servlet interface, which defines servlet lifecycle methods. When implementing a generic service, we can extend the GenericServlet class provided with the Java Servlet API. The HttpServlet class provides methods, such as doGet() and doPost(), for handling HTTP-specific services.</li>
            <li>Most of the times, web applications are accessed using HTTP protocol and thats why we mostly extend HttpServlet class. Servlet API hierarchy is shown in below image.</li>
        </ul>
        <h3>What are the differences between Get and Post methods?</h3>
        <table>
            <tr>
                <th>GET</th>
                <th>POST</th>
            </tr>
            <tr>
                <td>Limited amount of data can be sent because data is sent in header.</td>
                <td>Large amount of data can be sent because data is sent in body.</td>
            </tr>
            <tr>
                <td>Not Secured because data is exposed in URL bar.</td>
                <td>Secured because data is not exposed in URL bar.</td>
            </tr>
            <tr>
                <td>Can be bookmarked</td>
                <td>Cannot be bookmarked</td>
            </tr>
            <tr>
                <td>Idempotent</td>
                <td>Non-Idempotent</td>
            </tr>
            <tr>
                <td>It is more efficient and used than Post</td>
                <td>It is less efficient and used</td>
            </tr>
        </table>
        <h3>What is Request Dispatcher?</h3>
        <p>RequestDispatcher interface is used to forward the request to another resource that can be HTML, JSP or another servlet in same application. We can also use this to include the content of another resource to the response.</p>
        <h3>What are the differences between forward() method and sendRedirect() methods?</h3>
        <table>
            <tr>
                <th>forward() method</th>
                <th>SendRedirect() method</th>
            </tr>
            <tr>
                <td>forward() sends the same request to another resource.</td>
                <td>sendRedirect() method sends new request always because it uses the URL bar of the browser.</td>
            </tr>
            <tr>
                <td>forward() method works at server side.</td>
                <td>sendRedirect() method works at client side.</td>
            </tr>
            <tr>
                <td>forward() method works within the server only.</td>
                <td>sendRedirect() method works within and outside the server.</td>
            </tr>
        </table>
        <h3>What is the life-cycle of a servlet?</h3>
        <ol>
            <li>Servlet is loaded</li>
            <li>Servlet is instantiated</li>
            <li>Servlet is initialized</li>
            <li>Service the request</li>
            <li>Servlet is destroyed</li>
        </ol>
        <h3>How does cookies work in Servlets?</h3>
        <ul>
            <li>Cookies are text data sent by server to the client and it gets saved at the client local machine.</li>
            <li>Servlet API provides cookies support through javax.servlet.http.Cookie class that implements Serializable and Cloneable interfaces.</li>
            <li>HttpServletRequest getCookies() method is provided to get the array of Cookies from request, since there is no point of adding Cookie to request, there are no methods to set or add cookie to request.</li>
            <li>Similarly HttpServletResponse addCookie(Cookie c) method is provided to attach cookie in response header, there are no getter methods for cookie.</li>
        </ul>
        <h3>What are the differences between ServletContext vs ServletConfig?</h3>
        <table>
            <tr>
                <th>ServletConfig</th>
                <th>ServletContext</th>
            </tr>
            <tr>
                <td>Servlet config object represent single servlet</td>
                <td>It represent whole web application running on particular JVM and common for all the servlet</td>
            </tr>
            <tr>
                <td>Its like local parameter associated with particular servlet</td>
                <td>Its like global parameter associated with whole application</td>
            </tr>
            <tr>
                <td>It’s a name value pair defined inside the servlet section of web.xml file so it has servlet wide scope</td>
                <td>ServletContext has application wide scope so define outside of servlet tag in web.xml file.</td>
            </tr>
            <tr>
                <td>getServletConfig() method is used to get the config object</td>
                <td>getServletContext() method is  used to get the context object.</td>
            </tr>
            <tr>
                <td>for example shopping cart of a user is a specific to particular user so here we can use servlet config	</td>
                <td>To get the MIME type of a file or application session related information is stored using servlet context object.</td>
            </tr>
        </table>
        <h3>What are the different methods of session management in servlets?</h3>
        <p>Session is a conversational state between client and server and it can consists of multiple request and response between client and server. Since HTTP and Web Server both are stateless, the only way to maintain a session is when some unique information about the session (session id) is passed between server and client in every request and response.</p>
        <p>Some of the common ways of session management in servlets are:</p>
        <ol>
            <li>User Authentication</li>
            <li>HTML Hidden Field</li>
            <li>Cookies</li>
            <li>URL Rewriting</li>
            <li>Session Management API</li>
        </ol>
        <h2>JDBC Interview Questions</h2>
        <h3>What is JDBC Driver?</h3>
        <p>JDBC Driver is a software component that enables java application to interact with the database. There are 4 types of JDBC drivers:</p>
        <ol>
            <li>JDBC-ODBC bridge driver</li>
            <li>Native-API driver (partially java driver)</li>
            <li>Network Protocol driver (fully java driver)</li>
            <li>Thin driver (fully java driver)</li>
        </ol>
        <h3>What are the steps to connect to a database in java?</h3>
        <ul>
            <li>Registering the driver class</li>
            <li>Creating connection</li>
            <li>Creating statement</li>
            <li>Executing queries</li>
            <li>Closing connection</li>
        </ul>
        <h3>What are the JDBC API components?</h3>
        <p>Interfaces:</p>
        <ul>
            <li>Connection</li>
            <li>Statement</li>
            <li>PreparedStatement</li>
            <li>ResultSet</li>
            <li>ResultSetMetaDatav
            <li>DatabaseMetaData</li>
            <li>CallableStatement etc.</li>
        </ul>
        <p>Classes:</p>
        <ul>
            <li>DriverManager</li>
            <li>Blob</li>
            <li>Clob</li>
            <li>Types</li>
            <li>SQLException etc.</li>
        </ul>
        <h3>What is the role of JDBC DriverManager class?</h3>
        <p>The DriverManager class manages the registered drivers. It can be used to register and unregister drivers. It provides factory method that returns the instance of Connection.</p>
        <h3>What is JDBC Connection interface?</h3>
        <p>The Connection interface maintains a session with the database. It can be used for transaction management. It provides factory methods that returns the instance of Statement, PreparedStatement, CallableStatement and DatabaseMetaData.</p>
        <h3>What is the purpose of JDBC ResultSet interface?</h3>
        <p>The ResultSet object represents a row of a table. It can be used to change the cursor pointer and get the information from the database.</p>
        <h3>What is JDBC ResultSetMetaData interface?</h3>
        <p>The ResultSetMetaData interface returns the information of table such as total number of columns, column name, column type etc.</p>
        <h3>What is JDBC DatabaseMetaData interface?</h3>
        <p>The DatabaseMetaData interface returns the information of the database such as username, driver name, driver version, number of tables, number of views etc.</p>
        <h3>What do you mean by batch processing in JDBC?</h3>
        <p>Batch processing helps you to group related SQL statements into a batch and execute them instead of executing a single query. By using batch processing technique in JDBC, you can execute multiple queries which makes the performance faster.</p>
        <h3>What is the difference between execute, executeQuery, executeUpdate?</h3>
        <p>Statement execute(String query) is used to execute any SQL query and it returns TRUE if the result is an ResultSet such as running Select queries. The output is FALSE when there is no ResultSet object such as running Insert or Update queries. We can use getResultSet() to get the ResultSet and getUpdateCount() method to retrieve the update count.</p>
        <p>Statement executeQuery(String query) is used to execute Select queries and returns the ResultSet. ResultSet returned is never null even if there are no records matching the query. When executing select queries we should use executeQuery method so that if someone tries to execute insert/update statement it will throw java.sql.SQLException with message “executeQuery method can not be used for update”.</p>
        <p>Statement executeUpdate(String query) is used to execute Insert/Update/Delete (DML) statements or DDL statements that returns nothing. The output is int and equals to the row count for SQL Data Manipulation Language (DML) statements. For DDL statements, the output is 0.</p>
        <p>You should use execute() method only when you are not sure about the type of statement else use executeQuery or executeUpdate method.</p>
        <h3>What do you understand by JDBC Statements?</h3>
        <p>JDBC statements are basically the statements which are used to send SQL commands to the database and retrieve data back from the database. Various methods like execute(), executeUpdate(), executeQuery, etc. are provided by JDBC to interact with the database.</p>
        <ol>
            <li>Statement: Used for general purpose access to the database and executes a static SQL query at runtime.</li>
            <li>PreparedStatement: Used to provide input parameters to the query during execution.</li>
            <li>CallableStatement: Used to access the database stored procedures and helps in accepting runtime parameters.</li>
        </ol>
        <h2>Spring Interview Questions</h2>
        <h3>What is Spring?</h3>
        <p>Spring is essentially a lightweight, integrated framework that can be used for developing enterprise applications in java.</p>
        <h3>Name the different modules of the Spring framework.</h3>
        <ul>
            <li>Spring Context – for dependency injection.</li>
            <li>Spring AOP – for aspect oriented programming.</li>
            <li>Spring DAO – for database operations using DAO pattern</li>
            <li>Spring JDBC – for JDBC and DataSource support.</li>
            <li>Spring ORM – for ORM tools support such as Hibernate</li>
            <li>Spring Web Module – for creating web applications.</li>
            <li>Spring MVC – Model-View-Controller implementation for creating web applications, web services etc.</li>
        </ul>
        <div class="center"><img src="images/Spring-Framework-Java.png" alt="Spring Framework Image"></div>
        <h3>List some of the important annotations in annotation-based Spring configuration.</h3>
        <ul>
            <li>@Required</li>
            <li>@Autowired</li>
            <li>@Qualifier</li>
            <li>@Resource</li>
            <li>@PostConstruct</li>
            <li>@PreDestroy</li>
        </ul>
        <h3>Explain Bean in Spring and List the different Scopes of Spring bean.</h3>
        <p>Beans are objects that form the backbone of a Spring application. They are managed by the Spring IoC container. In other words, a bean is <b>an object that is instantiated, assembled, and managed by a Spring IoC container.</b></p>
        <p>Scopes defined in Spring beans</p>
        <ul>
            <li>Singleton: Only one instance of the bean will be created for each container. This is the default scope for the spring beans. While using this scope, make sure spring bean doesn’t have shared instance variables otherwise it might lead to data inconsistency issues because it’s not thread-safe.</li>
            <li>Prototype: A new instance will be created every time the bean is requested.</li>
            <li>Request: This is same as prototype scope, however it’s meant to be used for web applications. A new instance of the bean will be created for each HTTP request.</li>
            <li>Session: A new bean will be created for each HTTP session by the container.</li>
            <li>Global-session: This is used to create global session beans for Portlet applications.</li>
        </ul>
        <h3>Explain the role of DispatcherServlet and ContextLoaderListener.</h3>
        <p>DispatcherServlet is basically the front controller in the Spring MVC application as it loads the spring bean configuration file and initializes all the beans that have been configured. If annotations are enabled, it also scans the packages to configure any bean annotated with @Component, @Controller, @Repository or @Service annotations.</p>
        <div class="center"><img src="images/Dispatcher-Servlet-768x632.png" alt="Dispatcher Servlet Image"></div>
        <p>ContextLoaderListener, on the other hand, is the listener to start up and shut down the WebApplicationContext in Spring root. Some of its important functions includes tying up the lifecycle of Application Context to the lifecycle of the ServletContext and automating the creation of ApplicationContext.</p>
        <h3>What are the differences between constructor injection and setter injection?</h3>
        <table>
            <tr>
                <th>Constructor Injection</th>
                <th>Setter Injection</th>
            </tr>
            <tr>
                <td>No Partial Injection</td>
                <td>Partial Injection</td>
            </tr>
            <tr>
                <td>Doesn’t override the setter property</td>
                <td>Overrides the constructor property if both are defined.</td>
            </tr>
            <tr>
                <td>Creates a new instance if any modification occurs</td>
                <td>Doesn’t create a new instance if you change the property value</td>
            </tr>
            <tr>
                <td>Better for too many properties</td>
                <td>Better for a few properties.</td>
            </tr>
        </table>
        <h3>What is autowiring in Spring? What are the autowiring modes?</h3>
        <p>Autowiring enables the programmer to inject the bean automatically. We don’t need to write explicit injection logic.</p>
        <table>
            <tr>
                <th>Mode</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>no</td>
                <td>this is the default mode, it means autowiring is not enabled.</td>
            </tr>
            <tr>
                <td>ByName</td>
                <td>Injects the bean based on the property name. It uses setter method.</td>
            </tr>
            <tr>
                <td>ByType</td>
                <td>Injects the bean based on the property type. It uses setter method.</td>
            </tr>
            <tr>
                <td>constructor</td>
                <td>It injects the bean using constructor</td>
            </tr>
        </table>
        <h3>How to handle exceptions in Spring MVC Framework?</h3>
        <p>Controller Based: We can define exception handler methods in our controller classes. All we need is to annotate these methods with @ExceptionHandler annotation.</p>
        <p>Global Exception Handler: Exception Handling is a cross-cutting concern and Spring provides @ControllerAdvice annotation that we can use with any class to define our global exception handler.</p>
        <p>HandlerExceptionResolver implementation: For generic exceptions, most of the times we serve static pages. Spring Framework provides HandlerExceptionResolver interface that we can implement to create global exception handler. The reason behind this additional way to define global exception handler is that Spring framework also provides default implementation classes that we can define in our spring bean configuration file to get spring framework exception handling benefits.</p>
        <h3>What are some of the important Spring annotations which you have used?</h3>
        <p>@Controller – for controller classes in Spring MVC project.</p>
        <p>@RequestMapping – for configuring URI mapping in controller handler methods. This is a very important annotation, so you should go through Spring MVC RequestMapping Annotation Examples</p>
        <p>@ResponseBody – for sending Object as response, usually for sending XML or JSON data as response.</p>
        <p>@PathVariable – for mapping dynamic values from the URI to handler method arguments.</p>
        <p>@Autowired – for autowiring dependencies in spring beans.</p>
        <p>@Qualifier – with @Autowired annotation to avoid confusion when multiple instances of bean type is present.</p>
        <p>@Service – for service classes.</p>
        <p>@Scope – for configuring the scope of the spring bean.</p>
        <p>@Configuration, @ComponentScan and @Bean – for java based configurations.</p>
        <h3>How to integrate Spring and Hibernate Frameworks?</h3>
        <p>We can use Spring ORM module to integrate Spring and Hibernate frameworks if you are using Hibernate 3+ where SessionFactory provides current session, then you should avoid using HibernateTemplate or HibernateDaoSupport classes and better to use DAO pattern with dependency injection for the integration.</p>
        <p>Also, Spring ORM provides support for using Spring declarative transaction management, so you should utilize that rather than going for hibernate boiler-plate code for transaction management.</p>
        <h3>Name the types of transaction management that Spring supports.</h3>
        <ol>
            <li>Programmatic transaction management: In this, the transaction is managed with the help of programming. It provides you extreme flexibility, but it is very difficult to maintain.</li>
            <li>Declarative transaction management: In this, transaction management is separated from the business code. Only annotations or XML based configurations are used to manage the transactions.</li>
        </ol>
        <h3>Hibernate Interview Questions</h3>
        <p>Object-relational mapping or ORM is the programming technique to map application domain model objects to the relational database tables. Hibernate is Java-based ORM tool that provides a framework for mapping application domain objects to the relational database tables and vice versa.</p>
        <p>Hibernate provides a reference implementation of Java Persistence API, that makes it a great choice as ORM tool with benefits of loose coupling. We can use the Hibernate persistence API for CRUD operations. Hibernate framework provide option to map plain old java objects to traditional database tables with the use of JPA annotations as well as XML based configuration.</p>
        <h3>What are the important benefits of using Hibernate Framework?</h3>
        <ol>
            <li>Hibernate eliminates all the boiler-plate code that comes with JDBC and takes care of managing resources, so we can focus on business logic.</li>
            <li>Hibernate framework provides support for XML as well as JPA annotations, that makes our code implementation independent.</li>
            <li>Hibernate provides a powerful query language (HQL) that is similar to SQL. However, HQL is fully object-oriented and understands concepts like inheritance, polymorphism, and association.</li>
            <li>Hibernate is an open source project from Red Hat Community and used worldwide. This makes it a better choice than others because learning curve is small and there are tons of online documentation and help is easily available in forums.</li>
            <li>Hibernate is easy to integrate with other Java EE frameworks, it’s so popular that Spring Framework provides built-in support for integrating hibernate with Spring applications.</li>
            <li>Hibernate supports lazy initialization using proxy objects and perform actual database queries only when it’s required.</li>
            <li>Hibernate cache helps us in getting better performance.</li>
            <li>For database vendor specific feature, hibernate is suitable because we can also execute native sql queries.</li>
        </ol>
        <h3>What are the differences between get and load methods?</h3>
        <table>
            <tr>
                <th>get()</th>
                <th>load()</th>
            </tr>
            <tr>
                <td>Returns null if object is not found.</td>
                <td>Throws ObjectNotFoundException if an object is not found.</td>
            </tr>
            <tr>
                <td>get() method always hit the database.</td>
                <td>load() method hits the database only when it is required.</td>
            </tr>
            <tr>
                <td>It returns a real object, not a proxy.</td>
                <td>It returns a proxy object.</td>
            </tr>
            <tr>
                <td>It should be used if you are not sure about the existence of instance.</td>
                <td>It should be used if you are sure that the instance exists.</td>
            </tr>
        </table>
        <h3>What are the advantages of Hibernate over JDBC?</h3>
        <ul>
            <li>Hibernate removes a lot of boiler-plate code that comes with JDBC API, the code looks cleaner and readable.</li>
            <li>Hibernate supports inheritance, associations, and collections. These features are not present with JDBC API.</li>
            <li>Hibernate implicitly provides transaction management, in fact, most of the queries can’t be executed outside transaction. In JDBC API, we need to write code for transaction management using commit and rollback.</li>
            <li>JDBC API throws SQLException that is a checked exception, so we need to write a lot of try-catch block code. Most of the times it’s redundant in every JDBC call and used for transaction management. Hibernate wraps JDBC exceptions and throw JDBCException or HibernateException un-checked exception, so we don’t need to write code to handle it. Hibernate built-in transaction management removes the usage of try-catch blocks.</li>
            <li>Hibernate Query Language (HQL) is more object-oriented and close to Java programming language. For JDBC, we need to write native SQL queries.</li>
            <li>Hibernate supports caching that is better for performance, JDBC queries are not cached hence performance is low.</li>
            <li>Hibernate provides option through which we can create database tables too, for JDBC tables must exist in the database.</li>
            <li>Hibernate configuration helps us in using JDBC like connection as well as JNDI DataSource for the connection pool. This is a very important feature in enterprise application and completely missing in JDBC API.</li>
            <li>Hibernate supports JPA annotations, so the code is independent of the implementation and easily replaceable with other ORM tools. JDBC code is very tightly coupled with the application.</li>
        </ul>
        <h2>Exception and Thread Java Interview Questions</h2>
        <h3>What is the difference between Error and Exception?</h3>
        <p><b>An error is an irrecoverable condition occurring at runtime.</b> Such as OutOfMemory error. These JVM errors you cannot repair them at runtime. Though error can be caught in the catch block but the execution of application will come to a halt and is not recoverable.</p>
        <p>While <b>exceptions are conditions that occur because of bad input or human error etc.</b> e.g. FileNotFoundException will be thrown if the specified file does not exist. Or a NullPointerException will take place if you try using a null reference. In most of the cases it is possible to recover from an exception (probably by giving the user feedback for entering proper values etc.</p>
        <h3>How can you handle Java exceptions?</h3>
        <p>There are five keywords used to handle exceptions in Java:</p>
        <ol>
            <li>try</li>
            <li>catch</li>
            <li>finally</li>
            <li>throw</li>
            <li>throws</li>
        </ol>
        <h3>What are the differences between Checked Exception and Unchecked Exception?</h3>
        <p>Checked Exception</p>
        <ul>
            <li>The classes that extend Throwable class except RuntimeException and Error are known as checked exceptions.</li>
            <li>Checked exceptions are checked at compile-time.</li>
            <li>Example: IOException, SQLException etc.</li>
        </ul>
        <p>Unchecked Exception</p>
        <ul>
            <li>The classes that extend RuntimeException are known as unchecked exceptions.</li>
            <li>Unchecked exceptions are not checked at compile-time.</li>
            <li>Example: ArithmeticException, NullPointerException etc.</li>
        </ul>
        <h3>What purpose do the keywords final, finally, and finalize fulfill? </h3>
        <p>Final is used to apply restrictions on class, method, and variable. A final class can’t be inherited, final method can’t be overridden and final variable value can’t be changed.</p>
        <p>Finally is used to place important code, it will be executed whether the exception is handled or not.</p>
        <p>Finalize is used to perform clean up processing just before the object is garbage collected.</p>
        <h3>What are the differences between throw and throws?</h3>
        <table>
            <tr>
                <th>throw keyword</th>
                <th>throws keyword</th>
            </tr>
            <tr>
                <td>Throw is used to explicitly throw an exception.</td>
                <td>Throws is used to declare an exception.</td>
            </tr>
            <tr>
                <td>Checked exceptions can not be propagated with throw only.</td>
                <td>Checked exception can be propagated with throws.</td>
            </tr>
            <tr>
                <td>Throw is followed by an instance.</td>
                <td>Throws is followed by class.</td>
            </tr>
            <tr>
                <td>Throw is used within the method.</td>
                <td>Throws is used with the method signature.</td>
            </tr>
            <tr>
                <td>You cannot throw multiple exception</td>
                <td>You can declare multiple exception e.g. public void method()throws IOException,SQLException.</td>
            </tr>
        </table>
        <h3>What is exception hierarchy in java?</h3>
        <p>Throwable is a parent class of all Exception classes. There are two types of Exceptions: Checked exceptions and UncheckedExceptions or RunTimeExceptions. Both type of exceptions extends Exception class whereas errors are further classified into Virtual Machine error and Assertion error.</p>
        <h3>How to create a custom Exception?</h3>
        <p>To create you own exception extend the Exception class or any of its subclasses.</p>
        <h3>What are the important methods of Java Exception Class?</h3>
        <p>Exception and all of it’s subclasses doesn’t provide any specific methods and all of the methods are defined in the base class Throwable.</p>
        <ol>
            <li>String getMessage() – This method returns the message String of Throwable and the message can be provided while creating the exception through it’s constructor.</li>
            <li>String getLocalizedMessage() – This method is provided so that subclasses can override it to provide locale specific message to the calling program. Throwable class implementation of this method simply use getMessage() method to return the exception message.</li>
            <li>Synchronized Throwable getCause() – This method returns the cause of the exception or null id the cause is unknown.</li>
            <li>String toString() – This method returns the information about Throwable in String format, the returned String contains the name of Throwable class and localized message.</li>
            <li>void printStackTrace() – This method prints the stack trace information to the standard error stream, this method is overloaded and we can pass PrintStream or PrintWriter as an argument to write the stack trace information to the file or stream.</li>
        </ol>
        <h3>What are the differences between processes and threads?</h3>
        <table>
            <tr>
                <th></th>
                <th>Process</th>
                <th>Thread</th>
            </tr>
            <tr>
                <td>Definition</td>
                <td>An executing instance of a program is called a process.</td>
                <td>A thread is a subset of the process.</td>
            </tr>
            <tr>
                <td>Communication</td>
                <td>Processes must use inter-process communication to communicate with sibling processes.</td>
                <td>Threads can directly communicate with other threads of its process.</td>
            </tr>
            <tr>
                <td>Control</td>
                <td>Processes can only exercise control over child processes.</td>
                <td>Threads can exercise considerable control over threads of the same process.</td>
            </tr>
            <tr>
                <td>Changes</td>
                <td>Any change in the parent process does not affect child processes.</td>
                <td>Any change in the main thread may affect the behavior of the other threads of the process.</td>
            </tr>
            <tr>
                <td>Memory</td>
                <td>Run in separate memory spaces.</td>
                <td>Run in shared memory spaces.</td>
            </tr>
            <tr>
                <td>Controlled by</td>
                <td>Process is controlled by the operating system.</td>
                <td>Threads are controlled by programmer in a program.</td>
            </tr>
            <tr>
                <td>Dependence</td>
                <td>Processes are independent.</td>
                <td>Threads are dependent.</td>
            </tr>
        </table>
        <h3>What is a finally block? Is there a case when finally will not execute?</h3>
        <p>Finally block is a block which always executes a set of statements. It is always associated with a try block regardless of any exception that occurs or not.</p>
        <p>Yes, finally will not be executed if the program exits either by calling System.exit() or by causing a fatal error that causes the process to abort.</p>
        <h3>What is synchronization?</h3>
        <p>Synchronization refers to multi-threading. A synchronized block of code can be executed by only one thread at a time. As Java supports execution of multiple threads, two or more threads may access the same fields or objects. Synchronization is a process which keeps all concurrent threads in execution to be in sync. Synchronization avoids memory consistency errors caused due to inconsistent view of shared memory. When a method is declared as synchronized the thread holds the monitor for that method’s object. If another thread is executing the synchronized method the thread is blocked until that thread releases the monitor.</p>
        <div class="center"><img src="images/Synchronization-768x304.png" alt="Synchronization Image"></div>
        <h3>Can we write multiple catch blocks under single try block?</h3>
        <p>Yes we can have multiple catch blocks under single try block but the approach should be from specific to general.</p>
        <h3>What are the important methods of Java Exception Class?</h3>
        <ol>
            <li>String getMessage() – This method returns the message String about the exception. The message can be provided through its constructor.</li>
            <li>public StackTraceElement[] getStackTrace() – This method returns an array containing each element on the stack trace. The element at index 0 represents the top of the call stack whereas the last element in the array represents the method at the bottom of the call stack.</li>
            <li>Synchronized Throwable getCause() – This method returns the cause of the exception or null id as represented by a Throwable object.</li>
            <li>String toString() – This method returns the information in String format. The returned String contains the name of Throwable class and localized message.</li>
            <li>void printStackTrace() – This method prints the stack trace information to the standard error stream.</li>
        </ol>
        <h3>What is OutOfMemoryError in Java?</h3>
        <p>OutOfMemoryError is the subclass of java.lang.Error which generally occurs when our JVM runs out of memory.</p>
        <h3>What is a Thread?</h3>
        <p>A thread is the smallest piece of programmed instructions which can be executed independently by a scheduler. In Java, all the programs will have at least one thread which is known as the main thread. This main thread is created by the JVM when the program starts its execution. The main thread is used to invoke the main() of the program.</p>
        <h3>What are the two ways to create a thread?</h3>
        <ul>
            <li>By implementing the Runnable interface.</li>
            <li>By extending the Thread</li>
        </ul>
        <h3>What are the different types of garbage collectors in Java?</h3>
        <p>Garbage collection in Java a program which helps in implicit memory management. Since in Java, using the new keyword you can create objects dynamically, which once created will consume some memory. Once the job is done and there are no more references left to the object, Java using garbage collection destroys the object and relieves the memory occupied by it. Java provides four types of garbage collectors:</p>
        <ul>
            <li>Serial Garbage Collector</li>
            <li>Parallel Garbage Collector</li>
            <li>CMS Garbage Collector</li>
            <li>G1 Garbage Collector</li>
        </ul>
    </div>
    &nbsp;
    <button class="collapsible">Core Java 300</button>
    <div class="content">
    <button class="collapsible">Core Java: Basics of Java Interview Questions</button>
    <div class="content">
        <p>https://www.javatpoint.com/corejava-interview-questions</p>
        <button class="collapsible">What is Java?</button>
        <div class="content">
            <p>Java is the high-level, object-oriented, robust, secure programming language, platform-independent, high performance, Multithreaded, and portable programming language. It was developed by James Gosling in June 1991. It can also be known as the platform as it provides its own JRE and API.</p>
        </div>
        &nbsp;
        <button class="collapsible">List the features of Java Programming language.</button>
        <div class="content">
            <ul>
                <li>Simple: Java is easy to learn. The syntax of Java is based on C++ which makes easier to write the program in it.</li>
                <li>Object-Oriented: Java follows the object-oriented paradigm which allows us to maintain our code as the combination of different type of objects that incorporates both data and behavior.</li>
                <li>Portable: Java supports read-once-write-anywhere approach. We can execute the Java program on every machine. Java program (.java) is converted to bytecode (.class) which can be easily run on every machine.</li>
                <li>Platform Independent: Java is a platform independent programming language. It is different from other programming languages like C and C++ which needs a platform to be executed. Java comes with its platform on which its code is executed. Java doesn't depend upon the operating system to be executed.</li>
                <li>Secured: Java is secured because it doesn't use explicit pointers. Java also provides the concept of ByteCode and Exception handling which makes it more secured.</li>
                <li>Robust: Java is a strong programming language as it uses strong memory management. The concepts like Automatic garbage collection, Exception handling, etc. make it more robust.</li>
                <li>Architecture Neutral: Java is architectural neutral as it is not dependent on the architecture. In C, the size of data types may vary according to the architecture (32 bit or 64 bit) which doesn't exist in Java.</li>
                <li>Interpreted: Java uses the Just-in-time (JIT) interpreter along with the compiler for the program execution.</li>
                <li>High Performance: Java is faster than other traditional interpreted programming languages because Java bytecode is "close" to native code. It is still a little bit slower than a compiled language (e.g., C++).</li>
                <li>Multithreaded: We can write Java programs that deal with many tasks at once by defining multiple threads. The main advantage of multi-threading is that it doesn't occupy memory for each thread. It shares a common memory area. Threads are important for multi-media, Web applications, etc.</li>
                <li>Distributed: Java is distributed because it facilitates users to create distributed applications in Java. RMI and EJB are used for creating distributed applications. This feature of Java makes us able to access files by calling the methods from any machine on the internet.</li>
                <li>Dynamic: Java is a dynamic language. It supports dynamic loading of classes. It means classes are loaded on demand. It also supports functions from its native languages, i.e., C and C++.</li>
            </ul>
        </div>
        &nbsp;
        <button class="collapsible">What do you understand by Java virtual machine?</button>
        <div class="content">
            <p>Java Virtual Machine is a virtual machine that enables the computer to run the Java program. JVM acts like a run-time engine which calls the main method present in the Java code. JVM is the specification which must be implemented in the computer system. The Java code is compiled by JVM to be a Bytecode which is machine independent and close to the native code.</p>
        </div>
        &nbsp;
        <button class="collapsible">What is the difference between JDK, JRE, and JVM?</button>
        <div class="content">
            <p>JVM is an acronym for Java Virtual Machine; it is an abstract machine which provides the runtime environment in which Java bytecode can be executed. It is a specification which specifies the working of Java Virtual Machine. Its implementation has been provided by Oracle and other companies. Its implementation is known as JRE. JVMs are available for many hardware and software platforms (so JVM is platform dependent). It is a runtime instance which is created when we run the Java class. There are three notions of the JVM: specification, implementation, and instance.</p>
            <p>JRE stands for Java Runtime Environment. It is the implementation of JVM. The Java Runtime Environment is a set of software tools which are used for developing Java applications. It is used to provide the runtime environment. It is the implementation of JVM. It physically exists. It contains a set of libraries + other files that JVM uses at runtime.</p>
            <p>JDK is an acronym for Java Development Kit. It is a software development environment which is used to develop Java applications and applets. It physically exists. It contains JRE + development tools. JDK is an implementation of any one of the below given Java Platforms released by Oracle Corporation:</p>
            <ul>
                <li>Standard Edition Java Platform</li>
                <li>Enterprise Edition Java Platform</li>
                <li>Micro Edition Java Platform</li>
            </ul>
        </div>
        &nbsp;
        <button class="collapsible">How many types of memory areas are allocated by JVM?</button>
        <div class="content">
            <ol>
                <li>Class(Method) Area: Class Area stores per-class structures such as the runtime constant pool, field, method data, and the code for methods.</li>
                <li>Heap: It is the runtime data area in which the memory is allocated to the objects</li>
                <li>Stack: Java Stack stores frames. It holds local variables and partial results, and plays a part in method invocation and return. Each thread has a private JVM stack, created at the same time as the thread. A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes.</li>
                <li>Program Counter Register: PC (program counter) register contains the address of the Java virtual machine instruction currently being executed.</li>
                <li>Native Method Stack: It contains all the native methods used in the application.</li>
            </ol>
        </div>
        &nbsp;
        <button class="collapsible">What is JIT compiler?</button>
        <div class="content">
            <p>Just-In-Time(JIT) compiler: It is used to improve the performance. JIT compiles parts of the bytecode that have similar functionality at the same time, and hence reduces the amount of time needed for compilation. Here the term “compiler” refers to a translator from the instruction set of a Java virtual machine (JVM) to the instruction set of a specific CPU.</p>
        </div>
        &nbsp;
        <button class="collapsible">What is the platform?</button>
        <div class="content">
            <p>A platform is the hardware or software environment in which a piece of software is executed. There are two types of platforms, software-based and hardware-based. Java provides the software-based platform.</p>
        </div>
        &nbsp;
        <button class="collapsible">What are the main differences between the Java platform and other platforms?</button>
        <div class="content">
            <p>Java is the software-based platform whereas other platforms may be the hardware platforms or software-based platforms.</p>
            <p>Java is executed on the top of other hardware platforms whereas other platforms can only have the hardware components.</p>
        </div>
        &nbsp;
        <button class="collapsible">What gives Java its 'write once and run anywhere' nature?</button>
        <div class="content">
            <p>The bytecode. Java compiler converts the Java programs into the class file (Byte Code) which is the intermediate language between source code and machine code. This bytecode is not platform specific and can be executed on any computer.</p>
        </div>
        &nbsp;
        <button class="collapsible">What is classloader?</button>
        <div class="content">
            <p>Classloader is a subsystem of JVM which is used to load class files. Whenever we run the java program, it is loaded first by the classloader. There are three built-in classloaders in Java.</p>
            <ol>
                <li>Bootstrap ClassLoader: This is the first classloader which is the superclass of Extension classloader. It loads the rt.jar file which contains all class files of Java Standard Edition like java.lang package classes, java.net package classes, java.util package classes, java.io package classes, java.sql package classes, etc.</li>
                <li>Extension ClassLoader: This is the child classloader of Bootstrap and parent classloader of System classloader. It loads the jar files located inside $JAVA_HOME/jre/lib/ext directory.</li>
                <li>System/Application ClassLoader: This is the child classloader of Extension classloader. It loads the class files from the classpath. By default, the classpath is set to the current directory. You can change the classpath using "-cp" or "-classpath" switch. It is also known as Application classloader.</li>
            </ol>
        </div>
        &nbsp;
        <button class="collapsible">Is Empty .java file name a valid source file name?</button>
        <div class="content">
            <p>Yes, Java allows to save our java file by .java only, we need to compile it by javac .java and run by java classname.</p>
        </div>
        &nbsp;
        <button class="collapsible">Is delete, next, main, exit or null keyword in java?</button>
        <div class="content">
            <p>No</p>
        </div>
        &nbsp;
        <button class="collapsible">If I don't provide any arguments on the command line, then what will the value stored in the String array passed into the main() method, empty or NULL?</button>
        <div class="content">
            <p>It is empty, but not null.</p>
        </div>
        &nbsp;
        <button class="collapsible">What if I write static public void instead of public static void?</button>
        <div class="content">
            <p>The program compiles and runs correctly because the order of specifiers doesn't matter in Java.</p>
        </div>
        &nbsp;
        <button class="collapsible">What is the default value of the local variables?</button>
        <div class="content">
            <p>The local variables are not initialized to any default value, neither primitives nor object references.</p>
        </div>
        &nbsp;
        <button class="collapsible">What are the various access specifiers in Java?</button>
        <div class="content">
            <p>In Java, access specifiers are the keywords which are used to define the access scope of the method, class, or a variable. In Java, there are four access specifiers given below.</p>
            <ul>
                <li>Public The classes, methods, or variables which are defined as public, can be accessed by any class or method.</li>
                <li>Protected Protected can be accessed by the class of the same package, or by the sub-class of this class, or within the same class.</li>
                <li>Default Default are accessible within the package only. By default, all the classes, methods, and variables are of default scope.</li>
                <li>Private The private class, methods, or variables defined as private can be accessed within the class only.</li>
            </ul>
        </div>
        &nbsp;
        <button class="collapsible">What is the purpose of static methods and variables?</button>
        <div class="content">
            <p>The methods or variables defined as static are shared among all the objects of the class. The static is the part of the class and not of the object. The static variables are stored in the class area, and we do not need to create the object to access such variables. Therefore, static is used in the case, where we need to define variables or methods which are common to all the objects of the class.</p>
        </div>
        &nbsp;
        <button class="collapsible">What are the advantages of Packages in Java?</button>
        <div class="content">
            <ul>
                <li>Packages avoid the name clashes.</li>
                <li>The Package provides easier access control.</li>
                <li>We can also have the hidden classes that are not visible outside and used by the package.</li>
                <li>It is easier to locate the related classes.</li>
            </ul>
        </div>
        &nbsp;
        <button class="collapsible">What is the output of the following Java program?</button>
        <div class="content">
            <div class="code">
                class Test {<br>
                &emsp;public static void main (String args[]) {<br>
                &emsp;&emsp;System.out.println(10 + 20 + "Javatpoint");<br>
                &emsp;&emsp;System.out.println("Javatpoint" + 10 + 20);<br>
                &emsp;}<br>
                }
            </div>
            <p>The output of the above code will be:</p>
            <div class="code">
                30Javatpoint<br>
                Javatpoint1020
            </div>
            <p>In the first case, 10 and 20 are treated as numbers and added to be 30. Now, their sum 30 is treated as the string and concatenated with the string Javatpoint. Therefore, the output will be 30Javatpoint.</p>
            <p>In the second case, the string Javatpoint is concatenated with 10 to be the string Javatpoint10 which will then be concatenated with 20 to be Javatpoint1020.</p>
        </div>
        &nbsp;
        <button class="collapsible">What is the output of the following Java program?</button>
        <div class="content">
            <div class="code">
                class Test {<br>
                &emsp;public static void main (String args[]) {<br>
                &emsp;&emsp;System.out.println(10 * 20 + "Javatpoint");<br>
                &emsp;&emsp;System.out.println("Javatpoint" + 10 * 20);<br>
                &emsp;}<br>
                }
            </div>
            <p>The output of the above code will be:</p>
            <div class="code">
                200Javatpoint<br>
                Javatpoint200
            </div>
            <p>In the first case, The numbers 10 and 20 will be multiplied first and then the result 200 is treated as the string and concatenated with the string Javatpoint to produce the output 200Javatpoint.</p>
            <p>In the second case, The numbers 10 and 20 will be multiplied first to be 200 because the precedence of the multiplication is higher than addition. The result 200 will be treated as the string and concatenated with the string Javatpoint to produce the output as Javatpoint200.</p>
        </div>
        &nbsp;
        <button class="collapsible">What is the output of the following Java program?</button>
        <div class="content">
            <div class="code">
                class Test {<br>
                &emsp;public static void main (String args[]) {<br>
                &emsp;&emsp;for(int i=0; 0; i++) {<br>
                &emsp;&emsp;&emsp;System.out.println("Hello Javatpoint");<br>
                &emsp;&emsp;}<br>
                &emsp;}<br>
                }
            </div>
            <p>The above code will give the compile-time error because the for loop demands a boolean value in the second part and we are providing an integer value, i.e., 0.</p>
        </div>
    </div>
    &nbsp;
    <button class="collapsible">Core Java - OOPs Concepts: Initial OOPs Interview Questions</button>
    <div class="content">
        <button class="collapsible">What is object-oriented paradigm?</button>
        <div class="content">
            <p>It is a programming paradigm based on objects having data and methods defined in the class to which it belongs. Object-oriented paradigm aims to incorporate the advantages of modularity and reusability. Objects are the instances of classes which interacts with one another to design applications and programs. There are the following features of the object-oriented paradigm.</p>
            <ul>
                <li>Follows the bottom-up approach in program design.</li>
                <li>Focus on data with methods to operate upon the object's data</li>
                <li>Includes the concept like Encapsulation and abstraction which hides the complexities from the user and show only functionality.</li>
                <li>Implements the real-time approach like inheritance, abstraction, etc.</li>
                <li>The examples of the object-oriented paradigm are C++, Simula, Smalltalk, Python, C#, etc.</li>
            </ul>
        </div>
        &nbsp;
        <button class="collapsible">What is an object?</button>
        <div class="content">
            <p>The Object is the real-time entity having some state and behavior. In Java, Object is an instance of the class having the instance variables as the state of the object and the methods as the behavior of the object. The object of a class can be created by using the new keyword.</p>
        </div>
        &nbsp;
        <button class="collapsible">What is the difference between an object-oriented programming language and object-based programming language?</button>
        <div class="content">
            <ul>
                <li>Object-oriented languages follow all the concepts of OOPs whereas, the object-based language doesn't follow all the concepts of OOPs like inheritance and polymorphism.</li>
                <li>Object-oriented languages do not have the inbuilt objects whereas Object-based languages have the inbuilt objects, for example, JavaScript has window object.</li>
                <li>Examples of object-oriented programming are Java, C#, Smalltalk, etc. whereas the examples of object-based languages are JavaScript, VBScript, etc.</li>
            </ul>
        </div>
        &nbsp;
        <button class="collapsible">What will be the initial value of an object reference which is defined as an instance variable?</button>
        <div class="content">
            <p>All object references are initialized to null in Java.</p>
        </div>
    </div>
    &nbsp;
    <button class="collapsible">Core Java - OOPs: Constructor Interview Questions</button>
    <div class="content">
        <button class="collapsible">What is the constructor?</button>
        <div class="content">
            <p>The constructor can be defined as the special type of method that is used to initialize the state of an object. It is invoked when the class is instantiated, and the memory is allocated for the object. Every time, an object is created using the new keyword, the default constructor of the class is called. The name of the constructor must be similar to the class name. The constructor must not have an explicit return type.</p>
        </div>
        &nbsp;
        <button class="collapsible">How many types of constructors are used in Java?</button>
        <div class="content">
            <p>Default Constructor: default constructor is the one which does not accept any value. The default constructor is mainly used to initialize the instance variable with the default values. It can also be used for performing some useful task on object creation. A default constructor is invoked implicitly by the compiler if there is no constructor defined in the class.</p>
            <p>Parameterized Constructor: The parameterized constructor is the one which can initialize the instance variables with the given values. In other words, we can say that the constructors which can accept the arguments are called parameterized constructors.</p>
        </div>
        &nbsp;
        <button class="collapsible">What is the purpose of a default constructor?</button>
        <div class="content">
            <p>The purpose of the default constructor is to assign the default value to the objects. The java compiler creates a default constructor implicitly if there is no constructor in the class.</p>
            <div class="code">
                class Student{<br>
                &emsp;int id;<br>
                &emsp;String name;<br><br>
                &emsp;void display() {<br>
                &emsp;&emsp;System.out.println(id+" "+name);<br>
                &emsp;}<br><br>
                &emsp;public static void main(String args[]){<br>
                &emsp;&emsp;Student s1=new Student();<br>
                &emsp;&emsp;Student s2=new Student();<br>
                &emsp;&emsp;s1.display();<br>
                &emsp;&emsp;s2.display();<br>
                &emsp;}<br>
                }
            </div>
            <p>Output:</p>
            <div class="code">
                0 null<br>
                0 null
            </div>
            <p>In the above class, you are not creating any constructor, so compiler provides you a default constructor. Here 0 and null values are provided by default constructor.</p>
        </div>
        &nbsp;
        <button class="collapsible">Does constructor return any value?</button>
        <div class="content">
            <p>Yes, The constructor implicitly returns the current instance of the class (You can't use an explicit return type with the constructor).</p>
        </div>
        &nbsp;
        <button class="collapsible">Is constructor inherited?</button>
        <div class="content">
            <p>No, The constructor is not inherited.</p>
        </div>
        &nbsp;
        <button class="collapsible">Can you make a constructor final?</button>
        <div class="content">
            <p>No, the constructor can't be final.</p>
        </div>
        &nbsp;
        <button class="collapsible">Can we overload the constructors?</button>
        <div class="content">
            <p>Yes, the constructors can be overloaded by changing the number of arguments accepted by the constructor or by changing the data type of the parameters.</p>
            <div class="code">
                class Test {<br>
                &emsp;int i;<br>
                &emsp;public Test(int k) {<br>
                &emsp;&emsp;i=k;<br>
                &emsp;}<br>
                &emsp;public Test(int k, int m) {<br>
                &emsp;&emsp;System.out.println("Hi I am assigning the value max(k, m) to i");<br>
                &emsp;&emsp;if(k>m) {<br>
                &emsp;&emsp;&emsp;i=k;<br>
                &emsp;&emsp;} else {<br>
                &emsp;&emsp;&emsp;i=m;<br>
                &emsp;&emsp;}<br>
                &emsp;}<br>
                }<br>
                public class Main {<br>
                &emsp;public static void main (String args[]) {<br>
                &emsp;&emsp;Test test1 = new Test(10);<br>
                &emsp;&emsp;Test test2 = new Test(12, 15);<br>
                &emsp;&emsp;System.out.println(test1.i);<br>
                &emsp;&emsp;System.out.println(test2.i);<br>
                &emsp;}<br>
                }
            </div>
            <p>In the above program, The constructor Test is overloaded with another constructor. In the first call to the constructor, The constructor with one argument is called, and will be initialized with the value 10. However, In the second call to the constructor, The constructor with the 2 arguments is called, and will be initialized with the value 15.</p>
        </div>
        &nbsp;
        <button class="collapsible">What do you understand by copy constructor in Java?</button>
        <div class="content">
            <p>There is no copy constructor in java. However, there are many ways to copy the values of one obejct into another.</p>
            <ul>
                <li>By constructor</li>
                <li>By assigning the values of one object into another</li>
                <li>By clone() method of Object class</li>
            </ul>
            <div class="code">
                &emsp;class Student {<br>
                &emsp;&emsp;int id;<br>
                &emsp;&emsp;String name;<br>
                &emsp;<mark>//constructor to initialize integer and string</mark><br>
                &emsp;Student6(int i,String n){<br>
                &emsp;&emsp;id = i;<br>
                &emsp;&emsp;name = n;<br>
                &emsp;}<br>
                &emsp;<mark>//constructor to initialize another object</mark><br>
                &emsp;Student(Student s){<br>
                &emsp;&emsp;id = s.id;<br>
                &emsp;&emsp;name =s.name;<br>
                &emsp;}<br><br>
                &emsp;void display() {<br>
                &emsp;&emsp;System.out.println(id+" "+name);<br>
                &emsp;}<br><br>
                &emsp;public static void main(String args[]){<br>
                &emsp;&emsp;Student s1 = new Student(111,"Karan");<br>
                &emsp;&emsp;Student s2 = new Student(s1);<br>
                &emsp;&emsp;s1.display();<br>
                &emsp;&emsp;s2.display();<br>
                &emsp;}<br>
                }
            </div>
            <p>Output:</p>
            <div class="code">
                111 Karan<br>
                111 Karen
            </div>
        </div>
        &nbsp;
        <button class="collapsible">What are the differences between the constructors and methods?</button>
        <div class="content">
            <table>
                <tr>
                    <th>Java Constructor</th>
                    <th>Java Method</th>
                </tr>
                <tr>
                    <td>A constructor is used to initialize the state of an object.	</td>
                    <td>A method is used to expose the behavior of an object.</td>
                </tr>
                <tr>
                    <td>A constructor must not have a return type.</td>
                    <td>A method must have a return type.</td>
                </tr>
                <tr>
                    <td>The constructor is invoked implicitly.</td>
                    <td>The method is invoked explicitly.</td>
                </tr>
                <tr>
                    <td>The Java compiler provides a default constructor if you don't have any constructor in a class.</td>
                    <td>The method is not provided by the compiler in any case.</td>
                </tr>
                <tr>
                    <td>The constructor name must be same as the class name.</td>
                    <td>The method name may or may not be same as class name.</td>
                </tr>
            </table>
        </div>
        &nbsp;
        <button class="collapsible">What is the output of the following Java program?</button>
        <div class="content">
            <div class="code">
                public class Test {<br>
                &emsp;Test(int a, int b) {<br>
                &emsp;&emsp;System.out.println("a = "+a+" b = "+b);<br>
                &emsp;}<br>
                &emsp;Test(int a, float b) {<br>
                &emsp;&emsp;System.out.println("a = "+a+" b = "+b);<br>
                &emsp;}<br>
                &emsp;public static void main (String args[]) {<br>
                &emsp;&emsp;byte a = 10;<br>
                &emsp;&emsp;byte b = 15;<br>
                &emsp;&emsp;Test test = new Test(a,b);<br>
                &emsp;}<br>
                }
            </div>
            <p>Output:</p>
            <div class="code">
                a = 10 b = 15
            </div>
            <p>Here, the data type of the variables a and b, i.e., byte gets promoted to int, and the first parameterized constructor with the two integer parameters is called.</p>
        </div>
        &nbsp;
        <button class="collapsible">What is the output of the following Java program?</button>
        <div class="content">
            <div class="code">
                class Test {<br>
                &emsp;int i;<br>
                }<br>
                public class Main {<br>
                &emsp;public static void main (String args[]) {<br>
                &emsp;&emsp;Test test = new Test();<br>
                &emsp;&emsp;System.out.println(test.i);<br>
                &emsp;}<br>
                }
            </div>
            <p>The output of the program is 0 because the variable i is initialized to 0 internally. As we know that a default constructor is invoked implicitly if there is no constructor in the class, the variable i is initialized to 0 since there is no constructor in the class.</p>
        </div>
        &nbsp;
        <button class="collapsible">What is the output of the following Java program?</button>
        <div class="content">
            <div class="code">
                class Test {<br>
                &emsp;int test_a, test_b;<br>
                &emsp;Test(int a, int b) {<br>
                &emsp;&emsp;test_a = a;<br>
                &emsp;&emsp;test_b = b;<br>
                &emsp;}<br>
                &emsp;public static void main (String args[]) {<br>
                &emsp;&emsp;Test test = new Test();<br>
                &emsp;&emsp;System.out.println(test.test_a+" "+test.test_b);<br>
                &emsp;}<br>
                }
            </div>
            <p>There is a compiler error in the program because there is a call to the default constructor in the main method which is not present in the class. However, there is only one parameterized constructor in the class Test. Therefore, no default constructor is invoked by the constructor implicitly.</p>
        </div>
    </div>
    &nbsp;
    <button class="collapsible">Core Java - OOPs Concepts: static keyword Interview Questions</button>
    <div class="content">
        <button class="collapsible">What is the static variable?</button>
        <div class="content">
            <p>The static variable is used to refer to the common property of all objects (that is not unique for each object), e.g., The company name of employees, college name of students, etc. Static variable gets memory only once in the class area at the time of class loading. Using a static variable makes your program more memory efficient (it saves memory). Static variable belongs to the class rather than the object.</p>
            <div class="code">
                class Student{<br>
                &emsp;int rollno;<br>
                &emsp;String name;<br>
                &emsp;static String college ="ITS";<br><br>
                &emsp;Student(int r,String n){<br>
                &emsp;&emsp;rollno = r;<br>
                &emsp;&emsp;name = n;<br>
                &emsp;}<br><br>
                &emsp;void display () {<br>
                &emsp;&emsp;System.out.println(rollno+" "+name+" "+college);<br>
                &emsp;}<br><br>
                &emsp;public static void main(String args[]){<br>
                &emsp;&emsp;Student s1 = new Student(111,"Karan");<br>
                &emsp;&emsp;Student s2 = new Student(222,"Aryan");<br>
                &emsp;&emsp;s1.display();<br>
                &emsp;&emsp;s2.display();<br>
                &emsp;}<br>
                }
            </div>
            <p>Output:</p>
            <div class="code">
                111 Karan ITS<br>
                222 Aryan ITS
            </div>
        </div>
        &nbsp;
        <button class="collapsible">What is the static method?</button>
        <div class="content">
            <ul>
                <li>A static method belongs to the class rather than the object.</li>
                <li>There is no need to create the object to call the static methods.</li>
                <li>A static method can access and change the value of the static variable.</li>
            </ul>
        </div>
        &nbsp;
        <button class="collapsible"></button>
        <div class="content">
            <p></p>
        </div>
        &nbsp;
        <button class="collapsible"></button>
        <div class="content">
            <p></p>
        </div>
        &nbsp;
        <button class="collapsible"></button>
        <div class="content">
            <p></p>
        </div>
        &nbsp;
        <button class="collapsible"></button>
        <div class="content">
            <p></p>
        </div>
        &nbsp;
        <button class="collapsible"></button>
        <div class="content">
            <p></p>
        </div>
        &nbsp;
        <button class="collapsible"></button>
        <div class="content">
            <p></p>
        </div>
        &nbsp;
        <button class="collapsible"></button>
        <div class="content">
            <p></p>
        </div>
        &nbsp;
        <button class="collapsible"></button>
        <div class="content">
            <p></p>
        </div>
        &nbsp;
        <button class="collapsible"></button>
        <div class="content">
            <p></p>
        </div>
        &nbsp;
        <button class="collapsible"></button>
        <div class="content">
            <p></p>
        </div>
        &nbsp;
    </div>
    </div>
    &nbsp;
    <button class="collapsible">Constructors</button>
    <div class="content">
        <h2>Constructor Questions</h2>
        <h3>What is a Constructor?</h3>
        <p>Constructors are used to initialize the object’s state. Like methods, a constructor also contains collection of statements(i.e. instructions) that are executed at time of Object creation.</p>
        <h3>Do we have Copy Constructor in Java?</h3>
        <p>Java doesn't create a default copy constructor if you don't write your own.</p>
        <h3>What is Constructor Chaining</h3>
        <p>Constructor Chaining is a technique of calling another constructor from one constructor. this() is used to call same class constructor where as super() is used to call super class constructor.</p>
        <h3>Can we call sub class constructor from super class constructor?</h3>
        <p>No. There is no way in java to call sub class constructor from a super class constructor.</p>
        <h3>What happens if you keep a return type for a constructor?</h3>
        <p>Ideally, Constructor must not have a return type. By definition, if a method has a return type, it’s not a constructor. It will be treated as a normal method. But compiler gives a warning saying that method has a constructor name.</p>
        <h3>What is No-arg constructor?</h3>
        <p>Constructor without arguments is called no-arg constructor. Default constructor in java is always a no-arg constructor.</p>
        <h3>How a no – argument constructor is different from default Constructor?</h3>
        <p>If a class contains no constructor declarations, then a default constructor with no formal parameters and no throws clause is implicitly declared. If the class being declared is the primordial class Object, then the default constructor has an empty body. Otherwise, the default constructor simply invokes the superclass constructor with no arguments.</p>
        <h3>What are private constructors and where are they used?</h3>
        <p>Like any method we can provide access specifier to the constructor. If it’s made private, then it can only be accessed inside the class.</p>
        <p>The major scenarios where we use private constructor:</p>
        <ul>
            <li>Internal Constructor chaining</li>
            <li>Singleton class design pattern</li>
        </ul>
        <h3>When do we need Constructor Overloading?</h3>
        <p>Sometimes there is a need of initializing an object in different ways. This can be done using constructor overloading. Different constructors can do different work by implementing different line of codes and are called based on the type and number of parameters passed.</p>
        <h3>Do we have destructors in Java?</h3>
        <p>No, Because Java is a garbage collected language you cannot predict when (or even if) an object will be destroyed. Hence there is no direct equivalent of a destructor.</p>
    </div>
    &nbsp;
    <button class="collapsible">Lambda Expressions</button>
    <div class="content">
    <h2>Lambda Expression Questions</h2>
        <h3>What is a lambda expression?</h3>
        <p>Lambda expression in itself is an anonymous method i.e. a method with no name which is used to provide implementation of the method defined by a functional interface.</p>
        <h3>What is a functional interface?</h3>
        <p>A functional interface is an interface with only one abstract method.</p>
        <h3>How do you use lambda expression with functional interfaces?</h3>
        <p>Lambda expression provides implementation of the abstract method defined by the functional interface.</p>
        <h3>What is block lambda expression?</h3>
        <p>A block lambda is the lambda expression where the right side of the lambda expression is a block of code.</p>
        <h3>Can we have a generic functional interface?</h3>
        <p>Since lambda expression doesn't have type parameters of its own so it can't be generic. But the functional interface that specifies the target type for the lambda expression can be generic.</p>
        <h3>What is functional interface annotation?</h3>
        <p>Java 8 also introduces an annotation @FunctionalInterface to be used with functional interface.</p>
        <h3>Is it mandatory to mark functional interface with @FunctionalInterface annotation?</h3>
        <p>It is not mandatory to mark functional interface with @FunctionalInterface annotation, it is more of a best practice to do that and also gives a surety that no other abstract method will be added accidentally to the functional interface.</p>
        <h3>What is effective final in Java? What is variable capture?</h3>
        <p>A lambda expression may only use local variable whose value doesn't change. That restriction is referred as "variable capture".</p>
        <p>The local variables that a lambda expression may use are known as "effectively final". An effectively final variable is one whose value does not change after it is first assigned.</p>
        <h3>Can lambda expression throw exception? Is there any restriction in lambda expression exception handling?</h3>
        <p>A lambda expression can throw an exception but lambda expression must throw exception compatible with those specified in the throws clause of the functional interface method.</p>
        <h3>What is method reference in Java 8?</h3>
        <ul>
            <li>Lambda expressions can be used to call an existing method.</li>
            <li>General form of Method reference - ClassName (or object)::methodName</li>
            <li>Class name or instance is separated from the method name by a double colon.</li>
        </ul>
        <h3>What are the types of method reference?</h3>
        <table>
            <tr>
                <th>Kind</th>
                <th>Example</th>
                <th>Syntax</th>
            </tr>
            <tr>
                <td>Reference to a static method</td>
                <td>ContainingClass::staticMethodName</td>
                <td>ClassName::methodName</td>
            </tr>
            <tr>
                <td>Reference to an instance method of a particular object</td>
                <td>containingObject::instanceMethodName</td>
                <td>objRef::methodName</td>
            </tr>
            <tr>
                <td>Reference to an instance method of an arbitrary object of a particular type</td>
                <td>ContainingType::methodName</td>
                <td>ClassName::instanceMethodName</td>
            </tr>
            <tr>
                <td>Reference to a constructor</td>
                <td>ClassName::new</td>
                <td>classname::new</td>
            </tr>
        </table>
    </div>
    &nbsp;
    <button class="collapsible">Servlets</button>
    <div class="content">
    <h2>Servlet Questions</h2>
        <h3>What is a servlet?</h3>
        <p>Java Servlet is server side technologies to extend the capability of web servers by providing support for dynamic response and data persistence.</p>
        <p>The javax.servlet and javax.servlet.http packages provide interfaces and classes for writing our own servlets.</p>
        <h3>Can you explain the Servlet Container?</h3>
        <p>It provides the runtime environment for JavaEE (j2ee) applications. The client/user can request only static WebPages from the server. If the user wants to read the web pages as per input then the servlet container is used in java.</p>
        <h3>What are the common tasks performed by Servlet Container?</h3>
        <ul>
            <li>Communication Support: Servlet Container provides easy way of communication between web client (Browsers) and the servlets and JSPs.</li>
            <li>Lifecycle and Resource Management: Servlet Container takes care of managing the life cycle of servlet. From the loading of servlets into memory, initializing servlets, invoking servlet methods and to destroy them.</li>
            <li>Multi-threading Support: Container creates new thread for every request to the servlet and provide them request and response objects to process. So servlets are not initialized for each request and saves time and memory.</li>
            <li>JSP Support: JSPs do not look like normal java classes but every JSP in the application is compiled by container and converted to Servlet and then container manages them like other servlets.</li>
            <li>Miscellaneous Task: Servlet container manages the resource pool, perform memory optimizations, execute garbage collector, provides security configurations, support for multiple applications, hot deployment and several other tasks behind the scene that makes a developer life easier.</li>
        </ul>
        <h3>What is the ServletConfig object?</h3>
        <ul>
            <li>ServletConfig is used to pass configuration information to a single Servlet.</li>
            <li>The Servlet container is responsible for instantiating this object.</li>
            <li>Every servlet has its own ServletConfig object.</li>
            <li>We can provide servlet init parameters in the web.xml file or through the use of annotation.</li>
        </ul>
        <h3>What is ServletContext object?</h3>
        <ul>
            <li>The ServletContext object provide access to web application parameters to the servlets.</li>
            <li>This object is available to all the servlets in the web application.</li>
            <li>When we want some init parameters to be available to multiple or all of the servlets in the web application, we can use ServletContext object and define parameters in web.xml using the &lt;context-param&gt; element.</li>
        </ul>
        <h3>ServletConfig vs ServletContext</h3>
        <ul>
            <li>ServletConfig is a unique object per servlet whereas ServletContext is a unique object for complete application.</li>
            <li>ServletConfig is used to provide init parameters to the servlet whereas ServletContext is used to provide application level init parameters that all other servlets can use.</li>
            <li>We can’t set attributes in ServletConfig object whereas we can set attributes in ServletContext that other servlets can use in their implementation.</li>
        </ul>
        <h3>What is the Request Dispatcher?</h3>
        <p>An interface used to forward the request to another resource that can be HTML, JSP or another servlet in the same application. It is used for inter-servlet communication.</p>
        <p>There are two methods defined in this interface:</p>
        <ol>
            <li>void forward(ServletRequest request, ServletResponse response)</li>
            <ul>
                <li>Forwards the request from a servelt to another resource on the server.</li>
            </ul>
            <li>void include (ServletRequest request, ServletResponse response)</li>
            <ul>
                <li>Includes the content of a resource in the response.</li>
            </ul>
        </ol>
        <h3>How do we call one servlet from another servlet?</h3>
        <ul>
            <li>We can use RequestDispatcher forward() method to forward the processing of a request to another servlet.</li>
            <li>We can use RequestDispatcher include() method to include another servlets output to the response.</li>
        </ul>
        <h3>How can we create deadlock situation in servlet?</h3>
        <p>We can create deadlock in servlet by making a loop of method invocation, just call doPost() method from doGet() method and doGet() method to doPost() method to create deadlock situation in servlet.</p>
        <h3>Do we need to override service() method?</h3>
        <p>When servlet container receives client request, it invokes the service() method which in turn invokes the doGet(), doPost() methods based on the HTTP method of request. The whole purpose of service() method is to forward to request to corresponding HTTP method implementations. So, there would be no reason to overrid the service() method.</p>
        <h3>What are the phases of servlet life cycle?</h3>
        <ul>
            <li>Servlet Class Loading – When container receives request for a servlet, it first loads the class into memory and calls it’s default no-args constructor.</li>
            <li>Servlet Class Initialization - The container then initializes the ServletContext object for the servlet and invokes it’s init method by passing servlet config object.</li>
            <li>Request Handling - For every client request, servlet container spawns a new thread and invokes the service() method by passing the request and response object reference.</li>
            <li>Removal from Service - When container stops or we stop the application, servlet container destroys the servlet class by invoking it’s destroy() method.</li>
        </ul>
        <h3>What are life cycle methods of a servlet?</h3>
        <ol>
            <li>public void init(ServletConfig config)</li>
            <ul>
                <li>Used by the container to initialize the servlet, this method is invoked only once in the lifecycle of servlet.</li>
            </ul>
            <li>public void service(ServletRequest request, ServletResponse response)</li>
            <ul>
                <li>This method is called once for every request, container can’t invoke service() method unless init() method is executed.</li>
            </ul>
            <li>public void destroy()</li>
            <ul>
                <li>This method is invoked once when servlet is unloaded from memory.</li>
            </ul>
        </ol>
        <h3>What are different methods of session management in servlets?</h3>
        <ul>
            <li>HTML Hidden Fields</li>
            <li>URL Rewriting: When using HttpSession and cookies are dissabled, Then URL rewriting is used. It involes encoding the URL to pass information to another resource.</li>
            <li>HttpSession</li>
            <li>Cookies: Text data sent by the server to the client and it gets saved at the client local machine.</li>
        </ul>
    </div>
    &nbsp;
    <button class="collapsible">JDBC</button>
    <div class="content">
        <h3>What is JDBC API and when do we use it?</h3>
        <p>Java DataBase Connectivity API allows us to work with relational databases. JDBC API interfaces and classes are part of java.sql and javax.sql package. We can use JDBC API to get the database connection, run SQL queries and stored procedures in the database server and process the results.</p>
        <h3>What are different types of JDBC Drivers?</h3>
        <p>There are four types of JDBC drivers.</p>
        <table>
            <tr>
                <td>JDBC-ODBC Bridge plus ODBC Driver (Type 1)</td>
                <td>Uses ODBC driver to connect to database. We should have ODBC drivers installed to connect to database, that’s why this driver is almost obsolete.</td>
            </tr>
            <tr>
                <td>Native API partly Java technology-enabled driver (Type 2)</td>
                <td>Converts JDBC class to the client API for the database servers. We should have database client API installed. Because of extra dependency on database client API drivers, this is also not preferred driver.</td>
            </tr>
            <tr>
                <td>Pure Java Driver for Database Middleware (Type 3)</td>
                <td>Sends the JDBC calls to a middleware server that can connect to different types of databases. We should have a middleware server installed to work with this driver. This adds to extra network calls and slow performance and that's why it's not widely used JDBC driver.</td>
            </tr>
            <tr>
                <td>Direct-to-Database Pure Java Driver (Type 4)</td>
                <td>Converts the JDBC calls to the network protocol understood by the database server. This solution is simple and suitable for database connectivity over the network. However for this solution, we should use database specific drivers, for example OJDBC jars by Oracle for Oracle DB and MySQL Connector/J for MySQL databases.</td>
            </tr>
        </table>
        <h3>How does JDBC API help us achieve a loose coupling between Java Program and JDBC Drivers API?</h3>
        <p>JDBC API uses Java Reflection API to achieve loose coupling between java programs and JDBC Drivers. All the programming is done in terms of JDBC API and Driver comes in picture only when it’s loaded through reflection using Class.forName() method.</p>
        <h3>What is JDBC Connection? Explain the steps to get a Database connection.</h3>
        <p>JDBC Connection is like a Session created with the database server.</p>
        <p>Creating a JDBC Connection is very easy and requires two steps:</p>
        <ol>
            <li>Register and Load the Driver: Using Class.forName(), Driver class is registered to the DriverManager and loaded in the memory.</li>
            <li>Use DriverManager to get the Connection object: We get connection object from DriverManager.getConnection() by passing Database URL String, username and password as arguments.</li>
        </ol>
        <h3>What is the use of JDBC DriverManager class?</h3>
        <p>JDBC DriverManager is the factory class through which we get the Database Connection object.</p>
        <p>When we load the JDBC Driver class, it registers itself to the DriverManager.</p>
        <p>Then when we call DriverManager.getConnection() method by passing the database configuration details, DriverManager uses the registered drivers to get the Connection and return it to the caller program.</p>
        <h3>How do you get the Database server details in a java program?</h3>
        <p>We can use DatabaseMetaData object to get the database server details. When the database connection is created successfully, we can get the meta data object by calling getMetaData() method.</p>
        <h3>What is JDBC Statement?</h3>
        <p>JDBC API Statement is used to execute SQL queries in the database. We can create the Statement object by calling Connection createStatement() method. We can use Statement to execute static SQL queries by passing query through different execute methods such as execute(), executeQuery(), executeUpdate() etc.</p>
        <p>Since the query is generated in the java program, if the user input is not properly validated it can lead to an SQL injection.</p>
        <h3>What is the difference between execute, executeQuery and executeUpdate?</h3>
        <ul>
            <li>Statement execute(String query) is used to execute any SQL query and it returns TRUE if the result is an ResultSet such as running Select queries.</li>
            <p>We can use getResultSet() to get the ResultSet and getUpdateCount() method to retrieve the update count.</p>
            <li>Statement executeQuery(String query) is used to execute Select queries and returns the ResultSet.</li>
            <li>Statement executeUpdate(String query) is used to execute Insert/Update/Delete (DML) statements or DDL statements that returns nothing. The output is int and equals the row count for SQL Data Manipulation Language (DML) statements. For DDL statements, the output is 0.</li>
        </ul>
        <h3>What is JDBC PreparedStatement?</h3>
        <p>JDBC PreparedStatement object represents a precompiled SQL statement.</p>
        <p>Since PreparedStatement is precompiled, it can then be used to efficiently execute this statement multiple times. PreparedStatement is better choice that Statement because it automatically escapes the special characters and avoid SQL injection attacks.</p>
        <h3>How to set NULL values in JDBC PreparedStatement?</h3>
        <p>We can use PreparedStatement setNull() method to bind the null variable to a parameter. The setNull method takes index and SQL Types as argument, for example: ps.setNull(10, java.sql.Types.INTEGER);</p>
        <h3>What are the benefits of PreparedStatement over Statement?</h3>
        <ul>
            <li>PreparedStatement helps us in preventing SQL injection attacks because it automatically escapes the special characters.</li>
            <li>PreparedStatement allows us to execute dynamic queries with parameter inputs.</li>
            <li>PreparedStatement is faster than Statement. It becomes more visible when we reuse the PreparedStatement or use it’s batch processing methods for executing multiple queries.</li>
            <li>PreparedStatement helps us in writing object Oriented code with setter methods whereas with Statement we have to use String Concatenation to create the query. If there are multiple parameters to set, writing Query using String concatenation looks very ugly and error prone.</li>
        </ul>
        <h3>What is the limitation of PreparedStatement and how to overcome it?</h3>
        <p>One of the limitation of PreparedStatement is that we can’t use it directly with IN clause statements.</p>
        <ol>
            <li>Execute Single Queries – very slow performance and not recommended</li>
            <li>Using Stored Procedure – Database specific and hence not suitable for multiple database applications.</li>
            <li>Creating PreparedStatement Query dynamically – Good approach but looses the benefit of cached PreparedStatement.</li>
            <li>Using NULL in PreparedStatement Query – A good approach when you know the maximum number of variables inputs, can be extended to allow unlimited parameters by executing in parts.</li>
        </ol>
        <h3>What is JDBC ResultSet?</h3>
        <p>JDBC ResultSet is like a table of data representing a database result set, which is usually generated by executing a statement that queries the database.</p>
        <p>ResultSet object maintains a cursor pointing to its current row of data. Initially, the cursor is positioned before the first row. The next() method moves the cursor to the next row.</p>
        <p>A default ResultSet object is not updatable and has a cursor that moves forward only. Thus, you can iterate through it only once and only from the first row to the last row.</p>
        <h3>What is JDBC RowSet? What are different types of RowSet?</h3>
        <p>JDBC RowSet holds tabular data in more flexible ways than ResultSet.</p>
        <p>All RowSet objects are derived from ResultSet, so they have all the capabilities of ResultSet with some additional features.</p>
        <p>RowSet is divided into two types:</p>
        <ol>
            <li>Connected RowSet Objects – These objects are connected to database and are most similar to ResultSet object. JDBC API provides only one connected RowSet object javax.sql.rowset.JdbcRowSet and it’s standard implementation class is com.sun.rowset.JdbcRowSetImpl</li>
            <li>Disconnected RowSet Objects – These RowSet objects are not required to connected to a database, so they are more lightweight and serializable. They are suitable for sending data over a network. There are four types of disconnected RowSet implementations.</li>
            <ul>
                <li>CachedRowSet – They can get the connection and execute a query and read the ResultSet data to populate the RowSet data. We can manipulate and update data while it is disconnected and reconnect to database and write the changes.</li>
                <li>WebRowSet derived from CachedRowSet – They can read and write XML document.</li>
                <li>JoinRowSet derived from WebRowSet – They can form SQL JOIN without having to connect to a data source.</li>
                <li>FilteredRowSet derived from WebRowSet – We can apply filtering criteria so that only selected data is visible.</li>
            </ul>
        </ol>
        <h3>What are different types of ResultSet?</h3>
        <p>There are three types of ResultSet object.</p>
        <table>
            <tr>
                <td>ResultSet.TYPE_FORWARD_ONLY</td>
                <td>This is the default type and cursor can only move forward in the result set.</td>
            </tr>
            <tr>
                <td>ResultSet.TYPE_SCROLL_INSENSITIVE</td>
                <td>The cursor can move forward and backward, and the result set is not sensitive to changes made by others to the database after the result set was created.</td>
            </tr>
            <tr>
                <td>ResultSet.TYPE_SCROLL_SENSITIVE</td>
                <td>The cursor can move forward and backward, and the result set is sensitive to changes made by others to the database after the result set was created.</td>
            </tr>
        </table>
        <p>Based on the concurrency there are two types of ResultSet object.</p>
        <table>
            <tr>
                <td>ResultSet.CONCUR_READ_ONLY</td>
                <td>The result set is read only, this is the default concurrency type.</td>
            </tr>
            <tr>
                <td>ResultSet.CONCUR_UPDATABLE</td>
                <td>We can use ResultSet update method to update the rows data.</td>
            </tr>
        </table>
        <h3>What is the difference between ResultSet and RowSet?</h3>
        <p>RowSet objects are derived from ResultSet, so they have all the features of ResultSet with some additional features. One of the huge benefit of RowSet is that they can be disconnected and that makes it lightweight and easy to transfer over a network.</p>
        <p>Whether to use ResultSet or RowSet depends on your requirements but if you are planning to use ResultSet for longer duration, then a disconnected RowSet is better choice to free database resources.</p>
        <h3>How do we use JDBC API to call Stored Procedures?</h3>
        <p>Stored Procedures are a group of SQL queries that are compiled in the database and can be executed from JDBC API. JDBC CallableStatement can be used to execute stored procedures in the database.</p>
        <h3>What is JDBC Batch Processing and what are it’s benefits?</h3>
        <p>Sometimes we need to run bulk queries of a similar kind for a database.</p>
        <p>JDBC API supports batch processing through Statement and PreparedStatement addBatch() and executeBatch() methods.</p>
        <p>Batch Processing is faster than executing one statement at a time because the number of database calls is less.</p>
        <h3>What is JDBC Transaction Management and why do we need it?</h3>
        <p>By default when we create a database connection, it runs in auto-commit mode. It means that whenever we execute a query and it’s completed, the commit is fired automatically. So every SQL query we fire is a transaction and if we are running some DML or DDL queries, the changes are getting saved into the database after every SQL statement finishes.</p>
        <p>JDBC API provides the method setAutoCommit(boolean flag) through which we can disable the auto commit feature of the connection.</p>
        <h3>How to rollback a JDBC transaction?</h3>
        <p>We can use Connection object rollback() method to rollback the transaction. It will rollback all the changes made by the transaction and release any database locks currently held by this Connection object.</p>
        <h3>What is JDBC Savepoint? How to use it?</h3>
        <p>Sometimes a transaction can be a group of multiple statements and we would like to rollback to a particular point in the transaction. JDBC Savepoint helps us in creating checkpoints in a transaction and we can rollback to that particular checkpoint.</p>
        <h3>What is JDBC DataSource and what are its benefits?</h3>
        <p>JDBC DataSource is the interface defined in javax.sql package and it is more powerful than DriverManager for database connections.</p>
        <p>DataSource provides some additional features such as:</p>
        <ul>
            <li>Caching of PreparedStatement for faster processing</li>
            <li>Connection timeout settings</li>
            <li>Logging features</li>
            <li>ResultSet maximum size threshold</li>
            <li>Connection Pooling in servlet container using JNDI support</li>
        </ul>
        <h3>What is JDBC Connection isolation levels?</h3>
        <p>When we use JDBC Transactions for data integrity, DBMS uses locks to block access by others to the data being accessed by the transaction. DBMS uses locks to prevent Dirty Read, Non-Repeatable Reads and Phantom-Read issues.</p>
        <p>Isolation Levels:</p>
        <ul>
            <li>TRANSACTION_NONE</li>
            <li>TRANSACTION_READ_COMMITTED</li>
            <li>TRANSACTION_READ_UNCOMMITTED</li>
            <li>TRANSACTION_REPEATABLE_READ</li>
            <li>TRANSACTION_SERIALIZABLE</li>
        </ul>
        <h3>What are common JDBC Exceptions?</h3>
        <ol>
            <li>java.sql.SQLException – This is the base exception class for JDBC exceptions.</li>
            <li>java.sql.BatchUpdateException – This exception is thrown when Batch operation fails, but it depends on the JDBC driver whether they throw this exception or the base SQLException.</li>
            <li>java.sql.SQLWarning – For warning messages in SQL operations.</li>
            <li>java.sql.DataTruncation – when a data values is unexpectedly truncated for reasons other than its having exceeded MaxFieldSize.</li>
        </ol>
        <h3>What is “dirty read” in JDBC? Which isolation level prevents dirty read?</h3>
        <p>When we work with transactions, there is a chance that a row is updated and at the same time, another query can read the updated value. This results in a dirty read because the updated value is not permanent yet, the transaction that has updated the row can rollback to a previous value resulting in invalid data.</p>
        <p>Dirty Read is prevented by these isolation levels: TRANSACTION_READ_COMMITTED, TRANSACTION_REPEATABLE_READ, and TRANSACTION_SERIALIZABLE.</p>
        <h3>What is 2 phase commit?</h3>
            <p>In the first phase, the transaction manager sends commit-request to all the transaction resources. If all the transaction resources are OK, the transaction manager commits the transaction changes for all the resources. If any of the transaction resources responds as Abort, then the transaction manager can rollback all the transaction changes.</p>
        <h3>What is phantom read and which isolation level prevents it?</h3>
        <p>A phantom read is the situation where a transaction executes a query multiple times and gets different data.</p>
        <p>Suppose a transaction is executing a query to get data based on a condition and then another transaction inserts a row that matches the condition. Now when same transaction will execute the query again, a new row will be part of the result set. This new row is referred as Phantom Row and this situation is termed as Phantom Read.</p>
        <p>Phantom read can be prevented only with TRANSACTION_SERIALIZABLE isolation level.</p>
        <h3>What is SQL Warning? How to retrieve SQL warnings in the JDBC program?</h3>
        <p>SQLWarning is the subclass of SQLException and we can retrieve it by calling getWarnings() method on Connection, Statement, and ResultSet objects.</p>
        <p>SQL Warnings doesn’t stop the execution of the script but alerts the user about the warning.</p>
        <h3>When do we get java.sql.SQLException: No suitable driver found?</h3>
        <p>You get No suitable driver found exception when the SQL URL String is not properly formatted. You can get this exception in both simple java application using DriverManager or with JNDI resource using DataSource.</p>
        <h3>What are JDBC Best Practices?</h3>
        <ul>
            <li>Database resources are heavy, so make sure you close it as soon as you are done with it. Connection, Statement, ResultSet and all other JDBC objects have close() method defined to close them.</li>
            <li>Always close the result set, statement and connection explicitly in the code, because if you are working in connection pooling environment, the connection might be returned to the pool leaving open result sets and statement objects resulting in resource leak.</li>
            <li>Close the resources in the finally block to make sure they are closed even in case of exception scenarios.</li>
            <li>Use batch processing for bulk operations of similar kind.</li>
            <li>Always use PreparedStatement over Statement to avoid SQL Injection and get pre-compilation and caching benefits of PreparedStatement.</li>
            <li>If you are retrieving bulk data into result set, setting an optimal value for fetchSize helps in getting good performance.</li>
            <li>The database server might not support all isolation levels, so check it before assuming.</li>
            <li>More strict isolation levels result in slow performance, so make sure you have optimal isolation level set for your database connections.</li>
            <li>If you are creating database connections in a web application, try to use JDBC DataSource resources using JNDI context for re-using the connections.</li>
            <li>Try to use disconnected RowSet when you need to work with ResultSet for a long time.</li>
        </ul>
    </div>
    &nbsp;
    <button class="collapsible">Hibernate</button>
    <div class="content">
        <h3>What is the ORM Framework?</h3>
        <p>Object-relational mapping or ORM is the programming technique to map application domain model objects to the relational database tables.</p>
        <h3>What is the Hibernate Framework?</h3>
        <p>Hibernate is java based ORM tool that provides framework for mapping application domain objects to the relational database tables and vice versa.</p>
        <p>Hibernate framework provide option to map plain old java objects to traditional database tables with the use of JPA annotations as well as XML based configuration.</p>
        <h3>What are the core components of Hibernate?</h3>
        <ul>
            <li>Configuration</li>
            <li>SessionFactory</li>
            <li>Session</li>
            <li>Query</li>
            <li>Criteria</li>
            <li>Transaction</li>
        </ul>
        <h3>What is Java Persistence API (JPA)?</h3>
        <p>Java Persistence API (JPA) provides specification for managing the relational data in applications.</p>
        <p>JPA specifications is defined with annotations in javax.persistence package. Using JPA annotation helps us in writing implementation independent code.</p>
        <h3>What are the important benefits of using Hibernate Framework?</h3>
        <ol>
            <li>Hibernate eliminates all the boiler-plate code that comes with JDBC and takes care of managing resources, so we can focus on business logic.</li>
            <li>Hibernate framework provides support for XML as well as JPA annotations, that makes our code implementation independent.</li>
            <li>Hibernate provides a powerful query language (HQL) that is similar to SQL. However, HQL is fully object-oriented and understands concepts like inheritance, polymorphism and association.</li>
            <li>Hibernate is an open source project from Red Hat Community and used worldwide. This makes it a better choice than others because learning curve is small and there are tons of online documentations and help is easily available in forums.</li>
            <li>Hibernate is easy to integrate with other Java EE frameworks, it’s so popular that Spring Framework provides built-in support for integrating hibernate with Spring applications.</li>
            <li>Hibernate supports lazy initialization using proxy objects and perform actual database queries only when it’s required.</li>
            <li>Hibernate cache helps us in getting better performance.</li>
            <li>For database vendor specific feature, hibernate is suitable because we can also execute native sql queries.</li>
        </ol>
        <h3>What are the advantages of Hibernate over JDBC?</h3>
        <ol>
            <li>Hibernate removes a lot of boiler-plate code that comes with JDBC API, the code looks more cleaner and readable.</li>
            <li>Hibernate supports inheritance, associations and collections. These features are not present with JDBC API.</li>
            <li>Hibernate implicitly provides transaction management, in fact most of the queries can’t be executed outside transaction. In JDBC API, we need to write code for transaction management using commit and rollback. Read more at JDBC Transaction Management.</li>
            <li>JDBC API throws SQLException that is a checked exception, so we need to write a lot of try-catch block code. Most of the times it’s redundant in every JDBC call and used for transaction management. Hibernate wraps JDBC exceptions and throw JDBCException or HibernateException un-checked exception, so we don’t need to write code to handle it. Hibernate built-in transaction management removes the usage of try-catch blocks.</li>
            <li>Hibernate Query Language (HQL) is more object oriented and close to java programming language. For JDBC, we need to write native sql queries.</li>
            <li>Hibernate supports caching that is better for performance, JDBC queries are not cached hence performance is low.</li>
            <li>Hibernate provide option through which we can create database tables too, for JDBC tables must exist in the database.</li>
            <li>Hibernate configuration helps us in using JDBC like connection as well as JNDI DataSource for connection pool. This is very important feature in enterprise application and completely missing in JDBC API.</li>
            <li>Hibernate supports JPA annotations, so code is independent of implementation and easily replaceable with other ORM tools. JDBC code is very tightly coupled with the application.</li>
        </ol>
        <h3>Name some important interfaces of Hibernate framework?</h3>
        <ol>
            <li>SessionFactory (org.hibernate.SessionFactory): SessionFactory is an immutable thread-safe cache of compiled mappings for a single database. We need to initialize SessionFactory once and then we can cache and reuse it. SessionFactory instance is used to get the Session objects for database operations.</li>
            <li>Session (org.hibernate.Session): Session is a single-threaded, short-lived object representing a conversation between the application and the persistent store. It wraps JDBC java.sql.Connection and works as a factory for org.hibernate.Transaction. We should open session only when it’s required and close it as soon as we are done using it. Session object is the interface between java application code and hibernate framework and provide methods for CRUD operations.</li>
            <li>Transaction (org.hibernate.Transaction): Transaction is a single-threaded, short-lived object used by the application to specify atomic units of work. It abstracts the application from the underlying JDBC or JTA transaction. A org.hibernate.Session might span multiple org.hibernate.Transaction in some cases.</li>
        </ol>
        <h3>What is Hibernate SessionFactory and how to configure it?</h3>
        <p>SessionFactory is the factory class used to get the Session objects. SessionFactory is responsible for reading the hibernate configuration parameters and connect to the database and provide Session objects.</p>
        <p>The internal state of a SessionFactory is immutable. Once it is created this internal state is set. This internal state includes all of the metadata about Object/Relational Mapping.</p>
        <p>SessionFactory also provide methods to get the Class metadata and Statistics instance to get the stats of query executions, second level cache details etc.</p>
        <h3>What is a hibernate configuration file?</h3>
        <p>A Hibernate configuration file contains database specific configurations and is used to initialize SessionFactory. We provide database credentials or JNDI resource information in the hibernate configuration xml file. Some other important parts of hibernate configuration file is Dialect information, so that hibernate knows the database type and mapping file or class details.</p>
        <h3>What is hibernate mapping file?</h3>
        <p>A Hibernate mapping file is used to define the entity bean fields and database table column mappings. We know that JPA annotations can be used for mapping but sometimes XML mapping file comes in handy when we are using third party classes and we can’t use annotations.</p>
        <h3>Name some important annotations used for Hibernate mapping?</h3>
        <table>
            <tr>
                <td>javax.persistence.Entity</td>
                <td>Used with model classes to specify that they are entity beans.</td>
            </tr>
            <tr>
                <td>javax.persistence.Table</td>
                <td> Used with entity beans to define the corresponding table name in database.</td>
            </tr>
            <tr>
                <td>javax.persistence.Access</td>
                <td>Used to define the access type, either field or property. Default value is field and if you want hibernate to use getter/setter methods then you need to set it to property.</td>
            </tr>
            <tr>
                <td>javax.persistence.Id</td>
                <td>Used to define the primary key in the entity bean.</td>
            </tr>
            <tr>
                <td>javax.persistence.EmbeddedId</td>
                <td>Used to define composite primary key in the entity bean.</td>
            </tr>
            <tr>
                <td>javax.persistence.Column</td>
                <td>Used to define the column name in database table.</td>
            </tr>
            <tr>
                <td>javax.persistence.GeneratedValue</td>
                <td>Used to define the strategy to be used for generation of primary key. Used in conjunction with javax.persistence.GenerationType enum.</td>
            </tr>
            <tr>
                <td>javax.persistence.OneToOne</td>
                <td>Used to define the one-to-one mapping between two entity beans. We have other similar annotations as OneToMany, ManyToOne and ManyToMany</td>
            </tr>
            <tr>
                <td>org.hibernate.annotations.Cascade</td>
                <td>Used to define the cascading between two entity beans, used with mappings. It works in conjunction with org.hibernate.annotations.CascadeType</td>
            </tr>
            <tr>
                <td>javax.persistence.PrimaryKeyJoinColumn</td>
                <td>Used to define the property for foreign key. Used with org.hibernate.annotations.GenericGenerator and org.hibernate.annotations.Parameter</td>
            </tr>
        </table>
        <h3>Is Hibernate SessionFactory thread safe?</h3>
        <p>Internal state of SessionFactory is immutable, so it’s thread safe.</p>
        <h3>What is Hibernate Session and how to get it?</h3>
        <p>Hibernate Session is the interface between java application layer and hibernate. This is the core interface used to perform database operations. Lifecycle of a session is bound by the beginning and end of a transaction.</p>
        <p>Session provides methods to perform create, read, update and delete operations for a persistent object. We can execute HQL queries, SQL native queries and create criteria using Session object.</p>
        <h3>Is Hibernate Session thread safe?</h3>
        <p>Hibernate Session object is not thread safe, every thread should get it’s own session instance and close it after it’s work is finished.</p>
        <h3>What is difference between openSession and getCurrentSession?</h3>
        <p>Hibernate SessionFactory getCurrentSession() method returns the session bound to the context. But for this to work, we need to configure it in hibernate configuration file.</p>
        <p>Hibernate SessionFactory openSession() method always opens a new session. We should close this session object once we are done with all the database operations. We should open a new session for each request in multi-threaded environment.</p>
        <h3>What is boilerplate code (boilerplate)</h3>
        <p>boilerplate are sections of code that have to be included in many places with little or no alteration.</p>
        <p>The programmer must write a lot of code to accomplish only minor functionality.</p>
        <h3>What is difference between Hibernate Session get() and load() method?</h3>
        <ol>
            <li>get() loads the data as soon as it’s called whereas load() returns a proxy object and loads data only when it’s actually required, so load() is better because it support lazy loading.</li>
            <li>Since load() throws exception when data is not found, we should use it only when we know data exists.</li>
            <li>We should use get() when we want to make sure data exists in the database.</li>
        </ol>
        <h3>What is hibernate caching? Explain Hibernate first level cache?</h3>
        <p>As the name suggests, hibernate caches query data to make our application faster. Hibernate Cache can be very useful in gaining fast application performance if used correctly. The idea behind cache is to reduce the number of database queries, hence reducing the throughput time of the application.</p>
        <h3>What are different states of an entity bean?</h3>
        <ol>
            <li>Transient: When an object is never persisted or associated with any session, it’s in transient state. Transient instances may be made persistent by calling save(), persist() or saveOrUpdate(). Persistent instances may be made transient by calling delete().</li>
            <li>Persistent: When an object is associated with a unique session, it’s in persistent state. Any instance returned by a get() or load() method is persistent.</li>
            <li>Detached: When an object is previously persistent but not associated with any session, it’s in detached state. Detached instances may be made persistent by calling update(), saveOrUpdate(), lock() or replicate(). The state of a transient or detached instance may also be made persistent as a new persistent instance by calling merge().</li>
        </ol>
        <h3>What is use of Hibernate Session merge() call?</h3>
        <p>merge can be used to get a fresh copy of an entity, discarding changes made while in a detached state and returning an object in a persistent state.</p>
        <h3>What is difference between Hibernate save(), saveOrUpdate() and persist() methods?</h3>
        <table>
            <tr>
                <td>save()</td>
                <td>Hibernate save can be used to save entity to database. Problem with save() is that it can be invoked without a transaction and if we have mapping entities, then only the primary object gets saved causing data inconsistencies. Also save returns the generated id immediately.</td>
            </tr>
            <tr>
                <td>persist()</td>
                <td>Hibernate persist is similar to save, but with a transaction. We can’t use it outside the boundary of transaction, so all the object mappings are preserved. Also persist doesn’t return the generated id immediately, so data persistence happens when needed.</td>
            </tr>
            <tr>
                <td>saveOrUpdate()</td>
                <td>Hibernate saveOrUpdate results in insert or update queries based on the provided data. If the data is present in the database, update query is executed. We can use saveOrUpdate() without transaction also, but again you will face the issues with mapped objects not getting saved if session is not flushed.</td>
            </tr>
        </table>
        <h3>What will happen if we don’t have a no-args constructor in Entity bean?</h3>
        <p>Hibernate uses Reflection API to create instance of Entity beans, usually when you call get() or load() methods. The method Class.newInstance() is used for this and it requires no-args constructor. So if you won’t have no-args constructor in entity beans, hibernate will fail to instantiate it and you will get HibernateException.</p>
        <h3>What are the collection types in Hibernate?</h3>
        <ol>
            <li>Bag</li>
            <li>Set</li>
            <li>List</li>
            <li>Array</li>
            <li>Map</li>
        </ol>
        <h3>How to implement Joins in Hibernate?</h3>
        <ul>
            <li>Using associations such as one-to-one, one-to-many etc.</li>
            <li>Using JOIN in the HQL query. There is another form “join fetch” to load associated data simultaneously, no lazy loading.</li>
            <li>We can fire native sql query and use join keyword.</li>
        </ul>
        <h3>Why we should not make Entity Class final?</h3>
        <p>Hibernate use proxy classes for lazy loading of data, only when it’s needed. This is done by extending the entity bean, if the entity bean will be final then lazy loading will not be possible, hence low performance.</p>
        <h3>What is HQL and what are it’s benefits?</h3>
        <p>HQL: Hibernate Query Language, is a better choice than SQL queries because we use Objects instead of table names, which makes it closer to object oriented programming.</p>
        <p>Hibernate query language is case-insensitive except for java class and variable names.</p>
        <h3>Can we execute native sql query in hibernate?</h3>
        <p>Hibernate provide option to execute native SQL queries through the use of SQLQuery object.</p>
        <h3>What is the benefit of native sql query support in hibernate?</h3>
        <p>Native SQL Query comes handy when we want to execute database specific queries that are not supported by Hibernate API such as query hints or the CONNECT keyword in Oracle Database.</p>
        <h3>What is Named SQL Query?</h3>
        <p>Hibernate provides Named Query that we can define at a central location and use them anywhere in the code. We can created named queries for both HQL and Native SQL.</p>
        <p>Hibernate Named Queries can be defined in Hibernate mapping files or through the use of JPA annotations @NamedQuery and @NamedNativeQuery.</p>
        <h3>What are the benefits of Named SQL Query?</h3>
        <ul>
            <li>Hibernate Named Query helps us in grouping queries at a central location rather than letting them scattered all over the code.</li>
            <li>Hibernate Named Query syntax is checked when the hibernate session factory is created, thus making the application fail fast in case of any error in the named queries.</li>
            <li>Hibernate Named Query is global, means once defined it can be used throughout the application.</li>
        </ul>
        <p>However one of the major disadvantage of Named query is that it’s hard to debug, because we need to find out the location where it’s defined.</p>
        <h3>What is the benefit of Hibernate Criteria API?</h3>
        <p>Hibernate provides Criteria API that is more object oriented for querying the database and getting results. We can’t use Criteria to run update or delete queries or any DDL statements. It’s only used to fetch the results from the database using more object oriented approach.</p>
        <ul>
            <li>Criteria API provides Projection that we can use for aggregate functions such as sum(), min(), max() etc.</li>
            <li>Criteria API can be used with ProjectionList to fetch selected columns only.</li>
            <li>Criteria API can be used for join queries by joining multiple tables, useful methods are createAlias(), setFetchMode() and setProjection()</li>
            <li>Criteria API can be used for fetching results with conditions, useful methods are add() where we can add Restrictions.</li>
            <li>Criteria API provides addOrder() method that we can use for ordering the results.</li>
        </ul>
        <h3>What is Hibernate Proxy and how it helps in lazy loading?</h3>
        <p>Hibernate uses proxy object to support lazy loading. Basically when you load data from tables, hibernate doesn’t load all the mapped objects. As soon as you reference a child or lookup object via getter methods, if the linked entity is not in the session cache, then the proxy code will go to the database and load the linked object. It uses javassist to effectively and dynamically generate sub-classed implementations of your entity objects.</p>
        <h3>How to implement relationships in hibernate?</h3>
        <p>We can easily implement one-to-one, one-to-many and many-to-many relationships in hibernate. It can be done using JPA annotations as well as XML based configurations.</p>
        <h3>How transaction management works in Hibernate?</h3>
        <p>Transaction management is very easy in hibernate because most of the operations are not permitted outside of a transaction. So after getting the session from SessionFactory, we can call session beginTransaction() to start the transaction.</p>
        <h3>What are best practices to follow with Hibernate framework?</h3>
        <ul>
            <li>Always check the primary key field access, if it’s generated at the database layer then you should not have a setter for this.</li>
            <li>By default hibernate set the field values directly, without using setters. So if you want hibernate to use setters, then make sure proper access is defined as @Access(value=AccessType.PROPERTY).</li>
            <li>If access type is property, make sure annotations are used with getter methods and not setter methods. Avoid mixing of using annotations on both filed and getter methods.</li>
            <li>Use native sql query only when it can’t be done using HQL, such as using database specific feature.</li>
            <li>If you have to sort the collection, use ordered list rather than sorting it using Collection API.</li>
            <li>Use named queries wisely, keep it at a single place for easy debugging. Use them for commonly used queries only. For entity specific query, you can keep them in the entity bean itself.</li>
            <li>For web applications, always try to use JNDI DataSource rather than configuring to create connection in hibernate.</li>
            <li>Avoid Many-to-Many relationships, it can be easily implemented using bidirectional One-to-Many and Many-to-One relationships.</li>
            <li>For collections, try to use Lists, maps and sets. Avoid array because you don’t get benefit of lazy loading.</li>
            <li>Do not treat exceptions as recoverable, roll back the Transaction and close the Session. If you do not do this, Hibernate cannot guarantee that in-memory state accurately represents the persistent state.</li>
            <li>Prefer DAO pattern for exposing the different methods that can be used with entity bean</li>
            <li>Prefer lazy fetching for associations</li>
        </ul>
    </div>
    &nbsp;
    <button class="collapsible">Spring</button>
    <div class="content">
    <h3>What is Spring Framework?</h3>
        <p>The Spring Framework uses Dependency Injection and Aspect Oriented Programming to achieve a loose coupling between components and cross-cutting tasks.</p>
    <h3>What are some of the important features of Spring?</h3>
        <ul>
            <li>Lightweight and very little overhead of using framework for our development.</li>
            <li>Dependency Injection or Inversion of Control to write components that are independent of each other, spring container takes care of wiring them together to achieve our work.</li>
            <li>Spring IoC container manages Spring Bean life cycle and project specific configurations such as JNDI lookup.</li>
            <li>Spring MVC framework can be used to create web applications as well as restful web services capable of returning XML as well as JSON response.</li>
            <li>Support for transaction management, JDBC operations, File uploading, Exception Handling etc with very little configurations, either by using annotations or by spring bean configuration file.</li>
        </ul>
    <h3>What are some advantages of using Spring?</h3>
        <ul>
            <li>Reducing direct dependencies between different components of the application, usually Spring IoC container is responsible for initializing resources or beans and inject them as dependencies.</li>
            <li>Writing unit test cases are easy in Spring framework because our business logic doesn’t have direct dependencies with actual resource implementation classes. We can easily write a test configuration and inject our mock beans for testing purposes.</li>
            <li>Reduces the amount of boiler-plate code, such as initializing objects, open/close resources. I like JdbcTemplate class a lot because it helps us in removing all the boiler-plate code that comes with JDBC programming.</li>
            <li>Spring framework is divided into several modules, it helps us in keeping our application lightweight. For example, if we don’t need Spring transaction management features, we don’t need to add that dependency on our project.</li>
        </ul>
    <h3>What is Dependency Injection?</h3>
        <p>Dependency Injection design pattern allows us to remove the hard-coded dependencies and make our application loosely coupled, extendable and maintainable.</p>
        <p>We can implement dependency injection pattern to move the dependency resolution from compile-time to runtime.</p>
    <h3>How do we implement DI in Spring?</h3>
        <p>We can use Spring XML and Annotation-based configuration to implement DI in spring applications.</p>
    <h3>What are the benefits of using Spring Tool Suite?</h3>
        <ul>
            <li>Templates for creating different types of Spring projects.</li>
            <li>It highlights the Spring components and if you are using AOP pointcuts and advice, then it clearly shows which methods will come under the specific pointcut.</li>
        </ul>
    <h3>Name some of the important Spring Modules?</h3>
        <ul>
            <li>Spring Context – for dependency injection.</li>
            <li>Spring AOP – for aspect oriented programming.</li>
            <li>Spring DAO – for database operations using DAO pattern</li>
            <li>Spring JDBC – for JDBC and DataSource support.</li>
            <li>Spring ORM – for ORM tools support such as Hibernate</li>
            <li>Spring Web Module – for creating web applications.</li>
            <li>Spring MVC – Model-View-Controller implementation for creating web applications, web services etc.</li>
        </ul>
    <h3>What is Aspect Oriented Programming?</h3>
        <p>In Object Oriented Programming, modularity of application is achieved by Classes whereas in AOP application modularity is achieved by Aspects and they are configured to cut across different classes methods.</p>
        <p>AOP takes out the direct dependency of cross-cutting tasks from classes that are not possible in normal object-oriented programming.</p>
    <h3>What is Aspect, Advice, Pointcut, JointPoint and Advice Arguments in AOP?</h3>
        <ul>
            <li>Aspect: Aspect is a class that implements cross-cutting concerns, such as transaction management.</li>
                <p>Aspects can be a normal class configured and then configured in Spring Bean configuration file or we can use Spring AspectJ support to declare a class as Aspect using @Aspect annotation.</p>
            <li>Advice: Advice is the action taken for a particular join point.</li>
                <p>In terms of programming, they are methods that gets executed when a specific join point with matching pointcut is reached in the application. You can think of Advices as Spring interceptors or Servlet Filters.</p>
            <li>Pointcut: Pointcut are regular expressions that are matched with join points to determine whether advice needs to be executed or not.</li>
                <p>Pointcut uses different kinds of expressions that are matched with the join points. Spring framework uses the AspectJ pointcut expression language for determining the join points where advice methods will be applied.</p>
            <li>Join Point: A join point is a specific point in the application such as method execution, exception handling, changing object variable values etc. In Spring AOP a join point is always the execution of a method.</li><br>
            <li>Advice Arguments: We can pass arguments in the advice methods.</li>
                <p>We can use args() expression in the pointcut to be applied to any method that matches the argument pattern. If we use this, then we need to use the same name in the advice method from where the argument type is determined.</p>
        </ul>
        <h3>What is the difference between Spring AOP and AspectJ AOP?</h3>
        <ul>
            <li>Spring AOP is simpler to use than AspectJ because we don’t need to worry about the weaving process.</li>
            <li>Spring AOP supports AspectJ annotations, so if you are familiar with AspectJ then working with Spring AOP is easier.</li>
            <li>Spring AOP supports only proxy-based AOP, so it can be applied only to method execution join points. AspectJ support all kinds of pointcuts.</li>
            <li>One of the shortcomings of Spring AOP is that it can be applied only to the beans created through Spring Context.</li>
        </ul>
        <h3>What is Spring IoC Container?</h3>
        <p>Inversion of Control (IoC) is the mechanism to achieve loose-coupling between Objects dependencies. To achieve loose coupling and dynamic binding of the objects at runtime, the objects define their dependencies that are being injected by other assembler objects. Spring IoC container is the program that injects dependencies into an object and makes it ready for our use.</p>
        <p>Some of the useful ApplicationContext implementations that we use are:</p>
        <ul>
            <li>AnnotationConfigApplicationContext: For standalone java applications using annotations based configuration.</li>
            <li>ClassPathXmlApplicationContext: For standalone java applications using XML based configuration.</li>
            <li>FileSystemXmlApplicationContext: Similar to ClassPathXmlApplicationContext except that the xml configuration file can be loaded from anywhere in the file system.</li>
            <li>AnnotationConfigWebApplicationContext and XmlWebApplicationContext for web applications.</li>
        </ul>
        <h3>What is a Spring Bean?</h3>
        <p>Any normal java class that is initialized by Spring IoC container is called Spring Bean. We use Spring ApplicationContext to get the Spring Bean instance.</p>
        <p>Spring IoC container manages the life cycle of Spring Bean, bean scopes and injecting any required dependencies in the bean.</p>
        <h3>What is the importance of the Spring bean configuration file?</h3>
        <p>We use Spring Bean configuration file to define all the beans that will be initialized by Spring Context. When we create the instance of Spring ApplicationContext, it reads the spring bean XML file and initializes all of them. Once the context is initialized, we can use it to get different bean instances.</p>
        <h3>What are the different ways to configure a class as Spring Bean?</h3>
        <ol>
            <li>XML Configuration: This is the most popular configuration and we can use bean element in context file to configure a Spring Bean.</li>
            <li>Java Based Configuration: If you are using only annotations, you can configure a Spring bean using @Bean annotation. This annotation is used with @Configuration classes to configure a spring bean.</li>
            <li>Annotation Based Configuration: We can also use @Component, @Service, @Repository and @Controller annotations with classes to configure them to be as spring bean. For these, we would need to provide base package location to scan for these classes.</li>
        </ol>
        <h3>What are different scopes of Spring Bean?</h3>
        <ol>
            <li>singleton: Only one instance of the bean will be created for each container. This is the default scope for the spring beans.</li>
            <li>prototype: A new instance will be created every time the bean is requested.</li>
            <li>request: This is same as prototype scope, however it’s meant to be used for web applications. A new instance of the bean will be created for each HTTP request.</li>
            <li>session: A new bean will be created for each HTTP session by the container.</li>
            <li>global-session: This is used to create global session beans for Portlet applications.</li>
        </ol>
        <h3>What is Spring Bean life cycle?</h3>
        <ol>
            <li>Spring Beans are initialized by Spring Container.</li>
            <li>The dependencies are injected.</li>
            <li>When the context is destroyed, it also destroys all the initialized beans.</li>
            <p>We also have post processing methods that occur when creating or destroying a bean.</p>
            <p>Implementing InitializingBean and DisposableBean interfaces or using init-method and destroy-method attribute in spring bean configurations.</p>
        </ol>
        <h3>How we get ServletContext and ServletConfig objects in a Spring Bean?</h3>
        <ol>
            <li>Implementing Spring *Aware interfaces, for these ServletContextAware and ServletConfigAware interfaces.</li>
            <li>Using @Autowired annotation with bean variable of type ServletContext and ServletConfig.</li>
        </ol>
        <h3>What is Bean wiring and @Autowired annotation?</h3>
        <p>The process of injection spring bean dependencies while initializing it called Spring Bean Wiring.</p>
        <p>Usually, it’s best practice to do the explicit wiring of all the bean dependencies, but the spring framework also supports auto-wiring. We can use @Autowired annotation with fields or methods for autowiring byType. For this annotation to work, we also need to enable annotation-based configuration in spring bean configuration file. This can be done by context:annotation-config element.</p>
        <h3>What are different types of Spring Bean autowiring?</h3>
        <ol>
            <li>autowire byName</li>
            <li>autowire byType</li>
            <li>autowire by constructor</li>
            <li>autowiring by @Autowired and @Qualifier annotations</li>
        </ol>
        <h3>Does Spring Bean provide thread safety?</h3>
        <p>The default scope of Spring bean is singleton, so there will be only one instance per context.</p>
        <p>That means that all the having a class level variable that any thread can update will lead to inconsistent data. Hence in default mode spring beans are not thread-safe.</p>
    </div>
</div>
<!-- Javascript controlling the click functionality for the collapsible boxes -->
<script>
    var coll = document.getElementsByClassName("collapsible");
    var i;

    for (i = 0; i < coll.length; i++) {
        coll[i].addEventListener("click", function() {
            this.classList.toggle("active");
            var content = this.nextElementSibling;
            if (content.style.display === "block") {
                content.style.display = "none";
            } else {
                content.style.display = "block";
            }
        });
    }
</script>
</body>
</html>